// -----------------------------------------------------------------------------
// Copyright (C) 2023 David Hansel
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
// -----------------------------------------------------------------------------

#include <Arduino.h>
#include "ConverterTandyMPS801.h"


#define MODE_MPS801_STANDARD    0
#define MODE_MPS801_GRAPHICS    1
#define MODE_MPS801_DWIDTH      2
#define MODE_MPS801_REVERSE     4
#define MODE_MPS801_CURSORDOWN  8
#define MODE_MPS801_TAB        16


static const byte font[162*6] PROGMEM = 
  {0x00,0x00,0x00,0x00,0x00,0x00, // 00: (space)
   0x00,0x00,0x5F,0x00,0x00,0x00, // 01: !
   0x00,0x07,0x00,0x07,0x00,0x00, // 02: "
   0x14,0x7F,0x14,0x7F,0x14,0x00, // 03: #
   0x24,0x2A,0x7F,0x2A,0x12,0x00, // 04: $
   0x63,0x13,0x08,0x64,0x63,0x00, // 05: %
   0x30,0x4E,0x59,0x26,0x50,0x00, // 06: &
   0x00,0x04,0x02,0x01,0x00,0x00, // 07: '
   0x00,0x1C,0x22,0x41,0x00,0x00, // 08: (
   0x00,0x41,0x22,0x1C,0x00,0x00, // 09: )
   0x2A,0x1C,0x7F,0x1C,0x2A,0x00, // 0A: *
   0x08,0x08,0x3E,0x08,0x08,0x00, // 0B: +
   0x00,0x40,0x30,0x00,0x00,0x00, // 0C: ,
   0x08,0x08,0x08,0x08,0x08,0x00, // 0D: -
   0x00,0x60,0x60,0x00,0x00,0x00, // 0E: .
   0x60,0x10,0x08,0x04,0x03,0x00, // 0F: /
   0x3E,0x51,0x49,0x45,0x3E,0x00, // 10: 0
   0x00,0x42,0x7F,0x40,0x00,0x00, // 11: 1
   0x62,0x51,0x51,0x49,0x46,0x00, // 12: 2
   0x22,0x41,0x49,0x49,0x36,0x00, // 13: 3
   0x18,0x14,0x12,0x7F,0x10,0x00, // 14: 4
   0x27,0x45,0x45,0x45,0x39,0x00, // 15: 5
   0x3C,0x4A,0x49,0x49,0x31,0x00, // 16: 6
   0x01,0x71,0x09,0x05,0x03,0x00, // 17: 7
   0x36,0x49,0x49,0x49,0x36,0x00, // 18: 8
   0x46,0x49,0x49,0x29,0x1E,0x00, // 19: 9
   0x00,0x00,0x12,0x00,0x00,0x00, // 1A: :
   0x00,0x40,0x32,0x00,0x00,0x00, // 1B: ;
   0x08,0x14,0x22,0x41,0x41,0x00, // 1C: <
   0x14,0x14,0x14,0x14,0x14,0x00, // 1D: =
   0x41,0x41,0x22,0x14,0x08,0x00, // 1E: >
   0x02,0x01,0x51,0x09,0x06,0x00, // 1F: ?
   0x3E,0x41,0x5D,0x55,0x5E,0x00, // 20: @
   0x7E,0x09,0x09,0x09,0x7E,0x00, // 21: A
   0x41,0x7F,0x49,0x49,0x36,0x00, // 22: B
   0x3E,0x41,0x41,0x41,0x22,0x00, // 23: C
   0x41,0x7F,0x41,0x41,0x3E,0x00, // 24: D
   0x7F,0x49,0x49,0x49,0x41,0x00, // 25: E
   0x7F,0x09,0x09,0x09,0x01,0x00, // 26: F
   0x3E,0x41,0x41,0x49,0x3A,0x00, // 27: G
   0x7F,0x08,0x08,0x08,0x7F,0x00, // 28: H
   0x00,0x41,0x7F,0x41,0x00,0x00, // 29: I
   0x20,0x40,0x41,0x3F,0x01,0x00, // 2A: J
   0x7F,0x08,0x14,0x22,0x41,0x00, // 2B: K
   0x7F,0x40,0x40,0x40,0x40,0x00, // 2C: L
   0x7F,0x02,0x0C,0x02,0x7F,0x00, // 2D: M
   0x7F,0x04,0x08,0x10,0x7F,0x00, // 2E: N
   0x3E,0x41,0x41,0x41,0x3E,0x00, // 2F: O
   0x7F,0x09,0x09,0x09,0x06,0x00, // 30: P
   0x3E,0x41,0x51,0x21,0x5E,0x00, // 31: Q
   0x7F,0x09,0x19,0x29,0x46,0x00, // 32: R
   0x26,0x49,0x49,0x49,0x32,0x00, // 33: S
   0x01,0x01,0x7F,0x01,0x01,0x00, // 34: T
   0x3F,0x40,0x40,0x40,0x3F,0x00, // 35: U
   0x07,0x18,0x60,0x18,0x07,0x00, // 36: V
   0x7F,0x20,0x18,0x20,0x7F,0x00, // 37: W
   0x63,0x14,0x08,0x14,0x63,0x00, // 38: X
   0x07,0x08,0x78,0x08,0x07,0x00, // 39: Y
   0x61,0x51,0x49,0x45,0x43,0x00, // 3A: Z
   0x00,0x7F,0x41,0x41,0x00,0x00, // 3B: [
   0x48,0x7E,0x49,0x49,0x42,0x00, // 3C: (pound)
   0x00,0x41,0x41,0x7F,0x00,0x00, // 3D: ]
   0x00,0x04,0x02,0x7F,0x02,0x04, // 3E: (arrow up)
   0x08,0x1C,0x2A,0x08,0x08,0x08, // 3F: (arrow left)
   0x08,0x08,0x08,0x08,0x08,0x08, // 40: (horizontal middle bar)
   0x20,0x54,0x54,0x3C,0x40,0x00, // 41: a
   0x7F,0x48,0x44,0x44,0x38,0x00, // 42: b
   0x38,0x44,0x44,0x44,0x44,0x00, // 43: c
   0x38,0x44,0x44,0x48,0x7F,0x00, // 44: d
   0x38,0x54,0x54,0x54,0x08,0x00, // 45: e
   0x08,0x7E,0x09,0x01,0x02,0x00, // 46: f
   0x0C,0x52,0x52,0x52,0x3C,0x00, // 47: g
   0x7F,0x08,0x04,0x04,0x78,0x00, // 48: h
   0x00,0x44,0x7D,0x40,0x00,0x00, // 49: i
   0x00,0x20,0x40,0x3D,0x00,0x00, // 4A: j
   0x7F,0x10,0x28,0x44,0x00,0x00, // 4B: k
   0x00,0x01,0x7F,0x40,0x00,0x00, // 4C: l
   0x7C,0x04,0x38,0x04,0x78,0x00, // 4D: m
   0x04,0x78,0x04,0x04,0x78,0x00, // 4E: n
   0x38,0x44,0x44,0x44,0x38,0x00, // 4F: o
   0x7E,0x12,0x12,0x0C,0x00,0x00, // 50: p
   0x0C,0x12,0x12,0x7E,0x00,0x00, // 51: q
   0x7C,0x08,0x04,0x04,0x08,0x00, // 52: r
   0x48,0x54,0x54,0x54,0x20,0x00, // 53: s
   0x04,0x3F,0x44,0x44,0x20,0x00, // 54: t
   0x3C,0x40,0x40,0x3C,0x40,0x00, // 55: u
   0x0C,0x30,0x40,0x30,0x0C,0x00, // 56: v
   0x3C,0x40,0x30,0x40,0x3C,0x00, // 57: w
   0x44,0x28,0x10,0x28,0x44,0x00, // 58: x
   0x4C,0x50,0x50,0x3C,0x00,0x00, // 59: y
   0x44,0x64,0x54,0x4C,0x44,0x00, // 5A: z
   0x08,0x08,0x08,0x7F,0x08,0x08, // 5B: (full cross)
   0x55,0x2A,0x55,0x00,0x00,0x00, // 5C: (left checkerboad)
   0x00,0x00,0x00,0x7F,0x00,0x00, // 5D: (vertical middle bar)
   0x73,0x73,0x0C,0x0C,0x73,0x73, // 5E: (coarse full checkerboard)
   0x24,0x49,0x12,0x24,0x49,0x12, // 5F: (downward diagonal lines)
   0x08,0x08,0x08,0x08,0x08,0x08, // 60: (row 4 bar)
   0x1C,0x4E,0x7F,0x4E,0x1C,0x00, // 61: shift-A: (spades)
   0x00,0x00,0x7F,0x00,0x00,0x00, // 62: shift-B: (column 3 bar)
   0x04,0x04,0x04,0x04,0x04,0x04, // 63: shift-C: (row 3 bar)
   0x02,0x02,0x02,0x02,0x02,0x02, // 64: shift-D: (row 2 bar)
   0x01,0x01,0x01,0x01,0x01,0x01, // 65: shift-E: (row 1 bar)
   0x20,0x20,0x20,0x20,0x20,0x20, // 66: shift-F: (row 5 bar)
   0x00,0x7F,0x00,0x00,0x00,0x00, // 67: shift-G: (column 2 bar)
   0x00,0x00,0x00,0x00,0x7F,0x00, // 68: shift-H: (column 5 bar)
   0x08,0x08,0x10,0x60,0x00,0x00, // 69: shift-I: (bottom left rounded corner)
   0x00,0x00,0x00,0x03,0x04,0x08, // 6A: shift-J: (top right rounded corner)
   0x08,0x08,0x04,0x03,0x00,0x00, // 6B: shift-K: (top left rounded corner)
   0x7F,0x40,0x40,0x40,0x40,0x40, // 6C: shift-L: (bottom left L)
   0x02,0x04,0x08,0x10,0x20,0x40, // 6D: shift-M: (downward full diagonal)
   0x40,0x20,0x10,0x08,0x04,0x02, // 6E: shift-N: (upward full diagonal)
   0x7F,0x01,0x01,0x01,0x01,0x01, // 6F: shift-O: (top left L)
   0x01,0x01,0x01,0x01,0x01,0x7F, // 70: shift-P: (top right L)
   0x3C,0x7E,0x7E,0x7E,0x3C,0x00, // 71: shift-Q: (ball)
   0x20,0x20,0x20,0x20,0x20,0x20, // 72: shift-R: (row 6 bar)
   0x1C,0x3E,0x7C,0x3E,0x1C,0x00, // 73: shift-S: (heart)
   0x00,0x7F,0x00,0x00,0x00,0x00, // 74: shift-T: (column 2 bar)
   0x00,0x00,0x00,0x60,0x10,0x08, // 75: shift-U: (bottom right rounded corner)
   0x42,0x24,0x18,0x18,0x24,0x42, // 76: shift-V: (full X)
   0x3C,0x42,0x42,0x42,0x3C,0x00, // 77: shift-W: (circle)
   0x1C,0x0A,0x7F,0x0A,0x1C,0x00, // 78: shift-X: (empty spades)
   0x00,0x00,0x00,0x00,0x7F,0x00, // 79: shift-Y: (column 5 bar)
   0x18,0x3C,0x7E,0x3C,0x18,0x00, // 7A: shift-Z: (diamond)
   0x08,0x08,0x08,0x7F,0x08,0x08, // 7B: (full cross)
   0x55,0x2A,0x55,0x00,0x00,0x00, // 7C: (left checkerboard)
   0x00,0x00,0x00,0x7F,0x00,0x00, // 7D: (vertical middle bar)
   0x08,0x7C,0x04,0x7C,0x04,0x00, // 7E: (pi)
   0x01,0x03,0x07,0x0F,0x1F,0x3F, // 7F: (top-right triangle)
   0x00,0x00,0x00,0x00,0x00,0x00, // 80: (space)
   0x7F,0x7F,0x7F,0x00,0x00,0x00, // 81: (left half-block)
   0x78,0x78,0x78,0x78,0x78,0x78, // 82: (bottom half-block)
   0x01,0x01,0x01,0x01,0x01,0x01, // 83: (top line)
   0x40,0x40,0x40,0x40,0x40,0x40, // 84: (bottom line)
   0x7F,0x00,0x00,0x00,0x00,0x00, // 85: (left line)
   0x55,0x2A,0x55,0x2A,0x55,0x2A, // 86: (fine full checkerboard)
   0x00,0x00,0x00,0x00,0x00,0x7F, // 87: (right line)
   0x50,0x28,0x50,0x28,0x50,0x28, // 88: (bottom half checkerboard)
   0x3F,0x1F,0x0F,0x07,0x03,0x01, // 89: (top left triangle)
   0x00,0x00,0x00,0x00,0x00,0x7F, // 8A: (right line)
   0x00,0x00,0x00,0x7F,0x08,0x08, // 8B: (right T-junction)
   0x00,0x00,0x00,0x78,0x78,0x78, // 8C: (bottom right block)
   0x00,0x00,0x00,0x0F,0x08,0x08, // 8D: (top-right corner)
   0x08,0x08,0x08,0x78,0x00,0x00, // 8E: (bottom-left corner)
   0x60,0x60,0x60,0x60,0x60,0x60, // 8F: (double bottom line)
   0x00,0x00,0x00,0x78,0x08,0x08, // 90: (bottom right corner)
   0x08,0x08,0x08,0x0F,0x08,0x08, // 91: (top T-junction)
   0x08,0x08,0x08,0x78,0x08,0x08, // 92: (bottom T-junction)
   0x08,0x08,0x08,0x7F,0x00,0x00, // 93: (left T-junction)
   0x7F,0x00,0x00,0x00,0x00,0x00, // 94: (left line)
   0x7F,0x7F,0x00,0x00,0x00,0x00, // 95: (double left line)
   0x00,0x00,0x00,0x00,0x7F,0x7F, // 96: (right block)
   0x01,0x01,0x01,0x01,0x01,0x01, // 97: (top line)
   0x03,0x03,0x03,0x03,0x03,0x03, // 98: (double top line)
   0x70,0x70,0x70,0x70,0x70,0x70, // 99: (bottom block)
   0x40,0x40,0x40,0x40,0x40,0x7F, // 9A: (bottom right L)
   0x78,0x78,0x78,0x00,0x00,0x00, // 9B: (bottom left block)
   0x00,0x00,0x00,0x07,0x07,0x07, // 9C: (top right block)
   0x08,0x08,0x08,0x0F,0x00,0x00, // 9D: (top left corner)
   0x07,0x07,0x07,0x00,0x00,0x00, // 9E: (top left block)
   0x07,0x07,0x07,0x78,0x78,0x78, // 9F: (top left and bottom right block)
   0x78,0x20,0x10,0x08,0x04,0x00, // A0: (checkmark)
   0x12,0x49,0x24,0x12,0x49,0x24  // A1: (upward diagonal lines)
};


static const byte charset_standard[256] PROGMEM = 
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x7e  
  };


static const byte charset_business[256] PROGMEM = 
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 
    0x20, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
    0x40, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0xa1, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0xa0, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 
    0x40, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0xa1, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0xa0, 0x9b, 0x9c, 0x9d, 0x9e, 0x5e
  };




ConverterTandyMPS801::ConverterTandyMPS801() : Converter()
{
  m_mode = MODE_MPS801_STANDARD;
  m_dotcolumn = 0;
}


void ConverterTandyMPS801::begin()
{
  m_mode = MODE_MPS801_STANDARD;
  m_cmdbytes = 0;
}


void ConverterTandyMPS801::setChannel(byte channel)
{
  if( channel==7 )
    m_mode |=  MODE_MPS801_CURSORDOWN;
  else
    m_mode &= ~MODE_MPS801_CURSORDOWN;
}


void ConverterTandyMPS801::convert()
{
  // only proceed if we have enough space to write 10 or more bytes
  if( canRead()>0 && canWrite()>=10 )
    {
      byte data = read();

      if( m_cmdbytes>0 )
        {
          if( m_mode & MODE_MPS801_TAB )
            {
              static byte tab1;
              if( m_cmdbytes==2 )
                {
                  tab1 = data;
                  m_cmdbytes = 1;
                }
              else
                {                
                  m_dotcolumn = ((tab1&0x0F)*10 + (data&0x0F)) * 6;
                  write(27);
                  write(16);
                  write(m_dotcolumn / 256);
                  write(m_dotcolumn & 255);
                  m_mode &= ~MODE_MPS801_TAB;
                  m_cmdbytes = 0;
                }
            }
          else
            {
              write(data);
              m_cmdbytes--;
            }
        }
      else if( (m_mode & MODE_MPS801_GRAPHICS) && data>=128 )
        {
          write(data);
          m_dotcolumn += (m_mode & MODE_MPS801_DWIDTH) ? 2 : 1;
          if( m_dotcolumn>=480 ) m_dotcolumn = 0;
        }
      else
        {
          switch( data )
            {
            case 8: // enter graphics mode
              write(18);
              m_mode = MODE_MPS801_GRAPHICS;
              break;

            case 10:
            case 13:
              if( m_mode & MODE_MPS801_GRAPHICS )
                write(data);
              else
                { write(30); write(data); write(18); }
              if( data==13 ) m_mode &= ~(MODE_MPS801_CURSORDOWN|MODE_MPS801_REVERSE);
              m_dotcolumn = 0;
              break;

            case 14: // double width
              write(27);
              write(14);
              m_mode |= MODE_MPS801_DWIDTH;
              break;

            case 15: // standard mode (clear all others)
              if( m_mode & MODE_MPS801_DWIDTH ) { write(27); write(15); }
              m_mode = MODE_MPS801_STANDARD;
              break;

            case 16: // TAB setting the print head (followed by two characters specifying column
              m_mode |= MODE_MPS801_TAB;
              m_cmdbytes = 2;
              break;

            case 17: // "cursor down" (business) mode
              m_mode |= MODE_MPS801_CURSORDOWN;
              break;

            case 18: // reverse mode
              m_mode |= MODE_MPS801_REVERSE;
              break;

            case 26: // repeat graphics (followed by length and data byte)
              write(28);
              m_cmdbytes = 2;
              break;

            case 27: // specify dot address (followed by 16 and two-byte dot column)
              write(27);
              m_cmdbytes = 3;
              break;

            case 145: // "cursor up" (standard) mode
              m_mode &= ~MODE_MPS801_CURSORDOWN;
              break;

            case 146: // turn off reverse mode
              m_mode &= ~MODE_MPS801_REVERSE;
              break;

            default:
              {
                byte charIdx  = (m_mode & MODE_MPS801_CURSORDOWN) ? pgm_read_byte(charset_business+data) : pgm_read_byte(charset_standard+data);
                const byte *charData = font + charIdx*6;
                
                write(18);
                for(byte i=0; i<6; i++) 
                  {
                    if( m_dotcolumn>=480 )
                      {
                        if( (m_mode & MODE_MPS801_GRAPHICS)==0) 
                          { write(30); write(13); write(18); }
                        m_dotcolumn = 0;
                      }
                    
                    data = pgm_read_byte(charData+i);
                    if( m_mode & MODE_MPS801_REVERSE ) data = ~data;
                    write(data | 0x80);
                  }
               
                m_dotcolumn += (m_mode & MODE_MPS801_DWIDTH) ? 12 : 6;
                break;
              }
            }          
        }
    }
}
