
; 64tass Turbo Assembler Macro V1.52.1237? listing file
; 64tass -C -m -a -I /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib -i -L libtest00.txt -o libtest00.prg libtest00.asm
; Fri May 30 20:47:33 2025

;Offset	;Hex		;Source

;******  Processing input file: libtest00.asm

="20250525-151829"	               Version = "20250525-151829"

;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/header-c64.asm

>0801	29 08		bcmd1          .word bcmd2         ;Adresse de la commande basic suivante.
>0803	01 00		               .word 1             ;Numero de la ligne Basic.
>0805	8f		               .byte $8F           ;Le token de la commande REM du Basic
>0806	2a 50 52 4f	               .text "*programmation assembleur sur c64*"
>080a	47 52 41 4d 4d 41 54 49 4f 4e 20 41 53 53 45 4d
>081a	42 4c 45 55 52 20 53 55 52 20 43 36 34 2a
>0828	00		               .byte $00           ;Un zéro pour indiquer la fin de cette
>0829	44 08		bcmd2          .word bcmd3         ;Adresse de la commande basic suivante.
>082b	02 00		               .word 2             ;Numero de la ligne Basic.
>082d	8f		               .byte $8F           ;Le token de la commande REM du Basic
>082e	2a 50 41 52	               .text "*par daniel lafrance*"
>0832	20 44 41 4e 49 45 4c 20 4c 41 46 52 41 4e 43 45
>0842	2a
>0843	00		               .byte $00           ;Un zéro pour indiquer la fin de cette
>0844	4f 08		bcmd3          .word bcmd4         ;Adresse de la commande basic suivante.
>0846	03 00		               .word 3             ;Numero de la ligne Basic.
>0848	9e		               .byte $9e           ;Le token de la commande PRINT du Basic
>0849	30 32 31 32	               .text format("%05d",hpgmstart)
>084d	39
>084e	00		               .byte $00           ;Un zéro pour indiquer la fin de cette
>084f	00 00		bcmd4          .word $0000         ;L'adresse de la commande Basic suivante.
.0851	4c 54 08	hpgmstart     jmp   main           ; Le programme principale doit s'appeler "main"

;******  Return to file: libtest00.asm

.0854			main
.0854	20 00 c0	               jsr scrmaninit
.0857	08		               php
.0858	48		               pha
.0859	a9 8e		               lda  #b_uppercase
.085b	8d 1f c0	               sta  characterset
.085e	20 d2 ff	               jsr  $ffd2
.0861	68		               pla
.0862	28		               plp
.0863	08		               php
.0864	48		               pha
.0865	a9 8e		               lda  #b_uppercase
.0867	20 d2 ff	               jsr  $ffd2
.086a	68		               pla
.086b	28		               plp
.086c	08		               php
.086d	48		               pha
.086e	a9 08		               lda  #$08
.0870	20 d2 ff	               jsr  $ffd2
.0873	68		               pla
.0874	28		               plp
.0875	20 cf 08	               jsr aide
.0878	20 88 83	               jsr anykey
.087b	20 72 80	               jsr  pushreg
.087e	48		               pha
.087f	a9 05		               lda  #cvert
.0881	8d 20 d0	               sta  $d020
.0884	68		               pla
.0885	48		               pha
.0886	a9 06		               lda  #cbleu
.0888	8d 21 d0	               sta  $d021
.088b	68		               pla
.088c	48		               pha
.088d	a9 01		               lda  #cblanc
.088f	8d 86 02	               sta  bascol
.0892	68		               pla
.0893	20 a1 80	               jsr  popreg
.0896	a9 05		               lda #$05
.0898	20 47 09	               jsr libtest00
.089b	08		               php
.089c	48		               pha
.089d	a9 09		               lda  #$09
.089f	20 d2 ff	               jsr  $ffd2
.08a2	68		               pla
.08a3	28		               plp
.08a4	08		               php
.08a5	48		               pha
.08a6	a9 8e		               lda  #b_uppercase
.08a8	8d 1f c0	               sta  characterset
.08ab	20 d2 ff	               jsr  $ffd2
.08ae	68		               pla
.08af	28		               plp
.08b0	20 20 c0	               jsr  cls
.08b3	20 72 80	               jsr  pushreg
.08b6	48		               pha
.08b7	a9 05		               lda  #cvert
.08b9	8d 20 d0	               sta  $d020
.08bc	68		               pla
.08bd	48		               pha
.08be	a9 06		               lda  #cbleu
.08c0	8d 21 d0	               sta  $d021
.08c3	68		               pla
.08c4	48		               pha
.08c5	a9 01		               lda  #cblanc
.08c7	8d 86 02	               sta  bascol
.08ca	68		               pla
.08cb	20 a1 80	               jsr  popreg
.08ce	60		               rts
.08cf			aide
.08cf	08		               php
.08d0	48		               pha
.08d1	a9 0e		               lda  #14
.08d3	8d 1f c0	               sta  characterset
.08d6	20 d2 ff	               jsr  $ffd2
.08d9	68		               pla
.08da	28		               plp
.08db	20 20 c0	               jsr cls
.08de	20 72 80	               jsr  pushreg
.08e1	a2 f3		               ldx  #<line
.08e3	a0 0a		               ldy  #>line
.08e5	20 3d c0	               jsr  puts
.08e8	20 a1 80	               jsr  popreg
.08eb	20 72 80	               jsr  pushreg
.08ee	a2 97		               ldx  #<headera
.08f0	a0 09		               ldy  #>headera
.08f2	20 3d c0	               jsr  puts
.08f5	20 a1 80	               jsr  popreg
.08f8	20 72 80	               jsr  pushreg
.08fb	a2 be		               ldx  #<headerb
.08fd	a0 09		               ldy  #>headerb
.08ff	20 3d c0	               jsr  puts
.0902	20 a1 80	               jsr  popreg
.0905	20 72 80	               jsr  pushreg
.0908	a2 f3		               ldx  #<line
.090a	a0 0a		               ldy  #>line
.090c	20 3d c0	               jsr  puts
.090f	20 a1 80	               jsr  popreg
.0912	20 72 80	               jsr  pushreg
.0915	a2 f3		               ldx  #<line
.0917	a0 0a		               ldy  #>line
.0919	20 3d c0	               jsr  puts
.091c	20 a1 80	               jsr  popreg
.091f	20 72 80	               jsr  pushreg
.0922	a2 19		               ldx  #<shortcuts
.0924	a0 0a		               ldy  #>shortcuts
.0926	20 3d c0	               jsr  puts
.0929	20 a1 80	               jsr  popreg
.092c	20 72 80	               jsr  pushreg
.092f	a2 9f		               ldx  #<aidetext
.0931	a0 0a		               ldy  #>aidetext
.0933	20 3d c0	               jsr  puts
.0936	20 a1 80	               jsr  popreg
.0939	20 72 80	               jsr  pushreg
.093c	a2 f3		               ldx  #<line
.093e	a0 0a		               ldy  #>line
.0940	20 3d c0	               jsr  puts
.0943	20 a1 80	               jsr  popreg
.0946	60		               rts
.0947			libtest00
.0947	08		               php
.0948	48		               pha
.0949	20 20 c0	               jsr  cls
.094c	a9 a6		               lda  #166
.094e	48		nexta          pha
.094f	20 72 80	               jsr  pushreg
.0952	a2 1c		               ldx  #<dataloc
.0954	a0 0b		               ldy  #>dataloc
.0956	20 ca c0	               jsr  putscxy
.0959	20 a1 80	               jsr  popreg
.095c	48		               pha
.095d	a9 03		               lda  #ccyan
.095f	8d 86 02	               sta  bascol
.0962	68		               pla
.0963	48		               pha
.0964	a9 00		               lda  #<$0000+(256)
.0966	8d 28 82	               sta  loopcount
.0969	a9 01		               lda  #>$0000+(256)
.096b	8d 29 82	               sta  loopcount+1
.096e	68		               pla
.096f	20 20 c0	               jsr  cls
.0972	20 8a 09	               jsr  clearregs
.0975	20 b1 c5	               jsr  showregs
.0978	20 f7 c3	roll           jsr  bmtester
.097b	20 59 81	               jsr  inczp1
.097e	20 84 81	               jsr  deczp2
.0981	20 08 82	               jsr  loop
.0984	d0 f2		               bne  roll
.0986	68		out            pla
.0987	28		               plp
.0988	60		               rts
>0989	a6		car            .byte     166
.098a			clearregs
.098a	a9 00		               lda  #$00
.098c	85 fb		               sta  zpage1
.098e	85 fc		               sta  zpage1+1
.0990	85 fd		               sta  zpage2
.0992	85 fe		               sta  zpage2+1
.0994	aa		               tax
.0995	a8		               tay
.0996	60		               rts

;******  Processing file: strings_fr.asm

.0997			headera
>0997	13 1d 1d 1d	               .byte     b_home,b_crsr_right,b_crsr_right,b_crsr_right,b_crsr_right
>099b	1d
>099c	20 c3 4f 4d	               .text              " Commodore 64 test de libraries "
>09a0	4d 4f 44 4f 52 45 20 36 34 20 54 45 53 54 20 44
>09b0	45 20 4c 49 42 52 41 52 49 45 53 20
>09bc	0d 00		               .byte     $0d,0
>09be	20 20 20 20	headerb        .text          "               libtest00 "
>09c2	20 20 20 20 20 20 20 20 20 20 20 4c 49 42 54 45
>09d2	53 54 30 30 20
>09d7	0d		               .byte     $0d
>09d8	20 20 20 20	               .text          "       (c) 2025 Daniel Lafrance"
>09dc	20 20 20 28 43 29 20 32 30 32 35 20 c4 41 4e 49
>09ec	45 4c 20 cc 41 46 52 41 4e 43 45
>09f7	0d		               .byte     $0d
>09f8	20 20 20 20	               .text   format("       Version: %s",Version)
>09fc	20 20 20 d6 45 52 53 49 4f 4e 3a 20 32 30 32 35
>0a0c	30 35 32 35 2d 31 35 31 38 32 39
>0a17	0d 00		               .byte     $0d,0
>0a19	0d		shortcuts      .byte     $0d
>0a1a	91 91		               .byte     ucurkey,ucurkey
>0a1c	1d 1d 1d 1d	               .byte     rcurkey,rcurkey,rcurkey,rcurkey
>0a20	1d 1d 1d 1d	               .byte     rcurkey,rcurkey,rcurkey,rcurkey,rcurkey
>0a24	1d
>0a25	20 d2 20 c1	               .text          " R A C C O U R C I S "
>0a29	20 c3 20 c3 20 cf 20 d5 20 d2 20 c3 20 c9 20 d3
>0a39	20
>0a3a	0d		               .byte     $0d
>0a3b	20 4c 49 42	               .text   format(" libtest00: SYS%05d (jsr $%04X)",main, main)
>0a3f	54 45 53 54 30 30 3a 20 d3 d9 d3 30 32 31 33 32
>0a4f	20 28 4a 53 52 20 24 30 38 35 34 29
>0a5b	0d		               .byte     $0d
>0a5c	20 41 49 44	               .text   format(" aide.....: SYS%05d (jsr $%04X)",aide, aide)
>0a60	45 2e 2e 2e 2e 2e 3a 20 d3 d9 d3 30 32 32 35 35
>0a70	20 28 4a 53 52 20 24 30 38 c3 c6 29
>0a7c	0d		               .byte     $0d
>0a7d	20 43 4c 53	               .text   format(" cls......: SYS%05d (jsr $%04X)",cls, cls)
>0a81	2e 2e 2e 2e 2e 2e 3a 20 d3 d9 d3 34 39 31 38 34
>0a91	20 28 4a 53 52 20 24 c3 30 32 30 29
>0a9d	0d 00		               .byte     $0d,0
>0a9f	20 cc 41 4e	aidetext       .text   format(" Lancement: SYS%05d (jsr $%04X)",libtest00, libtest00)
>0aa3	43 45 4d 45 4e 54 3a 20 d3 d9 d3 30 32 33 37 35
>0ab3	20 28 4a 53 52 20 24 30 39 34 37 29
>0abf	0d 0d		               .byte     $0d, $0d
>0ac1	20 20 20 20	                .text   format("    ex.: SYS%05d",libtest00)
>0ac5	45 58 2e 3a 20 d3 d9 d3 30 32 33 37 35
>0ad2	0d		                .byte     $0d
>0ad3	20 20 20 20	                .text   format("    for i=0to100:SYS%05d:next",libtest00)
>0ad7	46 4f 52 20 49 3d 30 54 4f 31 30 30 3a d3 d9 d3
>0ae7	30 32 33 37 35 3a 4e 45 58 54
>0af1	0d 00		                .byte     $0d,0
>0af3	20 c0 c0 c0	line            .byte     $20,192,192,192,192,192,192,192,192,192
>0af7	c0 c0 c0 c0 c0 c0
>0afd	c0 c0 c0 c0	                .byte     192,192,192,192,192,192,192,192,192,192
>0b01	c0 c0 c0 c0 c0 c0
>0b07	c0 c0 c0 c0	                .byte     192,192,192,192,192,192,192,192,192,192
>0b0b	c0 c0 c0 c0 c0 c0
>0b11	c0 c0 c0 c0	                .byte     192,192,192,192,192,192,192,192,192
>0b15	c0 c0 c0 c0 c0
>0b1a	0d 00		                .byte     $0d,0
>0b1c	01 00 00 00	dataloc         .byte       1,0,0,0

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-cbm-pushpop.asm

>8000	00		rp        .byte     0
>8001	00		ra        .byte     0
>8002	00 00		pc        .word     0
.8004			pushall
.8004			push
.8004	08		          php            ; stack : flg, pcl, pch
.8005	78		          sei
.8006	8d 01 80	          sta  ra        ; save a
.8009	68		          pla            ; stack : pcl, pch
.800a	8d 00 80	          sta  rp        ; save rp
.800d	68		          pla            ; stack : pch
.800e	8d 02 80	          sta  pc        ; save pcl
.8011	68		          pla            ; stack : -
.8012	8d 03 80	          sta  pc+1      ; save pch
.8015	a5 fb		          lda  zpage1    ; get zpage1 low byte
.8017	48		          pha            ; stack : zp1l
.8018	a5 fc		          lda  zpage1+1  ; get zpage1 High byte
.801a	48		          pha            ; stack : zp1h, zp1l
.801b	a5 fd		          lda  zpage2    ; get zpage2 low byte
.801d	48		          pha            ; stack : zp2l, zp1h, zp1l
.801e	a5 fe		          lda  zpage2+1  ; get zpage2 High byte
.8020	48		          pha            ; stack : zp2h, zp2l, zp1h, zp1l
.8021	ad 00 80	          lda  rp        ; get rp
.8024	48		          pha            ; stack : flg, zp2h, zp2l, zp1h, zp1l
.8025	ad 01 80	          lda  ra        ; get a
.8028	48		          pha            ; stack : a, flg, zp2h, zp2l, zp1h, zp1l
.8029	8a		          txa            ; get x
.802a	48		          pha            ; stack : x, a, flg, zp2h, zp2l, zp1h, zp1l
.802b	98		          tya            ; get y
.802c	48		          pha            ; stack : y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.802d	ad 03 80	          lda  pc+1      ; get pch
.8030	48		          pha            ; stack : pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.8031	ad 02 80	          lda  pc        ; get pcl
.8034	48		          pha            ; stack : pcl, pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.8035	ad 00 80	          lda  rp        ; get rp
.8038	48		          pha            ; stack : flg, pcl, pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.8039	ad 01 80	          lda  ra        ; get a
.803c	28		          plp            ; stack : pcl, pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.803d	58		          cli
.803e	60		          rts
.803f			pullall
.803f			pull
.803f			popall
.803f			pop
.803f	78		          sei
.8040	68		          pla            ; get pcl stack : pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.8041	8d 02 80	          sta  pc        ; save pcl
.8044	68		          pla            ; get pch stack : y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.8045	8d 03 80	          sta  pc+1      ; save pch
.8048	68		          pla            ; get y stack : x, a, flg, zp2h, zp2l, zp1h, zp1l
.8049	a8		          tay            ; set y
.804a	68		          pla            ; get x stack : a, flg, zp2h, zp2l, zp1h, zp1l
.804b	aa		          tax            ; set x
.804c	68		          pla            ; get a stack : flg, zp2h, zp2l, zp1h, zp1l
.804d	8d 01 80	          sta  ra        ; save a
.8050	68		          pla            ; get flag stack : zp2h, zp2l, zp1h, zp1l
.8051	8d 00 80	          sta  rp        ; save rp
.8054	68		          pla            ; stack : zp2l, zp1h, zp1l
.8055	85 fe		          sta  zpage2+1  ; get zpage1 low byte
.8057	68		          pla            ; stack : zp1h, zp1l
.8058	85 fd		          sta  zpage2    ; get zpage2 High byte
.805a	68		          pla            ; stack : zp1l
.805b	85 fc		          sta  zpage1+1  ; get zpage2 low byte
.805d	68		          pla            ; stack :
.805e	85 fb		          sta  zpage1    ; get zpage1 High byte
.8060	ad 03 80	          lda  pc+1      ; get pch
.8063	48		          pha            ; stack : pch
.8064	ad 02 80	          lda  pc
.8067	48		          pha            ; stack : pcl, pch
.8068	ad 00 80	          lda  rp        ; get rp
.806b	48		          pha            ; stack : rp, pcl, pch
.806c	ad 01 80	          lda  ra        ; set ra
.806f	58		          cli
.8070	28		          plp            ; stack : pcl, pch
.8071	60		          rts
.8072			pushreg
.8072	08		          php            ; stack : flg, pcl, pch
.8073	78		          sei
.8074	8d 01 80	          sta  ra        ; save a
.8077	68		          pla            ; stack : pcl, pch
.8078	8d 00 80	          sta  rp        ; save rp
.807b	68		          pla            ; stack : pch
.807c	8d 02 80	          sta  pc        ; save pcl
.807f	68		          pla            ; stack : -
.8080	8d 03 80	          sta  pc+1      ; save pch
.8083	ad 00 80	          lda  rp        ; get rp
.8086	48		          pha            ; stack : flg, zp2h, zp2l, zp1h, zp1l
.8087	ad 01 80	          lda  ra        ; get a
.808a	48		          pha            ; stack : a, flg, zp2h, zp2l, zp1h, zp1l
.808b	8a		          txa            ; get x
.808c	48		          pha            ; stack : x, a, flg, zp2h, zp2l, zp1h, zp1l
.808d	98		          tya            ; get y
.808e	48		          pha            ; stack : y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.808f	ad 03 80	          lda  pc+1      ; get pch
.8092	48		          pha            ; stack : pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.8093	ad 02 80	          lda  pc        ; get pcl
.8096	48		          pha            ; stack : pcl, pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.8097	ad 00 80	          lda  rp        ; get rp
.809a	48		          pha            ; stack : flg, pcl, pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.809b	ad 01 80	          lda  ra        ; get a
.809e	28		          plp            ; stack : pcl, pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.809f	58		          cli
.80a0	60		          rts
.80a1			pullreg
.80a1			popreg
.80a1	78		          sei
.80a2	68		          pla            ; get pcl stack : pch, y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.80a3	8d 02 80	          sta  pc        ; save pcl
.80a6	68		          pla            ; get pch stack : y, x, a, flg, zp2h, zp2l, zp1h, zp1l
.80a7	8d 03 80	          sta  pc+1      ; save pch
.80aa	68		          pla            ; get y stack : x, a, flg, zp2h, zp2l, zp1h, zp1l
.80ab	a8		          tay            ; set y
.80ac	68		          pla            ; get x stack : a, flg, zp2h, zp2l, zp1h, zp1l
.80ad	aa		          tax            ; set x
.80ae	68		          pla            ; get a stack : flg, zp2h, zp2l, zp1h, zp1l
.80af	8d 01 80	          sta  ra        ; save a
.80b2	68		          pla            ; get flag stack : zp2h, zp2l, zp1h, zp1l
.80b3	8d 00 80	          sta  rp        ; save rp
.80b6	ad 03 80	          lda  pc+1      ; get pch
.80b9	48		          pha            ; stack : pch
.80ba	ad 02 80	          lda  pc
.80bd	48		          pha            ; stack : pcl, pch
.80be	ad 00 80	          lda  rp        ; get rp
.80c1	48		          pha            ; stack : rp, pcl, pch
.80c2	ad 01 80	          lda  ra        ; set ra
.80c5	58		          cli
.80c6	28		          plp            ; stack : pcl, pch
.80c7	60		          rts

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-cbm-mem.asm

.80c8			blkfill
.80c8	20 04 80	bf0            jsr  push
.80cb	20 93 81	               jsr  savezp1
.80ce	84 fc		               sty  zpage1+1
.80d0	a0 00		               ldy  #$00
.80d2	84 fb		               sty  zpage1
.80d4	91 fb		bf1            sta  (zpage1),y
.80d6	c8		               iny
.80d7	d0 fb		               bne  bf1
.80d9	20 a2 81	               jsr  restzp1
.80dc	20 3f 80	               jsr  pop
.80df	60		               rts
.80e0			memfill
.80e0	20 04 80	               jsr  push
.80e3	20 c8 80	mf1            jsr  blkfill
.80e6	c8		               iny
.80e7	ca		               dex
.80e8	d0 f9		               bne  mf1
.80ea	20 3f 80	               jsr  pop
.80ed	60		               rts
.80ee			memmove
.80ee	20 04 80	               jsr  push
.80f1	ba		               tsx            ; On se crée un pointeur ...
.80f2	8a		               txa
.80f3	18		               clc
.80f4	69 0b		               adc  #11
.80f6	a8		               tay
.80f7	a2 06		               ldx  #$06
.80f9	b9 00 01	nextbyte       lda  $0100,y
.80fc	99 48 81	               sta  words,y
.80ff	c8		               iny
.8100	ca		               dex
.8101	d0 f6		               bne  nextbyte
.8103	ad 48 81	               lda  s
.8106	8d 1f 81	               sta  source+1
.8109	ad 49 81	               lda  s+1
.810c	8d 20 81	               sta  source+2
.810f	ad 4a 81	               lda  d
.8112	8d 1c 81	               sta  destin+1
.8115	ad 4b 81	               lda  d+1
.8118	8d 1d 81	               sta  destin+2
.811b	ad ff ff	destin         lda  $ffff
.811e	8d ff ff	source         sta  $ffff
.8121	ee 1c 81	               inc  destin+1
.8124	d0 03		               bne  src
.8126	ee 1d 81	               inc  destin+2
.8129	ee 1f 81	src            inc  source+1
.812c	d0 03		               bne  cnt
.812e	ee 20 81	               inc  source+2
.8131	ad 4c 81	cnt            lda  compte
.8134	d0 08		               bne  decit
.8136	ad 4d 81	               lda  compte+1
.8139	f0 09		               beq  fini
.813b	ce 4d 81	               dec  compte+1
.813e	ce 4c 81	decit          dec  compte
.8141	4c 1b 81	               jmp  destin
.8144	20 3f 80	fini           jsr  pop
.8147	60		               rts
.8148			words
>8148	00 00		s         .word     $0000
>814a	00 00		d         .word     $0000
>814c	00 00		compte    .word     $0000
.814e			decword
.814e	20 04 80	               jsr  push
.8151	86 fd		               stx  zpage2
.8153	84 fe		               sty  zpage2+1
.8155	20 3f 80	               jsr  pop
.8158	60		               rts
.8159			inczpage1
.8159			inczp1
.8159	08		               php
.815a	48		               pha
.815b	e6 fb		               inc  zpage1
.815d	a5 fb		               lda  zpage1
.815f	d0 02		               bne  nopage
.8161	e6 fc		               inc  zpage1+1
.8163	68		nopage         pla
.8164	28		               plp
.8165	60		               rts
.8166			deczpage1
.8166			deczp1
.8166	08		               php
.8167	48		               pha
.8168	c6 fb		               dec  zpage1
.816a	a5 fb		               lda  zpage1
.816c	c9 ff		               cmp  #$ff
.816e	f0 02		               beq  report
.8170	d0 02		               bne  nopage
.8172	c6 fc		report         dec  zpage1+1
.8174	68		nopage         pla
.8175	28		               plp
.8176	60		               rts
.8177			inczpage2
.8177			inczp2
.8177	08		               php
.8178	48		               pha
.8179	e6 fd		               inc  zpage2
.817b	a5 fd		               lda  zpage2
.817d	d0 02		               bne  nopage
.817f	e6 fe		               inc  zpage2+1
.8181	68		nopage         pla
.8182	28		               plp
.8183	60		               rts
.8184			deczpage2
.8184			deczp2
.8184	08		               php
.8185	c6 fd		               dec  zpage2
.8187	a5 fd		               lda  zpage2
.8189	c9 ff		               cmp  #$ff
.818b	f0 02		               beq  report
.818d	d0 02		               bne  nopage
.818f	c6 fe		report         dec  zpage2+1
.8191	28		nopage         plp
.8192	60		               rts
.8193			savezp1
.8193	08		               php
.8194	48		               pha
.8195	a5 fb		               lda  zpage1
.8197	8d 24 82	               sta  zp1
.819a	a5 fc		               lda  zpage1+1
.819c	8d 25 82	               sta  zp1+1
.819f	68		               pla
.81a0	28		               plp
.81a1	60		               rts
.81a2			restzp1
.81a2	08		               php
.81a3	48		               pha
.81a4	ad 24 82	               lda  zp1
.81a7	85 fb		               sta  zpage1
.81a9	ad 25 82	               lda  zp1+1
.81ac	85 fc		               sta  zpage1+1
.81ae	68		               pla
.81af	28		               plp
.81b0	60		               rts
.81b1			savezp2
.81b1	08		               php
.81b2	48		               pha
.81b3	a5 fd		               lda  zpage2
.81b5	8d 26 82	               sta  zp2
.81b8	a5 fe		               lda  zpage2+1
.81ba	8d 27 82	               sta  zp2+1
.81bd	68		               pla
.81be	28		               plp
.81bf	60		               rts
.81c0			restzp2
.81c0	08		               php
.81c1	48		               pha
.81c2	ad 26 82	               lda  zp2
.81c5	85 fd		               sta  zpage2
.81c7	ad 27 82	               lda  zp2+1
.81ca	85 fe		               sta  zpage2+1
.81cc	68		               pla
.81cd	28		               plp
.81ce	60		               rts
.81cf			xy2addr
.81cf	08		               php
.81d0	48		               pha
.81d1	8a		               txa
.81d2	48		               pha
.81d3	98		               tya
.81d4	48		               pha
.81d5	ad 1f 82	               lda  addr1+1
.81d8	8d 21 82	               sta  addr2+1
.81db	ad 1e 82	               lda  addr1
.81de	8d 20 82	               sta  addr2
.81e1	c0 00		               cpy  #$00
.81e3	f0 0f		               beq  addx
.81e5	18		moreline       clc
.81e6	6d 1d 82	               adc  ymult
.81e9	90 03		               bcc  norepy
.81eb	ee 21 82	               inc  addr2+1
.81ee	8d 20 82	norepy         sta  addr2
.81f1	88		               dey
.81f2	d0 f1		               bne  moreline
.81f4	8a		addx           txa
.81f5	18		               clc
.81f6	6d 20 82	               adc  addr2
.81f9	90 03		               bcc  thatsit
.81fb	ee 21 82	               inc  addr2+1
.81fe	8d 20 82	thatsit        sta  addr2
.8201	68		               pla
.8202	a8		               tay
.8203	68		               pla
.8204	aa		               tax
.8205	68		               pla
.8206	28		               plp
.8207	60		               rts
.8208			loop
.8208	ce 28 82	               dec  loopcount
.820b	d0 03		               bne  norep
.820d	ce 29 82	               dec  loopcount+1
.8210	ad 28 82	norep          lda  loopcount
.8213	c9 00		               cmp  #$00
.8215	d0 05		               bne  out
.8217	4d 29 82	               eor  loopcount+1
.821a	c9 ff		               cmp  #$ff
.821c	60		out            rts
>821d	28		ymult          .byte     40
>821e	00 00		addr1          .word     $0000
>8220	00 00		addr2          .word     $0000
>8222	00 00		bytecnt        .word     $0000
>8224	00 00		zp1            .word     $0000
>8226	00 00		zp2            .word     $0000
>8228	00 00		loopcount      .word     $0000

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-cbm-hex.asm

>822a	01		a2hexcol       .byte     1              ; pour aputscxy
>822b	00		a2hexbkcol     .byte     %00000000
.822c			a2hexpos
>822c	00		a2hexpx        .byte     0              ; pour aputsxy
>822d	00		a2hexpy        .byte     0
>822e	24		a2hexprefix    .byte     "$"            ; pour aputs
>822f	00 00		a2hexstr       .word     $00
>8231	00 00		               .word     $00
>8233	00		               .byte     0              ; 0 end string
>8234	30 30 30 30	abin           .null     "00000000"
>8238	30 30 30 30 00
>823d	20 20 20 00	adec           .null     "   "
.8241			putahexfmtxy
.8241	20 04 80	               jsr  push
.8244	20 90 82	               jsr  atohex
.8247	ae 2c 82	               ldx  a2hexpx
.824a	ac 2d 82	               ldy  a2hexpy
.824d	20 57 c0	               jsr  gotoxy
.8250	a2 2e		               ldx  #<a2hexprefix
.8252	a0 82		               ldy  #>a2hexprefix
.8254	20 3d c0	               jsr  puts
.8257	20 3f 80	               jsr  pop
.825a	60		               rts
.825b			putahexfmt
.825b	20 04 80	               jsr  push
.825e	20 90 82	               jsr  atohex
.8261	a2 2e		               ldx  #<a2hexprefix
.8263	a0 82		               ldy  #>a2hexprefix
.8265	20 3d c0	               jsr  puts
.8268	20 3f 80	               jsr  pop
.826b	60		               rts
.826c			putahex
.826c	20 04 80	               jsr  push
.826f	20 90 82	               jsr  atohex
.8272	a2 2f		               ldx  #<a2hexstr
.8274	a0 82		               ldy  #>a2hexstr
.8276	20 3d c0	               jsr  puts
.8279	20 3f 80	               jsr  pop
.827c	60		               rts
.827d			nibtohex
.827d	08		               php
.827e	29 0f		               and  #$0f
.8280	f8		               sed
.8281	18		               clc
.8282	69 90		               adc  #$90
.8284	69 40		               adc  #$40
.8286	d8		               cld
.8287	28		               plp
.8288	60		               rts
.8289			lsra4bits
.8289	08		               php
.828a	4a		               lsr
.828b	4a		               lsr
.828c	4a		               lsr
.828d	4a		               lsr
.828e	28		               plp
.828f	60		               rts
.8290			atohex
.8290	08		               php
.8291	48		               pha
.8292	48		               pha
.8293	20 89 82	               jsr  lsra4bits
.8296	20 7d 82	               jsr  nibtohex
.8299	8d 2f 82	               sta  a2hexstr
.829c	68		               pla
.829d	20 7d 82	               jsr  nibtohex
.82a0	8d 30 82	               sta  a2hexstr+1
.82a3	a9 00		               lda  #$00                ; set end of string
.82a5	8d 31 82	               sta  a2hexstr+2
.82a8	68		               pla
.82a9	28		               plp
.82aa	60		               rts
.82ab			xy2hex
.82ab	20 04 80	               jsr  push
.82ae	20 90 82	               jsr  atohex
.82b1	8a		               txa
.82b2	48		               pha
.82b3	20 89 82	               jsr  lsra4bits
.82b6	20 7d 82	               jsr  nibtohex
.82b9	8d 2f 82	               sta  a2hexstr
.82bc	68		               pla
.82bd	20 7d 82	               jsr  nibtohex
.82c0	8d 30 82	               sta  a2hexstr+1
.82c3	98		               tya
.82c4	48		               pha
.82c5	20 89 82	               jsr  lsra4bits
.82c8	20 7d 82	               jsr  nibtohex
.82cb	8d 31 82	               sta  a2hexstr+2
.82ce	68		               pla
.82cf	20 7d 82	               jsr  nibtohex
.82d2	8d 32 82	               sta  a2hexstr+3
.82d5	a9 00		               lda  #$00                ; 0 ended string
.82d7	8d 33 82	               sta  a2hexstr+4
.82da	20 3f 80	               jsr  pop
.82dd			atobin
.82dd	20 04 80	               jsr  push
.82e0	a2 08		               ldx  #8
.82e2	a0 00		               ldy  #0
.82e4	18		               clc
.82e5	2a		nextbit        rol
.82e6	48		               pha
.82e7	69 00		               adc  #$00
.82e9	29 01		               and  #$01
.82eb	20 7d 82	               jsr  nibtohex
.82ee	99 34 82	               sta  abin,y
.82f1	68		               pla
.82f2	c8		               iny
.82f3	ca		               dex
.82f4	d0 ef		               bne  nextbit
.82f6	a9 00		               lda  #0
.82f8	99 34 82	               sta  abin,y
.82fb	20 3f 80	               jsr  pull
.82fe	60		               rts
.82ff			putabin
.82ff	20 dd 82	               jsr     atobin
.8302	20 04 80	               jsr     push
.8305	a2 34		               ldx     #<abin
.8307	a0 82		               ldy     #>abin
.8309	20 3d c0	               jsr     puts
.830c	20 3f 80	               jsr     pop
.830f	60		               rts
.8310			printabin
.8310	20 04 80	               jsr     push
.8313	a2 34		               ldx     #<abin
.8315	a0 82		               ldy     #>abin
.8317	20 3d c0	               jsr     puts
.831a	20 3f 80	               jsr     pop
.831d	60		               rts
.831e			putabinfmt
.831e	08		               php
.831f	48		               pha
.8320	a9 25		               lda     #"%"
.8322	20 37 c0	               jsr     putch
.8325	68		               pla
.8326	20 ff 82	               jsr     putabin
.8329	28		               plp
.832a	60		               rts
.832b			putabinxy
.832b	20 57 c0	               jsr     gotoxy
.832e	20 ff 82	               jsr     putabin
.8331	60		               rts
.8332			putabinfmtxy
.8332	20 57 c0	               jsr     gotoxy
.8335	20 1e 83	               jsr     putabinfmt
.8338	60		               rts
.8339			atodec
.8339	20 04 80	               jsr  push
.833c	f8		               sed            ; On se place en mode décimal.
.833d	aa		               tax            ; On déplace a dans x.
.833e	a0 00		               ldy  #$00      ; On pointe Y au début de la str.
.8340	a9 00		               lda  #$00      ; 0 dans A.
.8342	18		nextbit        clc            ; Bit carry a 0.
.8343	69 01		               adc  #$01      ; Ajoute 1 a A.
.8345	90 01		               bcc  decx      ; Pas de carry, pas de report.
.8347	c8		               iny            ; On incrémente Y
.8348	ca		decx           dex            ; X=X-1
.8349	d0 f7		               bne  nextbit   ; Pas encore a 0, on boucle.
.834b	48		               pha            ; A sur le stack.
.834c	98		               tya            ; Y dans A (MSB)
.834d	20 7d 82	               jsr  nibtohex  ; a hex petsci ...
.8350	8d 3d 82	               sta  adec      ; ... dans tampon.
.8353	68		               pla            ; Récupere A
.8354	48		               pha            ;
.8355	20 7d 82	               jsr  nibtohex
.8358	8d 3f 82	               sta  adec+2
.835b	68		               pla
.835c	6a		               ror
.835d	6a		               ror
.835e	6a		               ror
.835f	6a		               ror
.8360	20 7d 82	               jsr  nibtohex
.8363	8d 3e 82	               sta  adec+1
.8366	d8		               cld            ; On revient en mode binaire.
.8367	20 3f 80	               jsr  pull
.836a	60		               rts
.836b			putadec
.836b	20 04 80	               jsr  push
.836e	20 39 83	               jsr  atodec
.8371	a2 3d		               ldx  #<adec
.8373	a0 82		               ldy  #>adec+1
.8375	20 3d c0	               jsr  puts
.8378	20 3f 80	               jsr  pop
.837b	60		               rts

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-cbm-keyb.asm

.837c			waitstop
.837c	20 04 80	               jsr  push
.837f	20 ed f6	wait           jsr  k_stop
.8382	d0 fb		               bne  wait
.8384	20 3f 80	               jsr  pop
.8387	60		               rts
.8388			anykey
.8388	08		               php
.8389	48		               pha
.838a	a5 cb		nokey          lda 203
.838c	c9 40		               cmp #64
.838e	f0 fa		               beq nokey
.8390	20 96 83	               jsr releasekey
.8393	68		               pla
.8394	28		               plp
.8395	60		               rts
.8396			releasekey
.8396	08		               php
.8397	48		               pha
.8398	a5 cb		keypressed     lda 203
.839a	c9 40		               cmp #64
.839c	d0 fa		               bne keypressed
.839e	68		               pla
.839f	28		               plp
.83a0	60		               rts
.83a1			getkey
.83a1	20 e4 ff	gkagain        jsr  getin
.83a4	c9 00		               cmp  #0
.83a6	f0 f9		               beq  gkagain
.83a8	60		               rts
.83a9			kbflushbuff
.83a9	08		               php
.83aa	48		               pha
.83ab	20 e4 ff	again          jsr  getin
.83ae	c9 00		               cmp  #0
.83b0	d0 f9		               bne  again
.83b2	68		               pla
.83b3	28		               plp
.83b4	60		               rts
.83b5			waitkey
.83b5	20 04 80	               jsr  push
.83b8	8d 06 84	               sta  thekey
.83bb	20 e4 ff	nope           jsr  getin
.83be	20 d2 ff	               jsr  chrout
.83c1	cd 06 84	               cmp  thekey
.83c4	d0 f5		               bne  nope
.83c6	20 d2 ff	               jsr  chrout
.83c9	20 3f 80	               jsr  pop
.83cc	60		               rts
.83cd			waitspace
.83cd	20 04 80	               jsr  push
.83d0	a9 7f		wait           lda  #$7f  ;%01111111
.83d2	8d 00 dc	               sta  $dc00
.83d5	ad 01 dc	               lda  $dc01
.83d8	29 10		               and  #$10  ;mask %00010000
.83da	d0 f4		               bne  wait
.83dc	20 3f 80	               jsr  pop
.83df			waitsstop
.83df	20 04 80	               jsr  push
.83e2	20 ed f6	wait           jsr  k_stop  ;%01111111
.83e5	d0 fb		               bne  wait
.83e7	20 3f 80	               jsr  pop
.83ea			waitreturn
.83ea	20 04 80	               jsr  push
.83ed	ad 07 84	               lda  thecount
.83f0	8d 00 04	               sta  scrnram
.83f3	a9 02		               lda  #$02
.83f5	8d 00 d8	               sta  colorram
.83f8	20 e4 ff	nope           jsr  getin
.83fb	c9 0d		nohex          cmp  #$0d
.83fd	d0 f9		               bne  nope
.83ff	ee 07 84	               inc  thecount
.8402	20 3f 80	               jsr  pop
.8405	60		               rts
>8406	00		thekey         .byte   0
>8407	01		thecount       .byte   $01
>8408	00 00 00 00	asciitorom     .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$0d,$00,$00  ;$00
>840c	00 00 00 00 00 00 00 00 00 0d 00 00
>8418	00 00 00 00	               .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ;$10
>841c	00 00 00 00 00 00 00 00 00 00 00 00
>8428	20 21 22 23	               .byte     $20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$2a,$2b,$2c,$2d,$2e,$2f  ;$20
>842c	24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
>8438	30 31 32 33	               .byte     $30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3a,$3b,$3c,$3d,$3e,$3f  ;$30
>843c	34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
>8448	00 01 02 03	               .byte     $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f  ;$40
>844c	04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
>8458	10 11 12 13	               .byte     $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1a,$1b,$1c,$1d,$1e,$1f  ;$50
>845c	14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
>8468	00 00 00 00	               .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ;$60
>846c	00 00 00 00 00 00 00 00 00 00 00 00
>8478	00 00 00 00	               .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ;$70
>847c	00 00 00 00 00 00 00 00 00 00 00 00
>8488	00 00 00 00	               .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ;$80
>848c	00 00 00 00 00 00 00 00 00 00 00 00
>8498	00 00 00 00	               .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ;$90
>849c	00 00 00 00 00 00 00 00 00 00 00 00
>84a8	60 61 62 63	               .byte     $60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$6a,$6b,$6c,$6d,$6e,$6f  ;$a0
>84ac	64 65 66 67 68 69 6a 6b 6c 6d 6e 6f
>84b8	70 71 72 73	               .byte     $70,$71,$72,$73,$74,$75,$76,$77,$78,$79,$7a,$7b,$7c,$7d,$7e,$7f  ;$b0
>84bc	74 75 76 77 78 79 7a 7b 7c 7d 7e 7f
>84c8	40 41 42 43	               .byte     $40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$4a,$4b,$4c,$4d,$4e,$4f  ;$c0
>84cc	44 45 46 47 48 49 4a 4b 4c 4d 4e 4f
>84d8	50 51 52 53	               .byte     $50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$5a,$5b,$5c,$5d,$5e,$5f  ;$d0
>84dc	54 55 56 57 58 59 5a 5b 5c 5d 5e 5f
>84e8	00 00 00 00	               .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ;$e0
>84ec	00 00 00 00 00 00 00 00 00 00 00 00
>84f8	00 00 00 00	               .byte     $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ;$f0
>84fc	00 00 00 00 00 00 00 00 00 00 00 00

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-cbm-disk.asm

.8508			diskerror
.8508	20 04 80	               jsr  push
.850b	ad eb 86	               lda  dsk_dev   ; Select device 8
.850e	85 ba		               sta  $ba       ;
.8510	20 b4 ff	               jsr  talk      ; $ffb4 |a  , iec-cmd dev parle
.8513	a9 6f		               lda  #$6f
.8515	85 b9		               sta  $b9       ;
.8517	20 96 ff	               jsr  tksa      ; $ff96 |a  , talk adresse sec.
.851a	20 a5 ff	nextchar       jsr  acptr     ; $ffa5 |a  , rx serie.
.851d	20 d2 ff	               jsr  chrout    ; $ffd2 |a  , sort un car.
.8520	c9 0d		               cmp  #$0d      ; Is it CR ?
.8522	d0 f6		               bne  nextchar  ; No, get next char
.8524	20 ab ff	               jsr  untlk     ;$ffab      , iec-cmc stop talk
.8527	20 3f 80	               jsr  pop
.852a	60		               rts
.852b			diskdir
.852b	20 04 80	               jsr  push
.852e	a9 24		               lda  #$24      ; L012C - Filename is "$"
.8530	85 fb		               sta  $fb       ; L012E - Zpage1 msb
.8532	a9 fb		               lda  #$fb      ; L0130 - Set current filename
.8534	85 bb		               sta  $bb       ; L0132 - Current filename msb.
.8536	a9 00		               lda  #$00      ; L0134 - to Zpage 1
.8538	85 bc		               sta  $bc       ; L0136 - Current filename lsb.
.853a	a9 01		               lda  #$01      ; L0138 - set ...
.853c	85 b7		               sta  $b7       ; L013A - ... length of current filename
.853e	ad eb 86	               lda  dsk_dev   ; L013C - set 8 as ...
.8541	85 ba		               sta  $ba       ; L013E - ... current serial sevice.
.8543	a9 60		               lda  #$60      ; L0140 - set $60 to ...
.8545	85 b9		               sta  $b9       ; L0142 - ... secondary address
.8547	20 d5 f3	               jsr  sfopen    ; L0144 - $f3d5 Serial file open.
.854a	a5 ba		               lda  $ba       ; L0147 - Command device $ba ($08) ...%10111010
.854c	20 b4 ff	               jsr  talk      ; L0149 - $ffb4 ... to talk.
.854f	a5 b9		               lda  $b9       ; L014C - Command sec. device ($60) ...
.8551	20 96 ff	               jsr  tksa      ; L014E - $ff96 ... to talk.
.8554	a9 00		               lda  #$00      ; L0151 - put $00 in ...
.8556	85 90		               sta  $90       ; L0153 - ... kernal status word.
.8558	a0 03		               ldy  #$03      ; L0155 - To read 3 bytes, put $03 in
.855a	84 fb		loop1          sty  $fb       ; L0157 - Zpage 1 Msb
.855c	20 a5 ff	               jsr  acptr     ; L0159 - $ffa5 Recoit un byte du port serie.
.855f	85 fc		               sta  $fc       ; L015C - Store byte in zpage 1 lsb
.8561	a4 90		               ldy  $90       ; L015E - Load kernal status word.
.8563	d0 2f		               bne  exit      ; L0160 - If any error, EXIT.
.8565	20 a5 ff	               jsr  $ffa5     ; L0162 - jsr acptr
.8568	a4 90		               ldy  $90       ; L0165 - Load byte counter,
.856a	d0 28		               bne  exit      ; L0167
.856c	a4 fb		               ldy  $fb       ; L0169
.856e	88		               dey            ; L016b
.856f	d0 e9		               bne  loop1     ; L016C - If not last, loop
.8571	a6 fc		               ldx  $fc       ; L016E - Load the recieved byte in X.
.8573	20 cd bd	               jsr  b_putint  ; L0170 - $bdcd print file size
.8576	a9 20		               lda  #$20      ; L0173 - Load space character and ...
.8578	20 d2 ff	               jsr  chrout    ; L0175 - $ffd2 ... print it.
.857b	20 a5 ff	loop3          jsr  acptr     ; L0178 - $ffa5 Recoit un byte du port serie.
.857e	a6 90		               ldx  $90       ; L017B - Load kernal status word.
.8580	d0 12		               bne  exit      ; L017D - If any error, EXIT.
.8582	aa		               tax            ; L017F - tfr a in x
.8583	f0 06		               beq  loop2     ; L0180 - Byte is 0 loop1
.8585	20 d2 ff	               jsr  chrout    ; L0182 - $ffd2 ... print it.
.8588	4c 7b 85	               jmp  loop3     ; L0185 - get another byte
.858b	a9 0d		loop2          lda  #$0d      ; L0188  - Load CR in a
.858d	20 d2 ff	               jsr  chrout    ; L018A - $ffd2 ... print it.
.8590	a0 02		               ldy  #$02      ; L018D - set Y to 2
.8592	d0 c6		               bne  loop1     ; L018f - Loop to next dir entry.
.8594	20 42 f6	exit           jsr  sfclose   ; L0191 - $f642 ... close file.
.8597	20 3f 80	               jsr  pop
.859a	60		               rts            ; L0194
.859b			directory
.859b	20 2b 85	               jsr  diskdir
.859e	20 08 85	               jsr  diskerror
.85a1	60		               rts
.85a2			memtofile
.85a2	20 c5 86	               jsr  dsk_putmesg
.85a5	20 04 80	               jsr  push
.85a8	ad ef 86	               lda  dsk_fnlen
.85ab	ae ed 86	               ldx  dsk_fnptr      ; load fname addr. lbyte
.85ae	ac ee 86	               ldy  dsk_fnptr+1
.85b1	20 bd ff	               jsr  setnam         ; call setnam
.85b4	ad ec 86	               lda  dsk_lfsno
.85b7	ae eb 86	               ldx  dsk_dev        ; specified device
.85ba	a0 00		skip           ldy  #$00
.85bc	20 ba ff	               jsr  setlfs         ; call setlfs
.85bf	ad e7 86	               lda  dsk_data_s     ; put data start lbyte in stal
.85c2	85 c1		               sta  stal
.85c4	ad e8 86	               lda  dsk_data_s+1   ; put data start hbyte in stal
.85c7	85 c2		               sta  stal+1
.85c9	ae e9 86	               ldx  dsk_data_e     ; put data end lbyte in x
.85cc	ac ea 86	               ldy  dsk_data_e+1   ; put data end hbyte in y
.85cf	a9 c1		               lda  #stal          ; start address located in $c1/$c2
.85d1	20 d8 ff	               jsr  save           ; call save
.85d4	90 00		               bcc  noerror        ; if carry set, a load error has happened
.85d6	20 3f 80	noerror        jsr  pop
.85d9	60		               rts
.85da			filetomem
.85da	20 04 80	               jsr push
.85dd	ad ef 86	               lda dsk_fnlen  ; Loads filename lenght.
.85e0	ae ed 86	               ldx dsk_fnptr  ; Points x and y to the filename
.85e3	ac ee 86	               ldy dsk_fnptr+1;pointer
.85e6	20 bd ff	               jsr setnam     ; call setnam
.85e9	ad ec 86	               lda dsk_lfsno  ; Loads Acc with the logical file number
.85ec	ae eb 86	               ldx dsk_dev    ; default to device 8
.85ef	a0 01		               ldy #$01       ; not $01 means: load to address stored in file
.85f1	20 ba ff	               jsr setlfs     ; call setlfs
.85f4	a9 00		               lda #$00       ; $00 means: load to memory (not verify)
.85f6	20 d5 ff	               jsr load       ; call load
.85f9	90 03		               bcc noerror      ; if carry set, a load error has happened
.85fb	20 02 86	               jsr  error
.85fe	20 3f 80	noerror        jsr pop
.8601	60		               rts
.8602			error
.8602	20 04 80	               jsr  push
.8605	c9 01		isit01         cmp  #$01
.8607	d0 07		               bne  isit02
.8609	a2 56		               ldx  #<dsk_emsg01
.860b	a0 86		               ldy  #>dsk_emsg01
.860d	4c 47 86	               jmp  printerror
.8610	c9 02		isit02         cmp  #$02
.8612	d0 07		               bne  isit05
.8614	a2 6a		               ldx  #<dsk_emsg02
.8616	a0 86		               ldy  #>dsk_emsg02
.8618	4c 47 86	               jmp  printerror
.861b	c9 05		isit05         cmp  #$05
.861d	d0 07		               bne  isit04
.861f	a2 7d		               ldx  #<dsk_emsg05
.8621	a0 86		               ldy  #>dsk_emsg05
.8623	4c 47 86	               jmp  printerror
.8626	c9 04		isit04         cmp  #$04
.8628	d0 07		               bne  isit1d
.862a	a2 8d		               ldx  #<dsk_emsg04
.862c	a0 86		               ldy  #>dsk_emsg04
.862e	4c 47 86	               jmp  printerror
.8631	c9 1d		isit1d         cmp  #$1d
.8633	d0 07		               bne  isit00
.8635	a2 a2		               ldx  #<dsk_emsg1d
.8637	a0 86		               ldy  #>dsk_emsg1d
.8639	4c 47 86	               jmp  printerror
.863c	c9 00		isit00         cmp  #$00
.863e	d0 0a		               bne  noerror
.8640	a2 b8		               ldx  #<dsk_emsg00
.8642	a0 86		               ldy  #>dsk_emsg00
.8644	4c 47 86	               jmp  printerror
.8647	20 3d c0	printerror     jsr  puts
.864a	20 3f 80	noerror        jsr  pop
.864d	60		               rts
>864e	8d		dsk_msg1       .byte     141
>864f	53 55 43 43	               .null     "succes"
>8653	45 53 00
>8656	8d		dsk_emsg01     .byte     141
>8657	46 49 43 48	               .null     "fichier non ouvert"
>865b	49 45 52 20 4e 4f 4e 20 4f 55 56 45 52 54 00
>866a	11		dsk_emsg02     .byte     17
>866b	45 52 52 45	               .null     "erreur d'ecriture"
>866f	55 52 20 44 27 45 43 52 49 54 55 52 45 00
>867d	11		dsk_emsg05     .byte     17
>867e	4c 45 43 54	               .null     "lecteur absent"
>8682	45 55 52 20 41 42 53 45 4e 54 00
>868d	11		dsk_emsg04     .byte     17
>868e	46 49 43 48	               .null     "fichier introuvable"
>8692	49 45 52 20 49 4e 54 52 4f 55 56 41 42 4c 45 00
>86a2	11		dsk_emsg1d     .byte     17
>86a3	45 52 52 45	               .null     "erreur de chargement"
>86a7	55 52 20 44 45 20 43 48 41 52 47 45 4d 45 4e 54
>86b7	00
>86b8	11		dsk_emsg00     .byte     17
>86b9	42 52 45 41	               .null     "break error"
>86bd	4b 20 45 52 52 4f 52 00
.86c5			dsk_putmesg
.86c5	20 04 80	               jsr push
.86c8	a2 f0		               ldx #<dsk_msg0
.86ca	a0 86		               ldy #>dsk_msg0
.86cc	20 3d c0	               jsr puts
.86cf	a9 20		               lda #$20
.86d1	20 37 c0	               jsr putch
.86d4	ae ed 86	               ldx dsk_fnptr
.86d7	ac ee 86	               ldy dsk_fnptr+1
.86da	20 3d c0	               jsr puts
.86dd	ad ec 86	               lda dsk_lfsno
.86e0	20 c3 ff	               jsr close
.86e3	20 3f 80	               jsr pop
.86e6	60		               rts
>86e7	00 00		dsk_data_s     .word     $0000     ; Data start example addresses
>86e9	00 20		dsk_data_e     .word     $2000     ; Data end
>86eb	08		dsk_dev        .byte     $08       ; Device number
>86ec	00		dsk_lfsno      .byte     $00       ; Logical file number
>86ed	00 00		dsk_fnptr      .word     $00       ; Pointer to filename
>86ef	00		dsk_fnlen      .byte     0         ; Number of character in filename.
>86f0	8d		dsk_msg0       .byte     141       ; Miscilinaous file message.
>86f1	53 41 56 49	               .null     "saving "
>86f5	4e 47 20 00

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-cbm-chargen.asm

>86f9	00 00		charram        .word     $0000
.86fb			chargen2ram
.86fb	20 5a 87	               jsr  setcharram
.86fe	20 67 87	               jsr  cpchar2ram
.8701	60		               rts
.8702			loadchar
.8702	4c 04 80	               jmp  push
.8705	48		               pha
.8706	8a		               txa
.8707	85 fc		               sta  zpage1+1
.8709	98		               tya
.870a	85 fb		               sta  zpage1
.870c	ad f9 86	               lda  charram
.870f	85 fd		               sta  zpage2
.8711	ad fa 86	               lda  charram+1
.8714	85 fe		               sta  zpage2+1
.8716	a9 00		               lda  #$0
.8718	8d 59 87	               sta  charadd+1
.871b	a2 03		               ldx  #3
.871d	68		               pla
.871e	8d 58 87	               sta  charadd
.8721	ad 58 87	nextrol        lda  charadd
.8724	18		               clc
.8725	0a		               asl
.8726	8d 58 87	               sta  charadd
.8729	ad 59 87	               lda  charadd+1
.872c	2a		               rol
.872d	8d 59 87	               sta  charadd+1
.8730	ca		               dex
.8731	d0 ee		               bne  nextrol
.8733	ad f9 86	               lda  charram
.8736	8d 1e 82	               sta  addr1
.8739	ad f9 86	               lda  charram
.873c	8d 1f 82	               sta  addr1+1
.873f	ac 58 87	               ldy  charadd
.8742	ac 59 87	               ldy  charadd+1
.8745	20 cf 81	               jsr  xy2addr
.8748	ad 20 82	               lda  addr2
.874b	8d 58 87	               sta  charadd
.874e	ad 21 82	               lda  addr2+1
.8751	8d 59 87	               sta  charadd+1
.8754	4c 3f 80	               jmp  pop
.8757	60		               rts
>8758	00 00		charadd   .word $0000
.875a			setcharram
.875a	20 04 80	               jsr  push
.875d	8c f9 86	               sty  charram
.8760	8e fa 86	               stx  charram+1
.8763	20 3f 80	               jsr  pop
.8766	60		               rts
.8767			cpchar2ram
.8767	20 04 80	               jsr  push
.876a	ad 0e dc	               lda  cia1+14   ; peek (56334)
.876d	29 fe		               and  #254      ; and 254
.876f	8d 0e dc	               sta  cia1+14   ; poke 56334
.8772	a5 01		               lda  u6510map  ; peek (1)
.8774	29 fb		               and  #251      ; and %11111011
.8776	85 01		               sta  u6510map  ; poke 1
.8778	a9 00		               lda  #<chargen ; LSB de chargen
.877a	85 fb		               sta  zpage1    ;
.877c	a9 d0		               lda  #>chargen ; MSB de chargen
.877e	85 fc		               sta  zpage1+1  ;
.8780	ad f9 86	               lda  charram   ; $YYXX Contiennent
.8783	85 fd		               sta  zpage2    ; l'adresse
.8785	ad fa 86	               lda  charram+1 ; de destination
.8788	85 fe		               sta  zpage2+1  ; MSB->Y, LDB->X
.878a	a2 08		               ldx  #$08      ; 1 caractère = 8 bytes
.878c	a0 00		nextpage       ldy  #$00      ; 256 caractères
.878e	b1 fb		nextbyte       lda  (zpage1),y
.8790	91 fd		               sta  (zpage2),y
.8792	c8		               iny
.8793	d0 f9		               bne  nextbyte
.8795	e6 fc		               inc  zpage1+1
.8797	e6 fe		               inc  zpage2+1
.8799	ca		               dex
.879a	d0 f0		               bne  nextpage
.879c	a5 01		               lda  u6510map  ; peek (1)
.879e	09 04		               ora  #4        ; and %00000100
.87a0	85 01		               sta  u6510map  ; poke 1
.87a2	ad 0e dc	               lda  cia1+14   ; peek 56334
.87a5	09 01		               ora  #1        ; or 1
.87a7	8d 0e dc	               sta  cia1+14   ; poke 56334
.87aa	20 3f 80	               jsr  pop
.87ad	60		               rts

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-nmi.asm

.87ae			initnmi
.87ae			initnmireu
=$0140			jumpback       =    $0140          ; L'adresse du vecteur TMP en REU.
=$0318			nmivect        =    $0318          ; L'adresse du vecteur BRK.
.87ae	08		               php                 ; Sauvegarde les status.
.87af	48		               pha                 ; Sauvegarde Acc.
.87b0	78		               sei                 ; Bloque les interruptions.
.87b1	a9 40		               lda  #<jumpback     ; Enregistre le vecteur de l'instruction ...
.87b3	8d 18 03	               sta  nmivect        ; ... BRK et des touches ...
.87b6	a9 01		               lda  #>jumpback     ; ... [RUN/STOP] - [RESTORE] dans un ...
.87b8	8d 19 03	               sta  nmivect+1      ; ... vecteur personnel.
.87bb	68		               pla                 ; On récupère l'Acc et ...
.87bc	28		               plp                 ; ... le registre de status.
.87bd	60		               rts
.87be			initnmistd
=$8000			jumpbackstd    =    $8000          ; L'adresse du vecteur TMP standard.
=$0318			nmivect        =    $0318          ; L'adresse du vecteur BRK.
.87be	08		               php                 ; Sauvegarde les status.
.87bf	48		               pha                 ; Sauvegarde Acc.
.87c0	78		               sei                 ; Bloque les interruptions.
.87c1	a9 00		               lda  #<jumpbackstd  ; Enregistre le vecteur de l'instruction ...
.87c3	8d 18 03	               sta  nmivect        ; ... BRK et des touches ...
.87c6	a9 80		               lda  #>jumpbackstd  ; ... [RUN/STOP] - [RESTORE] dans un ...
.87c8	8d 19 03	               sta  nmivect+1      ; ... vecteur personnel.
.87cb	68		               pla                 ; On récupère l'Acc et ...
.87cc	28		               plp                 ; ... le registre de status.
.87cd	60		               rts

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-basic2.asm

.c000			scrmaninit
.c000	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres
.c003	20 a5 c4	               jsr  screendis      ; Disable screen
.c006	a9 06		               lda  #vbleu         ; Place bleue pour la couleur
.c008	8d 21 d0	               sta  vicbackcol     ;   d'arrière plan,
.c00b	a9 05		               lda  #vvert         ; vert pour la couleur
.c00d	8d 20 d0	               sta  vicbordcol     ;   de la bordure d'écran,
.c010	a9 01		               lda  #vblanc        ;   et blanc pour la couleur du
.c012	8d 86 02	               sta  bascol         ; texte.
.c015	20 20 c0	               jsr  cls            ; Efface l'écran.
.c018	20 b2 c4	               jsr  screenena      ; enable screen
.c01b	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c01e	60		               rts
>c01f	8e		characterset   .byte b_uppercase
.c020			cls
.c020	08		               php                 ; Sauvegarde les registres
.c021	48		               pha                 ;   modifiés.
.c022	a9 93		               lda  #$93           ; Affiche le code basic de
.c024	20 37 c0	               jsr  putch          ;   d'effacement d'écran.
.c027	68		               pla                 ; Récupère les registres
.c028	28		               plp                 ;   modifiés.
.c029	60		               rts
.c02a			putnch
.c02a	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c02d	20 d2 ff	again          jsr  $ffd2          ; On affiche A.
.c030	ca		               dex                 ; Un de moins à faire.
.c031	d0 fa		               bne  again          ; Si pas à 0 on en affiche encore.
.c033	20 a1 80	out            jsr  popreg         ; Récupère tous les registres.
.c036	60		               rts
.c037			putch
.c037	08		               php                 ; Sauvegarde le registre de status.
.c038	20 d2 ff	               jsr  $ffd2          ; Affiche le caractère de Acc.
.c03b	28		               plp                 ; Récupère le registre de status.
.c03c	60		               rts
.c03d			puts
.c03d	20 04 80	               jsr  pushall        ; Sauvegarde registres, ZP1 et ZP2.
.c040	86 fb		               stx  zpage1         ; Place l'adresse de la chaine
.c042	84 fc		               sty  zpage1+1       ;   dans ZP1.
.c044	a0 00		               ldy  #0             ; Initialise l'index du mode (ZP),Y
.c046	b1 fb		next           lda  (zpage1),y     ; Lit un charactère.
.c048	f0 09		               beq  exit           ; Si $00 on sort.
.c04a	20 37 c0	               jsr  putch          ; Affiche le caractères.
.c04d	20 59 81	               jsr  inczp1         ; Inc. le pointeur ZP1 en 16 bits.
.c050	4c 46 c0	               jmp  next           ; Saute chercher le prochain carac.
.c053	20 3f 80	exit           jsr  popall         ; Récupère registre, ZP1 et ZP2.
.c056	60		               rts
.c057			gotoxy
.c057	08		               php                 ; Sauvegarde le registre de
.c058	48		               pha                 ;   status et le registre a.
.c059	18		               clc                 ; Carry = 1 pour que kplot
.c05a	8a		               txa                 ;   positionne le curseur.
.c05b	48		               pha                 ; On inverse X et Y pcq kplot
.c05c	98		               tya                 ;
.c05d	aa		               tax                 ;   prend X comme la ligne
.c05e	68		               pla                 ;
.c05f	a8		               tay                 ;   et Y comme la colonne.
.c060	20 f0 ff	               jsr  kplot          ; Positionne le curseur
.c063	68		               pla                 ; Récupère le registre a et
.c064	28		               plp                 ;   le registre de status.
.c065	60		               rts
.c066			cursor
=$0286			bascol    =    $0286               ; debugme
.c066	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c069	90 12		               bcc  restore        ; Si C=0 c'est une récupération.
.c06b	20 f0 ff	               jsr  kplot          ; On récupère la position du
.c06e	8c 90 c0	               sty  cx             ;   curseur et on la sauvegarde
.c071	8e 91 c0	               stx  cy             ;   dans les vars locales.
.c074	ad 86 02	               lda  bascol         ; On sauvegarde la couleur
.c077	8d 92 c0	               sta  bcol           ; BASIC du texte.
.c07a	4c 8c c0	               jmp  out            ; c'est fini on sort.
.c07d	ae 91 c0	restore        ldx  cy             ; Comme C=1, On charge x avec
.c080	ac 90 c0	               ldy  cx             ;   la ligne, y ace  la col.
.c083	20 f0 ff	               jsr  kplot          ; On positionne le curseur.
.c086	ad 92 c0	               lda  bcol           ; On replace la couleur par basic
.c089	8d 86 02	               sta  bascol         ;   sauvegardé.
.c08c	20 a1 80	out            jsr  popreg         ; Récupère tous les registres.
.c08f	60		               rts
>c090	00		cx   .byte     $00
>c091	00		cy   .byte     $00
>c092	00		bcol .byte     $00
.c093			cursave
.c093	08		               php
.c094	38		               sec
.c095	20 66 c0	               jsr  cursor         ; Voir cette fonction plus haut.
.c098	28		               plp
.c099	60		               rts
.c09a			curput
.c09a	08		               php
.c09b	18		               clc
.c09c	20 66 c0	               jsr  cursor         ; Voir cette fonction plus haut.
.c09f	28		               plp
.c0a0	60		               rts
.c0a1			putsxy
.c0a1	20 04 80	               jsr  pushall        ; Sauvegarde registres, ZP1 et ZP2.
.c0a4	86 fb		               stx  zpage1         ; On place la position de la
.c0a6	84 fc		               sty  zpage1+1       ;   chaine dans le pointeur ZP1.
.c0a8	a0 00		               ldy  #$00           ; On charge l'index à 0.
.c0aa	b1 fb		               lda  (zpage1),y     ; Charge la coordonné X
.c0ac	aa		               tax                 ;   dans X.
.c0ad	20 59 81	               jsr  inczp1         ; Inc. le pointeur ZP1 en 16 bits.
.c0b0	b1 fb		               lda  (zpage1),y     ; Charge la coordonnée Y
.c0b2	a8		               tay                 ; dans Y.
.c0b3	20 57 c0	               jsr  gotoxy         ; on positionne le curseur.
.c0b6	20 59 81	               jsr  inczp1         ; Inc. le pointeur ZP1 en 16 bits.
.c0b9	a6 fb		               ldx  zpage1         ; On charge la nouvelle adresse
.c0bb	a4 fc		               ldy  zpage1+1       ;   de la chaine et on
.c0bd	20 3d c0	               jsr  puts           ;   l'affiche.
.c0c0	20 3f 80	               jsr  popall         ; Récupère registre, ZP1 et ZP2.
.c0c3	60		               rts
>c0c4	00 00		straddr   .word     $00
>c0c6	00		px        .byte     $00
>c0c7	00		py        .byte     $00
>c0c8	00 00		zp1       .word     $00
.c0ca			putscxy
.c0ca	20 04 80	               jsr  pushall        ; Sauvegarde registres, ZP1 et ZP2.
.c0cd	86 fb		               stx  zpage1         ; On place la position de la
.c0cf	84 fc		               sty  zpage1+1       ;   chaine dans le pointeur ZP1.
.c0d1	a0 00		               ldy  #$00           ; On charge l'index à 0.
.c0d3	ad 86 02	               lda  bascol         ; On sauvegarde la couleur
.c0d6	48		               pha                 ;   actuelle de basic.
.c0d7	b1 fb		               lda  (zpage1),y     ; On charge le paramètre de
.c0d9	8d 86 02	               sta  bascol         ;   couleur et le force a Basic.
.c0dc	20 59 81	               jsr  inczp1         ; Inc. le pointeur ZP1 en 16 bits.
.c0df	a6 fb		               ldx  zpage1         ; On charge la nouvelle adresse
.c0e1	a4 fc		               ldy  zpage1+1       ;   de la chaine et on
.c0e3	20 a1 c0	               jsr  putsxy         ;   l'affiche.
.c0e6	68		               pla                 ; On replace la couleur basic
.c0e7	8d 86 02	               sta  bascol         ;   que nous avions sauvegardée.
.c0ea	20 3f 80	               jsr  popall         ; Récupère registre, ZP1 et ZP2.
.c0ed	60		               rts
.c0ee			putrahex
.c0ee	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c0f1	20 90 82	               jsr  atohex         ; Conversion de a chaîne hexa.
.c0f4	a2 2f		               ldx  #<a2hexstr     ; Charge l'adresse de la chaîne
.c0f6	a0 82		               ldy  #>a2hexstr     ;   hexa dans $YYXX.
.c0f8	20 3d c0	               jsr  puts           ; Affiche la chaîne.
.c0fb	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c0fe	60		               rts
.c0ff			kputrahexxy
.c0ff			bputrahexxy
.c0ff			putrahexxy
.c0ff	08		               php                 ; Sauvegarde le registre de
.c100	48		               pha                 ;   status et le registre a.
.c101	20 90 82	               jsr  atohex         ; Convertion de a en hexadécimal.
.c104	a2 2c		               ldx  #<a2hexpos     ; Charge l'adresse de la chaîne
.c106	a0 82		               ldy  #>a2hexpos     ;   hexa dans $YYXX.
.c108	20 a1 c0	               jsr  putsxy         ; Positionne et affiche la chaîne.
.c10b	68		               pla                 ; Récupère le registre a et
.c10c	28		               plp                 ;   le registre de status.
.c10d	60		               rts
.c10e			putrahexcxy
.c10e	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c111	20 90 82	               jsr  atohex         ; Convertion de a en hexadécimal.
.c114	a2 2c		               ldx  #<a2hexpos     ; Charge l'adresse de la chaîne
.c116	a0 82		               ldy  #>a2hexpos     ;   hexa dans $YYXX.
.c118	20 a1 c0	               jsr  putsxy         ; Colore, positionne et affiche la
.c11b	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c11e	60		               rts
.c11f			setinverse
.c11f	48		               pha
.c120	a9 12		               lda  #$12
.c122	20 d2 ff	               jsr  $ffd2
.c125	68		               pla
.c126	60		               rts
.c127			clrinverse
.c127	48		               pha
.c128	a9 92		               lda  #$92
.c12a	20 d2 ff	               jsr  $ffd2
.c12d	68		               pla
.c12e	60		               rts

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-basic2-math.asm

.c12f			b_math_template
.c12f	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c132	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c135	60		               rts
>c136	00		b_bufflenght   .byte     $00
>c137	00 00 00 00	b_num1         .word     $0000,$0000,$0000
>c13b	00 00
>c13d	00 00 00 00	b_num2         .word     $0000,$0000,$0000
>c141	00 00
.c143			b_num0
>c143	00 00 00 00	b_numresult    .word     $0000,$0000,$0000
>c147	00 00
>c149	31 32 38 00	b_testnum      .null     "128"
.c14d			b_praxstr
.c14d	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c150	20 cd bd	               jsr  b_axout
.c153	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c156	60		               rts
.c157			b_getascnum
.c157	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c15a	20 bf e3	               jsr  b_intcgt       ; Initialise charget
.c15d	20 77 c1	               jsr  b_clearbuff    ; Efface le tampon d'entrée de BASIC.
.c160	20 f9 ab	               jsr  b_prompt       ; Affiche ? et peuple de tampon d'entrée de
.c163	86 7a		               stx  $7a            ; X and Y pointent vers $01ff au retour.
.c165	84 7b		               sty  $7b
.c167	20 73 00	               jsr  b_chrget       ; Lit un jeton du périphérique d'entrée.
.c16a	20 f3 bc	               jsr  b_ascflt       ; Conv. ASCII de l'adresse 0200 vers FAC1.
.c16d	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c170	20 47 c2	               jsr  b_getbufflen   ; Calcule la longueur de la chaîne dans var.
.c173	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c176	60		               rts
.c177			b_clearbuff
.c177	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c17a	a9 00		               lda  #$00           ; Place des $00 à toutes adresses de
.c17c	a0 59		               ldy  #$59           ;   $1a6 à $200 pour effacer le
.c17e	99 00 02	clear          sta  $0200,y        ;   tampon d'entrée de BASIC.
.c181	88		               dey                 ;
.c182	d0 fa		               bne  clear          ; 60 octets.
.c184	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c187	60		               rts
.c188			b_printbuff
.c188	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c18b	a9 00		               lda  #$00           ; Positionne le vecteur $0022 et
.c18d	85 22		               sta  $22            ;   $0023 pour quLil pointe vers
.c18f	a9 01		               lda  #$01           ; l'adresse $0100.
.c191	85 23		               sta  $23
.c193	ad 36 c1	               lda  b_bufflenght   ; Charge la longueur de la chaîne.
.c196	20 24 ab	               jsr  b_strout       ; Affiche la chaine
.c199	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c19c	60		               rts
.c19d			b_insub
.c19d	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c1a0	20 bf e3	               jsr  b_intcgt       ; Initialise CHRGET.
.c1a3	20 77 c1	               jsr  b_clearbuff    ; Efface le tampon d'entrée de BASIC.
.c1a6	20 f9 ab	               jsr  b_prompt       ; Affiche ? et peuple de tampon d'entrée de
.c1a9	86 7a		               stx  $7a
.c1ab	84 7b		               sty  $7b
.c1ad	20 73 00	               jsr  b_chrget       ; Lit un jeton du périphérique d'entrée.
.c1b0	20 f3 bc	               jsr  b_ascflt       ; Conv. la chaîne ascii en PF dans FAC1.
.c1b3	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c1b6	60		               rts
.c1b7			b_readmemfloat
.c1b7	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c1ba	20 bf e3	               jsr  b_intcgt       ; Initialisation de CHRGET.
.c1bd	a5 7a		               lda  $7a            ; Sauvegarde des valeurs actuelles des cases
.c1bf	8d 0d c2	               sta  b_v7a          ;   mémoires $007a et $007b.
.c1c2	a5 7b		               lda  $7b
.c1c4	8d 0e c2	               sta  b_v7b
.c1c7	a2 48		               ldx  #<(b_testnum-1); Initialise le pointeur FVAR à l'adresse de
.c1c9	86 7a		               stx  $7a            ; -
.c1cb	a0 c1		               ldy  #>(b_testnum-1); -
.c1cd	84 7b		               sty  $7b            ; - la variable -1.
.c1cf	20 73 00	               jsr  b_chrget       ; Lit un jeton du périphérique d'entrée.
.c1d2	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c1d5	a2 37		               ldx  #<(b_num1)     ; Copie de FAC1 dans la variable b_num1.
.c1d7	a0 c1		               ldy  #>(b_num1)     ;
.c1d9	20 d4 bb	               jsr  b_f1tmem       ;
.c1dc	20 e2 ba	               jsr  b_f1x10        ; Multiplie FAC1 par 10.
.c1df	a2 3d		               ldx  #<(b_num2)     ; Copie de FAC1 dans la variable b_num2.
.c1e1	a0 c1		               ldy  #>(b_num2)     ;
.c1e3	20 d4 bb	               jsr  b_f1tmem       ;
.c1e6	a2 43		               ldx  #<(b_num0)     ; Copie de FAC1 dans la variable b_num0.
.c1e8	a0 c1		               ldy  #>(b_num0)     ;
.c1ea	20 d4 bb	               jsr  b_f1tmem       ;
.c1ed	20 86 c3	               jsr  b_prhexbnum1   ; Affiche b_num1 en hexadécimal.
.c1f0	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c1f3	20 f3 bc	               jsr  b_ascflt       ; Conv. chaîne ASCII vers P.F. dans FAC1.
.c1f6	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c1f9	20 47 c2	               jsr  b_getbufflen   ; Calcule la longueur de la chaîne dans var.
.c1fc	ad 0d c2	               lda  b_v7a          ; Récupération des valeurs initiales des
.c1ff	85 7a		               sta  $7a            ;   cases mémoires $007a et $007b.
.c201	ad 0e c2	               lda  b_v7b          ;
.c204	85 7b		               sta  $7b            ;
.c206	20 77 c1	               jsr  b_clearbuff    ; Efface le tampon d'entrée de BASIC.
.c209	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c20c	60		               rts
>c20d	00		b_v7a          .byte     $00
>c20e	00		b_v7b          .byte     $00
.c20f			b_mul2fptomem
.c20f	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c212	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c215	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 dans $0057.
.c218	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c21b	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c21d	a0 00		               ldy  #$00           ;   premier nombre.
.c21f	20 28 ba	               jsr  b_f1xfv        ; Effectue la multiplication
.c222	a2 43		               ldx  #<b_numresult  ; Initialise le pointeur ou le résultat doit
.c224	a0 c1		               ldy  #>b_numresult  ;   être copié.
.c226	20 d4 bb	               jsr  b_f1tmem       ; Copie FAC1 en mémoire.
.c229	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c22c	60		               rts
.c22d			b_mul2fptoasc
.c22d	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c230	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c233	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 dans $0057.
.c236	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c239	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c23b	a0 00		               ldy  #$00           ;   premier nombre.
.c23d	20 28 ba	               jsr  b_f1xfv        ; Effectue la multiplication :
.c240	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c243	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c246	60		               rts
.c247			b_getbufflen
.c247	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c24a	a0 ff		               ldy  #$ff           ; Détermine la longueur de la chaine en
.c24c	c8		nxtchar        iny                 ;   cherchant le caractère $00
.c24d	b9 00 01	               lda  $0100,y        ;   ($00 = EOS 'End Of String').
.c250	d0 fa		               bne  nxtchar        ; Pas celui là. on passe au prochain.
.c252	c8		               iny                 ; On ajuste Y pour la longueur de la chaîne.
.c253	8c 36 c1	               sty  b_bufflenght   ; Sauvegarde dans le variable.
.c256	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c259	60		               rts
.c25a			b_outsub
.c25a	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c25d	20 47 c2	               jsr  b_getbufflen   ; Calcule la longueur de la chaîne dans var.
.c260	20 88 c1	               jsr  b_printbuff    ; Affiche le contenu du tampon sur le
.c263	20 77 c1	               jsr  b_clearbuff    ; Efface le tampon d'entrée de BASIC.
.c266	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c269	60		               rts
.c26a			b_fac1x10
.c26a	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c26d	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c270	20 e2 ba	               jsr  b_f1x10        ; Multiplie FAC1 par 10.
.c273	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c276	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c279	60		               rts
.c27a			b_fac1d10
.c27a	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c27d	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c280	20 2b bc	               jsr  b_sgnf1        ; Vérifie le signe de FAC1.
.c283	48		               pha                 ; Sauvegarde le signe.
.c284	20 fe ba	               jsr  b_f1d10        ; Divise FAC1 par 10.
.c287	68		               pla                 ; Récupère le signe.
.c288	aa		               tax                 ; Place le signe dans X.
.c289	e8		               inx                 ; Incrémente et si n'est pas
.c28a	d0 04		               bne  notneg         ;   egale à 0 i.e. non négatif.
.c28c	a9 80		               lda  #$80           ; On force le bit de signe
.c28e	85 66		               sta  $66            ;   de FAC1 a 1 (neg).
.c290	20 dd bd	notneg          jsr  b_facasc      ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c293	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c296	60		               rts
.c297			b_fac1square
.c297	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c29a	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c29d	20 0c bc	               jsr  b_f1tf2        ; Copie FAC1 vers FAC2.
.c2a0	a5 61		               lda  $61            ; Récupère l'exposant de FAC1.
.c2a2	20 2b ba	               jsr  b_f1xf2        ; Multiplie FAC1 et FAC2. FAC1=FAC1xFAC2.
.c2a5	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c2a8	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c2ab	60		               rts
.c2ac			b_fvardfac1
.c2ac	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c2af	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c2b2	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 vers $0057.
.c2b5	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c2b8	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c2ba	a0 00		               ldy  #$00           ;   premier nombre.
.c2bc	20 0f bb	               jsr  b_fvdf1        ; Divise FVAR et FAC1. (FAC1=FVAR/FAC1).
.c2bf	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c2c2	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c2c5	60		               rts
.c2c6			b_fac2dfac1
.c2c6	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c2c9	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c2cc	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 vers $0057.
.c2cf	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c2d2	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c2d4	a0 00		               ldy  #$00           ;   premier nombre.
.c2d6	20 8c ba	               jsr  b_memtf2       ; Copie FVAR vers FAC2.
.c2d9	a5 61		               lda  $61            ; Récupère l'exposant de FAC1.
.c2db	20 12 bb	               jsr  b_f2df1        ; Effectue la division: FAC1 = FAC2 / FAC1.
.c2de	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c2e1	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c2e4	60		               rts
.c2e5			b_fac1pfvar
.c2e5	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c2e8	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c2eb	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 vers $0057.
.c2ee	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c2f1	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c2f3	a0 00		               ldy  #$00           ;   premier nombre.
.c2f5	20 67 b8	               jsr  b_f1pfv        ; Effectue l'adition: FAC1 = FAC1 + FVAR.
.c2f8	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c2fb	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c2fe	60		               rts
.c2ff			b_fac2sfac1
.c2ff	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c302	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c305	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 vers $0057.
.c308	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c30b	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c30d	a0 00		               ldy  #$00           ;   premier nombre.
.c30f	20 8c ba	               jsr  b_memtf2       ; Copie FVAR vers FAC2.
.c312	20 53 b8	               jsr  b_f2sf1        ; Effec. la soustraction: FAC1 = FAC2 - FAC1.
.c315	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c318	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c31b	60		               rts
.c31c			b_fvarsfac1
.c31c	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c31f	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c322	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 vers $0057.
.c325	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c328	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c32a	a0 00		               ldy  #$00           ;   premier nombre.
.c32c	20 50 b8	               jsr  b_fvsf1        ; Effec. la soustraction: FAC1 = FVAR - FAC1.
.c32f	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c332	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c335	60		               rts
.c336			b_accpfac1
.c336	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c339	48		               pha                 ; Sauvegarde l'Acc.
.c33a	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c33d	68		               pla                 ; Récupère l'Acc.
.c33e	20 7e bd	               jsr  b_f1pacc       ; Effectue l'adition: FAC1 = FAC1 + ACC.
.c341	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c344	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c347	60		               rts
.c348			b_fac2pfac1
.c348	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c34b	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c34e	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 vers $0057.
.c351	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c354	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c356	a0 00		               ldy  #$00           ;   premier nombre.
.c358	20 8c ba	               jsr  b_memtf2       ; Copie FVAR vers FAC2.
.c35b	a5 61		               lda  $61            ; Récupère l'exposant de FAC1.
.c35d	20 6a b8	               jsr  b_f1pf2        ; Effactue l'adition: FAC1 = FAC1 + FAC2.
.c360	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c363	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c366	60		               rts
.c367			b_fac1powfac2
.c367	20 72 80	               jsr  pushreg        ; Sauvegarde tous les registres.
.c36a	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c36d	20 ca bb	               jsr  b_f1t57        ; Copie FAC1 vers $0057.
.c370	20 9d c1	               jsr  b_insub        ; Capture un nombre de L'entrée STD.
.c373	a9 57		               lda  #$57           ; Charge l'adresse mémoire du
.c375	a0 00		               ldy  #$00           ;   premier nombre.
.c377	20 8c ba	               jsr  b_memtf2       ; Copie FVAR vers FAC2.
.c37a	a5 61		               lda  $61            ; Récupère l'exposant de FAC1.
.c37c	20 7b bf	               jsr  b_expon        ; Calcul FAC1 = FAC1 ^ FAC2.
.c37f	20 dd bd	               jsr  b_facasc       ; Conv. P.F. FAC1 vers chaîne ascii à $0100.
.c382	20 a1 80	               jsr  popreg         ; Récupère tous les registres.
.c385	60		               rts
.c386			b_prhexbnum1
.c386	20 04 80	               jsr  pushall        ; debug
.c389	20 72 80	               jsr  pushreg
.c38c	a2 00		               ldx  #0
.c38e	a0 05		               ldy  #5
.c390	20 57 c0	               jsr  gotoxy
.c393	20 a1 80	               jsr  popreg
.c396	a9 37		               lda  #<b_num1
.c398	85 fb		               sta  zpage1
.c39a	a9 c1		               lda  #>b_num1
.c39c	85 fc		               sta  zpage1+1
.c39e	a0 00		               ldy  #$00
.c3a0	a2 12		               ldx  #18
.c3a2	b1 fb		more           lda  (zpage1),y
.c3a4	20 6c 82	               jsr  putahex
.c3a7	c8		               iny
.c3a8	c0 06		               cpy  #6
.c3aa	d0 0d		               bne  is12
.c3ac	20 72 80	               jsr  pushreg
.c3af	a2 00		               ldx  #0
.c3b1	a0 07		               ldy  #7
.c3b3	20 57 c0	               jsr  gotoxy
.c3b6	20 a1 80	               jsr  popreg
.c3b9	c0 0c		is12           cpy  #12
.c3bb	d0 0d		               bne  doit
.c3bd	20 72 80	               jsr  pushreg
.c3c0	a2 00		               ldx  #0
.c3c2	a0 09		               ldy  #9
.c3c4	20 57 c0	               jsr  gotoxy
.c3c7	20 a1 80	               jsr  popreg
.c3ca	ca		doit           dex
.c3cb	d0 d5		               bne  more
.c3cd	20 3f 80	               jsr  popall
.c3d0	60		               rts

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-binmath.asm

>c3d1	00 00		bmnum0         .word     $0000
>c3d3	00 00		bmnum1         .word     $0000
>c3d5	00 00		bmnum2         .word     $0000
>c3d7	00		bmovfl         .byte     $00
.c3d8			bmaddacc
.c3d8	08		               php
.c3d9	48		               pha
.c3da	a9 00		               lda  #$00
.c3dc	8d d7 c3	               sta  bmovfl
.c3df	68		               pla
.c3e0	48		               pha
.c3e1	18		               clc
.c3e2	6d d1 c3	               adc  bmnum0
.c3e5	8d d1 c3	               sta  bmnum0
.c3e8	90 03		               bcc  norep
.c3ea	ee d2 c3	               inc  bmnum0+1
.c3ed	90 05		norep          bcc  norep2
.c3ef	a9 01		               lda  #$01
.c3f1	8d d7 c3	               sta  bmovfl
.c3f4	68		norep2         pla
.c3f5	28		               plp
.c3f6	60		               rts
.c3f7			bmtester
.c3f7	20 72 80	               jsr  pushreg
.c3fa	a9 01		               lda  #1
.c3fc	20 d8 c3	               jsr  bmaddacc
.c3ff	ac d1 c3	               ldy  bmnum0
.c402	ae d2 c3	               ldx  bmnum0+1
.c405	ad d7 c3	               lda  bmovfl
.c408	20 b1 c5	               jsr  showregs
.c40b	20 a1 80	               jsr  popreg
.c40e	60		               rts
.c40f			add2word
.c40f	20 04 80	               jsr  pushall
.c412	84 fc		               sty  zpage1+1
.c414	86 fb		               stx  zpage1
.c416	20 3f 80	               jsr  popall
.c419	60		               rts
.c41a			add2word2
.c41a	20 72 80	               jsr  pushreg
.c41d	8c 41 c4	               sty adddo+1     ; LSB
.c420	8c 44 c4	               sty adddo2+1    ; LSB
.c423	8c 49 c4	               sty addrep+1    ; LSB
.c426	8e 42 c4	               stx adddo+2     ; MSB
.c429	8e 45 c4	               stx adddo2+2    ; MSB
.c42c	8e 4a c4	               stx addrep+2    ; MSB
.c42f	48		               pha             ; Sauve
.c430	18		               clc
.c431	a9 01		               lda #$01
.c433	6d 49 c4	               adc addrep+1    ; LSB+1
.c436	8d 49 c4	               sta addrep+1
.c439	90 03		               bcc addsamepage
.c43b	ee 4a c4	               inc addrep+2    ; MSB+1
.c43e			addsamepage
.c43e	68		               pla
.c43f	18		               clc
.c440	6d ff ff	adddo          adc $ffff
.c443	8d ff ff	adddo2         sta $ffff
.c446	90 03		               bcc addnorep
.c448	ee ff ff	addrep         inc $ffff
.c44b	20 3f 80	addnorep       jsr pop
.c44e	60		               rts
.c44f			sub2word2
.c44f	20 72 80	               jsr pushreg
.c452	8c 88 c4	               sty subdo+1     ; LSB
.c455	8c 8d c4	               sty subdo2+1    ; LSB
.c458	8c 92 c4	               sty subrep+1    ; LSB
.c45b	8c 97 c4	               sty subrep2+1   ; LSB
.c45e	8e 89 c4	               stx subdo+2     ; MSB
.c461	8e 8e c4	               stx subdo2+2    ; MSB
.c464	8e 93 c4	               stx subrep+2    ; MSB
.c467	8e 98 c4	               stx subrep2+2   ; MSB
.c46a	8d 8b c4	               sta subdo+4     ; Sauve
.c46d	18		               clc
.c46e	a9 01		               lda #$01
.c470	6d 92 c4	               adc subrep+1    ; LSB+1
.c473	8d 92 c4	               sta subrep+1
.c476	8d 97 c4	               sta subrep2+1
.c479	90 09		               bcc subsamepage
.c47b	ee 93 c4	               inc subrep+2    ; MSB+1
.c47e	ad 93 c4	               lda subrep+2
.c481	8d 98 c4	               sta subrep2+2
.c484	00		subsamepage    brk
.c485	68		               pla
.c486	38		               sec
.c487	ad ff ff	subdo          lda $ffff       ; LSB-1
.c48a	e9 ff		               sbc #$ff
.c48c	8d ff ff	subdo2         sta $ffff
.c48f	90 08		               bcc subnorep
.c491	ad ff ff	subrep         lda $ffff
.c494	e9 00		               sbc #$00        ; MSB-1
.c496	8d ff ff	subrep2        sta $ffff
.c499	ae a4 c4	subnorep       ldx memcount+1
.c49c	ac a3 c4	               ldy memcount
.c49f	20 a1 80	               jsr popreg
.c4a2	60		               rts
>c4a3	00 00		memcount       .word $00

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-vicii.asm

.c4a5			screendis
.c4a5	08		               php
.c4a6	48		               pha
.c4a7	ad 11 d0	               lda  $d011
.c4aa	29 ef		               and  #%11101111
.c4ac	8d 11 d0	               sta  $d011
.c4af	68		               pla
.c4b0	28		               plp
.c4b1	60		               rts
.c4b2			screenena
.c4b2	08		               php
.c4b3	48		               pha
.c4b4	ad 11 d0	               lda  $d011
.c4b7	09 10		               ora  #%00010000
.c4b9	8d 11 d0	               sta  $d011
.c4bc	68		               pla
.c4bd	28		               plp
.c4be	60		               rts
=8192			bmpram = 8192
.c4bf			victohighres
.c4bf	08		               php
.c4c0	48		               pha
.c4c1	ad 11 d0	               lda  vicmiscfnc
.c4c4	09 20		               ora  #%00100000     ; 32
.c4c6	8d 11 d0	               sta  vicmiscfnc
.c4c9	ad 18 d0	               lda  vicmemptr
.c4cc	09 08		               ora  #%00001000     ; $08
.c4ce	8d 18 d0	               sta  vicmemptr
.c4d1	a9 ff		               lda  #$ff           ; 255
.c4d3	85 37		               sta  $0037
.c4d5	a9 1f		               lda  #$1f           ; 31
.c4d7	85 38		               sta  $0038
.c4d9	68		               pla
.c4da	28		               plp
.c4db	60		               rts
.c4dc			victonormal
.c4dc	08		               php
.c4dd	48		               pha
.c4de	ad 11 d0	               lda  vicmiscfnc
.c4e1	29 df		               and  #%11011111     ; 233
.c4e3	8d 11 d0	               sta  vicmiscfnc
.c4e6	ad 18 d0	               lda  vicmemptr
.c4e9	29 f7		               and  #%11110111     ; $08
.c4eb	8d 18 d0	               sta  vicmemptr
.c4ee	a9 00		               lda  #$00
.c4f0	85 37		               sta  $0037
.c4f2	a9 a0		               lda  #$a0
.c4f4	85 38		               sta  $0038
.c4f6	20 20 c0	               jsr  cls
.c4f9	68		               pla
.c4fa	28		               plp
.c4fb	60		               rts
.c4fc			vicbmpclear
.c4fc	20 04 80	               jsr  push
.c4ff	a9 04		               lda  #cmauve
.c501	20 2a c5	               jsr  setvicbmpbackcol
.c504	a9 00		               lda  #<8192              ; Place le LSB de 8192 ...
.c506	85 fb		               sta  zpage1              ; ... dans le lsb de zpage1.
.c508	a9 20		               lda  #>8192              ; Place le MSB de 8192 ...
.c50a	85 fc		               sta  zpage1+1            ; ... dans le Msb de zpage1.
.c50c	48		               pha
.c50d	a9 ff		               lda  #<$0000+(8191)
.c50f	8d 28 82	               sta  loopcount
.c512	a9 1f		               lda  #>$0000+(8191)
.c514	8d 29 82	               sta  loopcount+1
.c517	68		               pla
.c518	a0 00		               ldy  #$00
.c51a	a9 0f		next           lda  #$0f
.c51c	91 fb		               sta  (zpage1),y
.c51e	20 59 81	               jsr  inczpage1
.c521	20 08 82	               jsr  loop
.c524	d0 f4		               bne  next
.c526	20 3f 80	               jsr  pop
.c529	60		               rts
.c52a			setvicbmpbackcol
.c52a	20 04 80	               jsr  push
.c52d	29 0f		               and  #$0f
.c52f	8d 5d c5	               sta  vicbmpbackcol
.c532	a0 00		               ldy  #<1024              ; Place le LSB de 8192 ...
.c534	84 fb		               sty  zpage1              ; ... dans le lsb de zpage1.
.c536	a0 04		               ldy  #>1024              ; Place le MSB de 8192 ...
.c538	84 fc		               sty  zpage1+1            ; ... dans le Msb de zpage1.
.c53a	48		               pha
.c53b	a9 00		               lda  #<$0000+(1024)
.c53d	8d 28 82	               sta  loopcount
.c540	a9 04		               lda  #>$0000+(1024)
.c542	8d 29 82	               sta  loopcount+1
.c545	68		               pla
.c546	a0 00		               ldy  #$00
.c548	b1 fb		next           lda  (zpage1),y
.c54a	29 f0		               and  #$f0
.c54c	0d 5d c5	               ora  vicbmpbackcol
.c54f	91 fb		               sta  (zpage1),y
.c551	20 59 81	               jsr  inczpage1
.c554	20 08 82	               jsr  loop
.c557	d0 ef		               bne  next
.c559	20 3f 80	               jsr  pop
.c55c	60		               rts
>c55d	00		vicbmpbackcol  .byte     $00
.c55e			setvicbmpforecol
.c55e	20 04 80	               jsr  push
.c561	2a		               rol
.c562	2a		               rol
.c563	2a		               rol
.c564	2a		               rol
.c565	29 f0		               and  #$f0
.c567	8d 95 c5	               sta  vicbmpforecol
.c56a	a0 00		               ldy  #<1024              ; Place le LSB de 8192 ...
.c56c	84 fb		               sty  zpage1              ; ... dans le lsb de zpage1.
.c56e	a0 04		               ldy  #>1024              ; Place le MSB de 8192 ...
.c570	84 fc		               sty  zpage1+1            ; ... dans le Msb de zpage1.
.c572	48		               pha
.c573	a9 00		               lda  #<$0000+(1024)
.c575	8d 28 82	               sta  loopcount
.c578	a9 04		               lda  #>$0000+(1024)
.c57a	8d 29 82	               sta  loopcount+1
.c57d	68		               pla
.c57e	a0 00		               ldy  #$00
.c580	b1 fb		next           lda  (zpage1),y
.c582	29 0f		               and  #$0f
.c584	0d 95 c5	               ora  vicbmpforecol
.c587	91 fb		               sta  (zpage1),y
.c589	20 59 81	               jsr  inczpage1
.c58c	20 08 82	               jsr  loop
.c58f	d0 ef		               bne  next
.c591	20 3f 80	               jsr  pop
.c594	60		               rts
>c595	00		vicbmpforecol  .byte     $00
.c596			bmphrcalccoords
.c596	20 04 80	               jsr  push
.c599	18		               clc       ; On met Carry à 0
.c59a	6a		               ror       ; le bit 0 de a dans carry  ?/2
.c59b	8a		               txa       ; x dans a
.c59c	4a		               lsr       ; ?/4
.c59d	4a		               lsr       ; ?/8 a = (ax)/8
.c59e	8d af c5	               sta  bmphrcol
.c5a1	98		               tya       ; Y dans a
.c5a2	4a		               lsr       ; ?/2
.c5a3	4a		               lsr       ; ?/4
.c5a4	4a		               lsr       ; ?/8 a=Y/8
.c5a5	8d ae c5	               sta  bmphrrow
.c5a8	48		               pha
.c5a9	98		               tya
.c5aa	20 3f 80	               jsr  pop
.c5ad	60		               rts
.c5ae			vicbmpfill
>c5ae	00		bmphrrow       .byte     $00
>c5af	00		bmphrcol       .byte     $00
>c5b0	00		bmphrmask      .byte     $00

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-showregs.asm

.c5b1			showregs
=23			line    =   23
=0			coln    =   0
=$01			colr    =   vblanc
.c5b1	08		               php                 ; Sauvegarde le registre de status sur stack.
.c5b2	8d a6 c7	               sta  rega           ; Sauvegarde Acc en mémoire.
.c5b5	68		               pla                 ; Récupère le registre de status du stack.
.c5b6	8d a9 c7	               sta  regp           ; Sauvegarde le registre de status en mémoire.
.c5b9	8e a7 c7	               stx  regx           ; Sauvegarde le registre X en mémoire.
.c5bc	8c a8 c7	               sty  regy           ; Sauvegarde le registre Y en mémoire.
.c5bf	ba		               tsx                 ; Copie le registre S dans X.
.c5c0	8e aa c7	               stx  regs           ; Sauvegarde le registre S en mémoire.
.c5c3	68		               pla                 ; Récupère le MSB de l'adresse de retour ...
.c5c4	8d ac c7	               sta  regpcl         ; ... et le sauvegarde en mémoire ...
.c5c7	8d ae c7	               sta  regpcl2        ; ... une seconde fois.
.c5ca	68		               pla                 ; Récupère le LSB de l'adresse de retour ...
.c5cb	8d ab c7	               sta  regpch         ; ... et le sauvegarde en mémoire ...
.c5ce	8d ad c7	               sta  regpch2        ; ... une seconde fois.
.c5d1	ad a6 c7	               lda  rega           ; On commence par le registre Acc.
.c5d4	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c5d5	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c5d8	8d 43 c7	               sta  vala+1         ; ... et le place dans la chaine.
.c5db	68		               pla                 ; Récupère la valeur de l'Acc temporaire.
.c5dc	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c5df	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c5e2	8d 42 c7	               sta  vala           ; ... et le place dans la chaine.
.c5e5	ad a8 c7	               lda  regy           ; Ensuite, le registre Y.
.c5e8	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c5e9	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c5ec	8d 5a c7	               sta  valy+1         ; ... et le place dans la chaine.
.c5ef	68		               pla                 ; Récupère la valeur de l'Acc temporaire.
.c5f0	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c5f3	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c5f6	8d 59 c7	               sta  valy           ; ... et le place dans la chaine.
.c5f9	ad a7 c7	               lda  regx           ; Ensuite, le registre X.
.c5fc	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c5fd	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c600	8d 4e c7	               sta  valx+1         ; ... et le place dans la chaine.
.c603	68		               pla                 ; Récupère la valeur de l'Acc temporaire.
.c604	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c607	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c60a	8d 4d c7	               sta  valx           ; ... et le place dans la chaine.
.c60d	ad a9 c7	               lda  regp           ; Ensuite, le registre de status.
.c610	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c611	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c614	8d 65 c7	               sta  valp+1         ; ... et le place dans la chaine.
.c617	68		               pla                 ; Récupère la valeur de l'Acc temporaire.
.c618	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c61b	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c61e	8d 64 c7	               sta  valp           ; ... et le place dans la chaine.
.c621	ad aa c7	               lda  regs           ; Ensuite, le pointeur de stack.
.c624	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c625	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c628	8d 70 c7	               sta  vals+1         ; ... et le place dans la chaine.
.c62b	68		               pla                 ; Récupère la valeur de l'Acc temporaire.
.c62c	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c62f	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c632	8d 6f c7	               sta  vals           ; ... et le place dans la chaine.
.c635	38		               sec                 ; Prépade le ADC en plaçant 0 dans Carry.
.c636	ad ae c7	               lda  regpcl2        ; On charge la LSB de l'adresse de retour.
.c639	69 00		               adc  #$00           ; On y ajoute 1.
.c63b	90 03		               bcc  noreport       ; Si pas de Carry on ne fait pas de report.
.c63d	ee ad c7	               inc  regpch2        ; ... en incrémentant le MSB.
.c640	8d ae c7	noreport       sta  regpcl2        ; On le sauvegarde.
.c643	ad ae c7	               lda  regpcl2        ; On récupère la partie basse du compteur.
.c646	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c647	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c64a	8d 80 c7	               sta  valpcl+1       ; ... et lace le code à la position "---X".
.c64d	68		               pla                 ; Récupère la valeur de l'Acc temporaire.
.c64e	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c651	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c654	8d 7f c7	               sta  valpcl         ; ... et lace le code à la position "--X-".
.c657	ad ad c7	               lda regpch2         ; On récupère la partie haute du compteur.
.c65a	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c65b	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c65e	8d 7e c7	               sta  valpch+1       ; ... et lace le code à la position "-X--".
.c661	68		               pla                 ; Récupère la valeur de l'Acc temporaire.
.c662	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c665	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c668	8d 7d c7	               sta  valpch         ; ... et lace le code à la position "X---".
.c66b	a5 fb		               lda  zpage1         ; On charge le LSB de ZP1 ($fb).
.c66d	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c66e	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c671	8d 91 c7	               sta  valz1l+1       ; ... et lace le code à la position "---X".
.c674	68		               pla
.c675	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c678	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c67b	8d 90 c7	               sta  valz1l         ; ... et lace le code à la position "--X-".
.c67e	a5 fc		               lda  zpage1+1         ; On charge le MSB de ZP1 ($fc).
.c680	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c681	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c684	8d 8f c7	               sta  valz1h+1       ; ... et lace le code à la position "-X--".
.c687	68		               pla
.c688	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c68b	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c68e	8d 8e c7	               sta  valz1h         ; ... et lace le code à la position "X---".
.c691	a5 fd		               lda  zpage2         ; On charge le LSB de ZP2 ($fd).
.c693	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c694	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c697	8d a2 c7	               sta  valz2l+1       ; ... et lace le code à la position "---X".
.c69a	68		               pla
.c69b	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c69e	20 7d 82	               jsr  nibtohex       ; Converti le second quartet (0-F) ...
.c6a1	8d a1 c7	               sta  valz2l         ; ... et lace le code à la position "--X-".
.c6a4	a5 fe		               lda  zpage2+1       ; On charge le MSB de ZP2 ($fc).
.c6a6	48		               pha                 ; Sauvegarde temporaire de la valeur de Acc.
.c6a7	20 7d 82	               jsr  nibtohex       ; Converti le premier quartet (0-F) ...
.c6aa	8d a0 c7	               sta  valz2h+1       ; ... et lace le code à la position "-X--".
.c6ad	68		               pla
.c6ae	20 89 82	               jsr  lsra4bits      ; Divise par 16 la valeur de l'Acc.
.c6b1	20 7d 82	               jsr  nibtohex
.c6b4	8d 9f c7	               sta  valz2h         ; ... et lace le code à la position "X---".
.c6b7	20 72 80	               jsr  pushreg
.c6ba	a2 3a		               ldx  #<srega
.c6bc	a0 c7		               ldy  #>srega
.c6be	20 ca c0	               jsr  putscxy
.c6c1	20 a1 80	               jsr  popreg
.c6c4	20 72 80	               jsr  pushreg
.c6c7	a2 46		               ldx  #<sregx
.c6c9	a0 c7		               ldy  #>sregx
.c6cb	20 ca c0	               jsr  putscxy
.c6ce	20 a1 80	               jsr  popreg
.c6d1	20 72 80	               jsr  pushreg
.c6d4	a2 51		               ldx  #<sregy
.c6d6	a0 c7		               ldy  #>sregy
.c6d8	20 ca c0	               jsr  putscxy
.c6db	20 a1 80	               jsr  popreg
.c6de	20 72 80	               jsr  pushreg
.c6e1	a2 5d		               ldx  #<sregp
.c6e3	a0 c7		               ldy  #>sregp
.c6e5	20 ca c0	               jsr  putscxy
.c6e8	20 a1 80	               jsr  popreg
.c6eb	20 72 80	               jsr  pushreg
.c6ee	a2 68		               ldx  #<sregs
.c6f0	a0 c7		               ldy  #>sregs
.c6f2	20 ca c0	               jsr  putscxy
.c6f5	20 a1 80	               jsr  popreg
.c6f8	20 72 80	               jsr  pushreg
.c6fb	a2 74		               ldx  #<sregpc
.c6fd	a0 c7		               ldy  #>sregpc
.c6ff	20 ca c0	               jsr  putscxy
.c702	20 a1 80	               jsr  popreg
.c705	20 72 80	               jsr  pushreg
.c708	a2 84		               ldx  #<sregz1
.c70a	a0 c7		               ldy  #>sregz1
.c70c	20 ca c0	               jsr  putscxy
.c70f	20 a1 80	               jsr  popreg
.c712	20 72 80	               jsr  pushreg
.c715	a2 95		               ldx  #<sregz2
.c717	a0 c7		               ldy  #>sregz2
.c719	20 ca c0	               jsr  putscxy
.c71c	20 a1 80	               jsr  popreg
.c71f	ad ab c7	               lda  regpch         ; On replace ls MSB l'adresse de retour ...
.c722	48		               pha                 ; ... à la bonne position sur la pile.
.c723	ad ac c7	               lda  regpcl         ; On replace ls LSB l'adresse de retour ...
.c726	48		               pha                 ; ... à la bonne position sur la pile.
.c727	ae aa c7	               ldx  regs           ; On replace tous les registre à leurs ...
.c72a	9a		               txs                 ; ...
.c72b	ac a8 c7	               ldy  regy           ; ...
.c72e	ae a7 c7	               ldx  regx           ; ...
.c731	ad a9 c7	               lda  regp           ; ...
.c734	48		               pha                 ; ...
.c735	ad a6 c7	               lda  rega           ; ...
.c738	28		               plp                 ; ... valeurs initiales
.c739	60		               rts
>c73a	07 01 17	srega   .byte   cyellow,coln+1,line
>c73d	20 20 41 3a	        .text   '  a:$' ;4,24
>c741	24
>c742	00 00 20 00	vala    .byte   0,0,32,0
>c746	03 09 17	sregx   .byte   ccyan,coln+9,line
>c749	20 58 3a 24	        .text   ' x:$' ;4,24
>c74d	00 00 20 00	valx    .byte   0,0,32,0
>c751	0d 10 17	sregy   .byte   clightgreen,coln+16,line
>c754	20 59 3a 20	        .text   ' y: $' ;4,24
>c758	24
>c759	00 00 20 00	valy    .byte   0,0,32,0
>c75d	08 18 17	sregp   .byte   corange,coln+24,line
>c760	20 50 3a 24	        .text   ' p:$' ;4,24
>c764	00 00 20 00	valp    .byte   0,0,32,0
>c768	0a 1f 17	sregs   .byte   clightred,coln+31,line
>c76b	20 53 3a 24	        .text   ' s:$' ;4,24
>c76f	00 00 20 20	vals    .byte   0,0,32,32,0
>c773	00
>c774	0e 01 18 20	sregpc  .byte   clightblue,coln+1,line+1,32
>c778	20 50 43 3a	        .text   ' pc:$' ;4,24
>c77c	24
>c77d	00 00		valpch  .byte   0,0
>c77f	00 00 20 20	valpcl  .byte   0,0,32,32,0
>c783	00
>c784	04 0d 18 20	sregz1  .byte   cpurple,coln+13,line+1,32
>c788	20 5a 50 31	        .text   ' zp1:$' ;4,24
>c78c	3a 24
>c78e	00 00		valz1h  .byte   0,0
>c790	00 00 20 20	valz1l  .byte   0,0,32,32,0
>c794	00
>c795	0f 1a 18 20	sregz2  .byte   clightgray,coln+26,line+1,32
>c799	20 5a 50 32	        .text   ' zp2:$' ;4,24
>c79d	3a 24
>c79f	00 00		valz2h  .byte   0,0
>c7a1	00 00 20 20	valz2l  .byte   0,0,32,32,0
>c7a5	00
>c7a6	00		rega    .byte   0
>c7a7	00		regx    .byte   0
>c7a8	00		regy    .byte   0
>c7a9	00		regp    .byte   0
>c7aa	00		regs    .byte   0
>c7ab	00		regpch  .byte   0
>c7ac	00		regpcl  .byte   0
>c7ad	00		regpch2 .byte   0
>c7ae	00		regpcl2 .byte   0
>c7af	00		vzp1h   .byte   0
>c7b0	00		vzp1l   .byte   0
>c7b1	00		vzp2h   .byte   0
>c7b2	00		vzp2l   .byte   0

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-ultimateii.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/macro-c64-ultimateii.asm


;******  Return to file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/lib-c64-ultimateii.asm

=$df1c			uiictrlreg	=	$df1c	;(Write)				* CONTROL REGISTER *
=$00								uiiidle		=	$00
=$01								uiicmdbusy	=	$01
=$02								uiidatalast	=	$02
=$03								uiidatamore	=	$03
=$df1c			uiicmdstat	=	$df1c	;(Read)	default $00	* CMD STATUS REGISTER *
=$df1d			uiicmddata	=	$df1d	;(Write)				* COMMAND DATA REGISTER *
=$df1d			uiiidenreg	=	$df1d	;(Read)	default $c9	* API ID REGISTER *
=$df1e			uiirxdata		=	$df1e	;(Read only)			* DATA REGISTER *
=$df1f			uiidatastat	=	$df1f	;(Read only)			* DATA STATUS REGISTER *
=$01			uii_identify	=	$01	; $01 $01 -> Read Id String as "ULTIMATE-II DOS V1.0"
=$02			uii_file_open	=	$02	; Open file for ...
=$01			uii_fa_read	=	$01	; $01 $02 $01 <filename> -> ... reading.
=$02			uii_fa_write	=	$02	; $01 $02 $02 <filename> -> ... writing.
=$04			uii_fa_new	=	$04	; $01 $02 $04 <filename> -> ... creating/writing.
=$08			uii_fa_ovwri	=	$08	; $01 $02 $08 <filename> -> ... overwriting.
=$03			uii_file_close	=	$03	; $01 $03 -> close opened file.
=$04			uii_read_data	= 	$04  ; $01 $04 [len_lo] [len_hi]
=$05			uii_writ_data	=	$05	; $01 $05 [dummy] [dummy] [data...]
=$06			uii_file_seek	=	$06	; $01 $06 [posl] [posml] [posmh] [posh].
=$07			uii_file_info 	=	$07	; $01 $07 -> returns current open file info.
=$08			uii_file_stat  = 	$08	; $01 $08 <filename> -> returns file info.
=$09			uii_file_del	=	$09	; $01 $09 <filename> -> delete/scratch file.
=$0a			uii_file_ren	=	$0a	; $01 $0a <filename> $00 <newname>
=$0b			uii_file_copy	=	$0b	; $01 $0b <source> $00 <destination>
=$11			uii_dir_change = 	$11	; $01 $11 <directory name>
=$12			uii_dir_pwd	=	$12	; $01 $12
=$13			uii_dir_open	=	$13	; $01 $13
=$14			uii_dir_read	=	$14  ; $01 $14
=$15			uii_dir_cp_ui	=	$15	; $01 $15 -> makes UI current path as API current path.
=$16			uii_dir_mkdir	=	$16	; $01 $16 <dirname> -> Create directory under current.
=$17			uii_dir_home	=	$17	; $01 $17 -> makes UI home path as API current path.
=$21			uii_reu_load	=	$21
=$22			uii_reu_save	=	$22
=$23			uii_dsk_mount	=	$23	; $01 $23 <id> <filename>
=$24			uii_dsk_umount = 	$24	; $01 $24 <id>
=$25			uii_dsk_swap 	= 	$25	; $01 $25 <id>
=$26			uii_time_get	=	$26	; $01 $26 [id] -> returns current RTC time/date.
=$27			uii_time_set	=	$27	; $01 $27 <Y> <M> <D> <H> <M> <S>
=$f0			uii_dos_echo	= 	$f0	; $01 $f0
>c7b3	01 01 00	uiicmdgetid       	.byte     $01,$01,$00
>c7b6	01 26 00	uiicmdgettime		.byte	$01,$26,$00
>c7b9			rxbuffer         .fill     256
>c8b9	00		rxbstart         .byte     0
>c8ba	00		rxbend           .byte     0
>c8bb	00		rxbflag          .byte     0
>c8bc			txbuffer         .fill     256
>c9bc	00		txbstart         .byte     0
>c9bd	00		txbend           .byte     0
>c9be	00		txbflag          .byte     0
.c9bf			uiifisbusy
.c9bf	48					pha
.c9c0	ad 1c df				lda	uiicmdstat
.c9c3	29 01					and	#%00000001	; Mask bit 0 of the command status register.
.c9c5	49 01					eor	#%00000001	; Reverse Logic  BEQ if Busy, BNE if free.
.c9c7	68					pla
.c9c8	60					rts
.c9c9			uiifbusywait
.c9c9	08					php
.c9ca	20 bf c9	wait			jsr	uiifisbusy
.c9cd	f0 fb					beq	wait			; Waiting for Busy to disappear.
.c9cf	28					plp
.c9d0	60					rts
.c9d1			uiifisdataacc
.c9d1	48					pha
.c9d2	ad 1f df				lda	uiidatastat
.c9d5	29 02					and	#%00000010	; Mask bit 1 of the command status register.
.c9d7	49 02					eor	#%00000010	; Reverse Logic  BEQ if Dacc, BNE if /Dacc.
.c9d9	68		out			pla
.c9da	60					rts
.c9db			uiifdaccwait
.c9db	08					php
.c9dc	20 d1 c9	wait			jsr 	uiifisdataacc
.c9df	d0 fb					bne	wait			; Waiting for Dacc to appears.
.c9e1	28					plp
.c9e2	60					rts
.c9e3			uiifisabortp
.c9e3	48					pha ; Bit 2
.c9e4	ad 1c df				lda	uiicmdstat
.c9e7	29 04					and	#%00000100	; Mask bit 2 of the command status register.
.c9e9	49 04					eor	#%00000100	; Rev. Logic   BEQ if Abort pending
.c9eb	68					pla
.c9ec	60					rts
.c9ed			uiifabortpwait
.c9ed	08					php
.c9ee	20 e3 c9	wait			jsr 	uiifisabortp
.c9f1	d0 fb					bne	wait			; Waiting for Dacc to appears.
.c9f3	28					plp
.c9f4	60					rts
.c9f5			uiifiscerror
.c9f5	48					pha ; Bit 3
.c9f6	ad 1c df				lda	uiicmdstat
.c9f9	29 08					and	#%00001000	; Mask bit 3 of the command status register.
.c9fb	49 08					eor	#%00001000	; Rev. Logic   BEQ if ERROR
.c9fd	68					pla
.c9fe	60					rts
.c9ff			uiifgetcmdstat
.c9ff	08					php	; Bits 5,4
.ca00	ad 1c df				lda	uiicmdstat
.ca03	4a					lsr				; Shifting bits 4 position to the right.
.ca04	4a					lsr				; Bits 5 and 4 are now in bits 1 and 0
.ca05	4a					lsr
.ca06	4a					lsr
.ca07	29 03					and	#%00000011
.ca09	28					plp
.ca0a	60					rts
.ca0b			uiifisrdataavail
.ca0b	48					pha
.ca0c	20 ff c9	notyet		jsr	uiifgetcmdstat
.ca0f	29 02					and	#%00000010	; Mask bit 3 of the command status register.
.ca11	49 02					eor	#%00000010	; Rev. Logic   BEQ if ERROR
.ca13	68					pla
.ca14	60					rts
.ca15			uiifisstatdata
.ca15	48					pha ; Bit 6
.ca16	ad 1c df				lda	uiicmdstat
.ca19	29 40					and	#%01000000	; Mask bit 6 of the command status register.
.ca1b	49 40					eor	#%01000000	; Rev. Logic   BEQ if stat data avail.
.ca1d	68					pla
.ca1e	60					rts
.ca1f			uiifisrespdata
.ca1f	48					pha ; Bit 7
.ca20	ad 1c df				lda	uiicmdstat
.ca23	29 80					and	#%10000000	; Mask bit 6 of the command status register.
.ca25	49 80					eor	#%10000000	; Rev. Logic   BEQ if stat data avail.
.ca27	68					pla
.ca28	60					rts
.ca29			uiifsendpushcmd
.ca29	08					php
.ca2a	48					pha
.ca2b	a9 01					lda	#%00000001
.ca2d	8d 1c df				sta	uiictrlreg
.ca30	68					pla
.ca31	28					plp
.ca32	60					rts
.ca33			uiifsenddataacc
.ca33	08					php
.ca34	48					pha
.ca35	a9 02					lda	#%00000010
.ca37	8d 1c df				sta	uiictrlreg
.ca3a	68					pla
.ca3b	28					plp
.ca3c	60					rts
.ca3d			uiifsendabort
.ca3d	08					php
.ca3e	48					pha
.ca3f	a9 04					lda	#%00000100
.ca41	8d 1c df				sta	uiictrlreg
.ca44	68					pla
.ca45	28					plp
.ca46	60					rts
.ca47			uiifwaitidle
.ca47	08					php
.ca48	20 ff c9	notyet		jsr	uiifgetcmdstat
.ca4b	c9 00					cmp	#$00
.ca4d	d0 f9					bne	notyet
.ca4f	28					plp
.ca50	60					rts
.ca51			uiifismoredata
.ca51	48					pha
.ca52	20 ff c9				jsr	uiifgetcmdstat
.ca55	29 02					and	#%00000010
.ca57	49 02					eor	#%00000010
.ca59	68					pla
.ca5a	60					rts
.ca5b			uiifputcmdbyte
.ca5b	20 c9 c9				jsr 	uiifbusywait
.ca5e	8d 1d df				sta	uiicmddata
.ca61	60					rts
.ca62			uiifsndcmd
.ca62	20 04 80				jsr	push
.ca65	86 fb					stx	zpage1
.ca67	84 fc					sty	zpage1+1
.ca69	a0 00					ldy	#$00
.ca6b	b1 fb		next			lda	(zpage1),y
.ca6d	f0 07					beq	finish
.ca6f	20 5b ca				jsr	uiifputcmdbyte
.ca72	c8					iny
.ca73	4c 6b ca				jmp	next
.ca76	a9 01		finish		lda	#$01
.ca78	8d 1c df				sta	uiictrlreg
.ca7b	20 3f 80				jsr	pop
.ca7e	60					rts
.ca7f			uiifreadrxdata
.ca7f	08					php
.ca80	20 c9 c9				jsr	uiifbusywait
.ca83	20 0b ca				jsr	uiifisrdataavail
.ca86	f0 06					beq	nodata
.ca88	ad 1e df				lda	uiirxdata
.ca8b	4c 90 ca				jmp	outdata
.ca8e	a9 00		nodata		lda	#$00
.ca90	28		outdata		plp
.ca91	60					rts
.ca92			uiifreadsdata
.ca92	08					php
.ca93	20 c9 c9				jsr	uiifbusywait
.ca96	20 15 ca				jsr	uiifisstatdata
.ca99	f0 06					beq	nodata
.ca9b	ad 1f df				lda	uiidatastat
.ca9e	4c a3 ca				jmp	outdata
.caa1	a9 00		nodata		lda	#$00
.caa3	28		outdata		plp
.caa4	60					rts

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/map-c64-kernal.asm

=$00			u6510ddr       =    $00       ; 0       6510 port data dir. reg. (def: %xx101111)
=$01			u6510map       =    $01       ; 1       6510 port used as memory map reg.
=$02			unused2        =    $02       ; 2       Unused.
=$03			adray1         =    $03       ; 3-4     Vector to routine to convert a number ...
=$05			adray2         =    $05       ; 5-6     Vector to routine to convert a number ...
=$07			b_charac       =    $07       ; 7       Search character for scanning ...
=$08			b_endchr       =    $08       ; 8       Search character for scanning ...
=$09			b_trmpos       =    $09       ; 9       Cursor column position before the ...
=$0a			verck          =    $0a       ; 10      Flag: 0=Load or 1=Check
=$0b			b_count        =    $0b       ; 11      Index into the Text Input Buffer ...
=$0c			dimflg         =    $0c       ; 12      Flags for routine that locate or build array.
=$0d			valtyp         =    $0d       ; 13 Flag: Type of data ($ff=string or $00=numeric)
=$0e			intflg         =    $0e       ; 14 Numeric data Type ($80=Integer or $00=Float)
=$0f			garbfl         =    $0f       ; 15 Flag for list, Garbage collection, ...
=$10			subflg         =    $10       ; 16 Flag: Subscript reference to an array or ...
=$11			inpflg         =    $11       ; 17 Flag: Is data input to GET, READ or INPUT.
=$12			tansgn         =    $12       ; 18 Flag: Sign of result of TAN or SIN.
=$13			channl         =    $13       ; 19 Current i/o channel # (CMD logical file).
=$14			linnum         =    $14       ; 20-21 Integer line number value.
=$16			temppt         =    $16       ; 22      Ptr to next space in temp. string stack.
=$17			lastpt         =    $17       ; 23-24 Ptr to last string in temp. string stack.
=$2b			txttab         =    $2b       ; 43-44 Ptr to start of BASIC Program text.
=$2d			vartab         =    $2d       ; 45-46 Ptr to start of BASIC Variable area.
=$2f			arytab         =    $2f       ; 47-48 Ptr to start of BASIC Array area.
=$31			strebd         =    $31       ; 49-50 Ptr to END of BASIC Array area(+1) ...
=$33			fretop         =    $33       ; 51-52 Ptr to bottom of string text area.
=$35			frespc         =    $35       ; 53-54 Temp. ptr for string.
=$37			memsiz         =    $37       ; 55-56 Ptr to highest address used by BASIC.
=$39			curlib         =    $39       ; 57-58 Current BASIC line number.
=$3b			oldlin         =    $3b       ; 59-60 Previous BASIC line number.
=$3d			oldtxt         =    $3d       ; 61-62 Ptr to current BASIC statement address.
=$3f			datlin         =    $3f       ; 63-64 Current DATA line number.
=$41			datptr         =    $41       ; 65-66 Current DATA item address ptr.
=$43			impptr         =    $43       ; 67-68 GET, READ or INPUT info. source ptr.
=$45			varnam         =    $45       ; 69-70 Current BASIC variable name.
=$47			varpnt         =    $47       ; 71-72 Ptr to current BASIC variable value.
=$49			forpnt         =    $49       ; 73-74 Temp Ptr to index variable used by FOR.
=$4b			opptr          =    $4b       ; 75-76 Math operator table displacement.
=$4d			opmask         =    $4d       ; 77 Mask for comparison operation.
=$4e			defpnt         =    $4e       ; 78-79 Pointer to current FN descriptor.
=$50			dscpnt         =    $50       ; 80-82 Tmp ptr to current string descriptor.
=$53			four6          =    $53       ;  83 Constant of garbage collector.
=$54			jmper          =    $54       ;  84-86 Jump to function Instruction.
=$61			fac1           =    $61       ;  97-102 Floating point Accumulator #1
=$73			chrget         =    $73       ;  115
=$79			chrgot         =    $79       ;  121
=$90			kiostatus      =    $90       ;  144 Kernal I/O status word (st) (byte)
=$b7			curfnlen       =    $b7       ;  183 Current filename length (byte)
=$b9			cursecadd      =    $b9       ;  185 Current secondary address (byte)
=$ba			curdevno       =    $ba       ;  186 Current device number (byte)
=$bb			curfptr        =    $bb       ;  187 Current file pointer (word)
=$c1			stal           =    $c1       ;  $c1-$c2 (193-194) ptr to ram address to load/save
=$c5			lstx           =    $c5       ;  197 matrix coordinate of last key pressed
=$c6			ndx            =    $c6       ;  198 Number of character in keyboard buffer
=$fb			zpage1         =    $fb       ;  251 zero page 1 address (word)
=$fd			zpage2         =    $fd       ;  253 zero page 2 address (word)
=$fb			zeropage       =    zpage1
=$fd			zonepage       =    zpage2
=$277			kbbuff         =    $277      ;  631
=$286			carcol         =    $286      ;  646 basic next chr colscreenram (byte)
=$288			hibase         =    $288      ;  648
=$286			kcarcol        =    carcol
=$286			bascol         =    carcol
=$28d			shflag         =    $28d      ; 653
=$30a			ieval          =    $30a
=$314			cinv           =    $314      ; $314-$315 brk instruction interupt
=$33c			tbuffer        =    $33c      ; 828-1019 Cassette i/o buffer
=$326			ibsout         =    $326      ; 806
=$33c			tpbuff         =    $33c      ; $033c-$03fb (828-1019)
=$400			scrnram        =    $400      ; 1024 video character ram
=$400			scrram0        =    scrnram   ; 1024
=$500			scrram1        =    $500      ; 1280
=$600			scrram2        =    $600      ; 1536
=$700			scrram3        =    $700      ; 1792
=$801			basicsta       =    $801      ; 2049  basic start address
=$a000			basicrom       =    $a000     ; 40960 Basic rom base address
=$d000			chargen        =    $d000
=$d400			sid            =    $d400     ; 54272 sid base address
=$d800			colorram       =    $d800     ; 55296 video color ram
=$d800			colram         =    $d800     ; 55296 video color ram
=$d800			colram0        =    colorram  ; 55296
=$d900			colram1        =    $d900     ; 55552
=$da00			colram2        =    $da00     ; 55808
=$db00			colram3        =    $db00     ; 56064
>caa5	00 d8 00 d9	colorptr  .word     colram0,colram1,colram2,colram3
>caa9	00 da 00 db
=$dc00			cia1           =    $dc00     ; 56320 cia1 base address
=$dc00			cia1pra        =    $dc00     ; 56320 cia1 dataport A (keyboard column Write)
=$dc01			cia1prb        =    $dc01     ; 56321 cia1 dataport B (keyboard row read)
=$dc02			cia1ddra       =    $dc02     ; 56322 cia1 data direction A
=$dc03			cia1ddrb       =    $dc03     ; 56323 cia1 data direction B
=$dc04			cia1tmalo      =    $dc04     ; 56324 cia1 timer A low byte
=$dc05			cia1tmahi      =    $dc05     ; 56325 cia1 timer A high byte
=$dc06			cia1tmblo      =    $dc06     ; 56326 cia1 timer B low byte
=$dc07			cia1tmbhi      =    $dc07     ; 56327 cia1 timer B high byte
=$dc08			cia1todten     =    $dc08     ; 56328 cia1 time of day clock seconds/10
=$dc09			cia1todsec     =    $dc09     ; 56329 cia1 time of day clock seconds
=$dc0a			cia1todmin     =    $dc0a     ; 56330 cia1 time of day clock minutes
=$dc0b			cia1todhrs     =    $dc0b     ; 56331 cia1 time of day clock hours
=$dc0c			cia1sdr        =    $dc0c     ; 56332 cia1 serial data port
=$dc0d			cia1icr        =    $dc0d     ; 56333 cia1 Interupt control register
=$dc0e			cia1cra        =    $dc0e     ; 56334 cia1 control register A
=$dc0f			cia1crb        =    $dc0f     ; 56335 cia1 control register B
=$dd00			cia2           =    $dd00     ; 56576 cia2 base address
=$dd00			cia2pra        =    $dd00     ; 56576 cia2 dataport A
=$dd01			cia2prb        =    $dd01     ; 56577 cia2 dataport B
=$dd02			cia2ddra       =    $dd02     ; 56578 cia2 data direction A
=$dd03			cia2ddrb       =    $dd03     ; 56579 cia2 data direction B
=$dd04			cia2tmalo      =    $dd04     ; 56580 cia2 timer A low byte
=$dd05			cia2tmahi      =    $dd05     ; 56581 cia2 timer A high byte
=$dd06			cia2tmblo      =    $dd06     ; 56582 cia2 timer B low byte
=$dd07			cia2tmbhi      =    $dd07     ; 56583 cia2 timer B high byte
=$dd08			cia2todten     =    $dd08     ; 56584 cia2 time of day clock seconds/10
=$dd09			cia2todsec     =    $dd09     ; 56585 cia2 time of day clock seconds
=$dd0a			cia2todmin     =    $dd0a     ; 56586 cia2 time of day clock minutes
=$dd0b			cia2todhrs     =    $dd0b     ; 56587 cia2 time of day clock hours
=$dd0c			cia2sdr        =    $dd0c     ; 56588 cia2 serial data port
=$dd0d			cia2icr        =    $dd0d     ; 56589 cia2 Interupt control register
=$dd0e			cia2cra        =    $dd0e     ; 56590 cia2 control register A
=$dd0f			cia2crb        =    $dd0f     ; 56501 cia2 control register B
=$e000			kernalrom      =    $e000     ; 57344 start of kernal rom
=$ea31			irq            =    $ea31     ; 59953 irq entry point
=$03			bstop          =    $03       ;  03 [STOP],     [CTRL]-[C]
=$05			bwhite         =    $05       ;  05 [CTRL]+[2], [CTRL]-[E], Set colour to WHITE
=$08			block          =    $08       ;  08 Disable char map switch with [SHIFT]+[C=]
=$09			bunlock        =    $09       ;  09 Enabled char map switch with [SHIFT]+[C=]
=$0d			bcarret        =    $0d       ;  11 [RETURN]
=$0e			btext          =    $0e       ;  14 CTRL]-[N] select Upper/lowercase charset
=$11			bcrsdn         =    $11       ;  17 [CRS-D]           Cursor DOWN 1 line
=$12			brevcol        =    $12       ;  18 [CTRL]+[9]        REVERSE VIDEO ON
=$13			bhome          =    $13       ;  19 [HOME]            Cursor HOME
=$14			bdelete        =    $14       ;  20 [DELETE]          Delete 1 char
=$1c			bred           =    $1c       ;  28 [CTRL]+[3]        Set colour to RED
=$1d			bcuright       =    $1d       ;  29 [CRS-R]           Cursor RIGHT
=$1e			bgreen         =    $1e       ;  30 [CTRL]+[6]        Set colour to GREEN
=$1f			bblue          =    $1f       ;  31 [CTRL]+[7]        Set colour to BLUE
=$81			borange        =    $81       ; 129 [C=]+[1]          Set colour to ORANGE
=$85			f1key          =    $85       ; 133 [F1]
=$86			f2key          =    $86       ; 134 [F2]
=$87			f3key          =    $87       ; 135 [F3]
=$88			f4key          =    $88       ; 136 [F4]
=$89			f5key          =    $89       ; 137 [F5]
=$8a			f6key          =    $8a       ; 138 [F6]
=$8b			f7key          =    $8b       ; 139 [F7]
=$8c			f8key          =    $8c       ; 140 [F8]
=17			dcurkey        =    17
=145			ucurkey        =    145
=29			rcurkey        =    29
=157			lcurkey        =    157
=95			larrowkey      =    95
=94			uarrowkey      =    94
=19			homekey        =    19
=147			clearkey       =    147
=20			delkey         =    20
=148			inskey         =    148
=$8d			bcarret1       =    $8d       ; 141 [SHIFT]+[RETURN]
=$8e			bgraph         =    $8e       ; 142 select Uppercase+graphics charset
=$90			bblack         =    $90       ; 144 [CTRL]+[1]        Set colour to BLACK
=$91			bcuup          =    $91       ; 145 [SHIFT]+[CRS-D]   cursor UP 1 line
=$92			brevoff        =    $92       ; 146 [CTRL]+[0]        REVERSE VIDEO OFF
=$93			bclear         =    $93       ; 147 [SHIFT]+[HOME]    CLEAR SCREEN
=$94			binsert        =    $94       ; 148 [SHIFT]+[DELETE]  INSERT a char
=$95			bbrown         =    $95       ; 149 [C=]+[2]          Set colour to BROWN
=$96			bltred         =    $96       ; 150 [C=]+[3]          Set colour to PINK
=$97			bdkgrey        =    $97       ; 151 [C=]+[4]          Set colour to DARK GREY
=$98			bmdgrey        =    $98       ; 152 [C=]+[5]          Set colour to MEDIUM GREY
=$99			bltgreen       =    $99       ; 153 [C=]+[6]          Set colour to LIGHT GREEN
=$9a			bltblue        =    $9a       ; 154 [C=]+[7]          Set colour to LIGHT BLUE
=$9b			bltgrey        =    $9b       ; 155 [C=]+[8]          Set colour to LIGHT GREY
=$9c			bmagenta       =    $9c       ; 156 [CTRL]+[5]        Set colour to MAGENTA
=$9d			bculeft        =    $9d       ; 157 [SHIFT]+[CRS-R]   cursor RIGHT 1 pos
=$9e			byellow        =    $9e       ; 158 [CTRL]+[8]        Set colour to YELLOW
=$9f			bcyan          =    $9f       ; 159 [CTRL]+[4]        Set colour to CYAN
=$a0			bspace1        =    $a0       ; 169                   space
=$e0			bspace2        =    $e0       ; 224                   space
=$0			cnoir          =    $0
=$1			cblanc         =    $1
=$2			crouge         =    $2
=$3			cocean         =    $3
=$4			cmauve         =    $4
=$5			cvert          =    $5
=$6			cbleu          =    $6
=$7			cjaune         =    $7
=$8			corange        =    $8
=$9			cbrun          =    $9
=$a			crose          =    $a
=$b			cgrisfonce     =    $b
=$c			cgrismoyen     =    $c
=$b			cgris0         =    $b
=$c			cgris1         =    $c
=$d			cvertpale      =    $d
=$e			cbleupale      =    $e
=$f			cgrispale      =    $f
=$f			cgris3          =    $f
=$0			cblack         =    $0
=$1			cwhite         =    $1
=$2			cred           =    $2
=$3			ccyan          =    $3
=$4			cpurple        =    $4
=$5			cgreen         =    $5
=$6			cblue          =    $6
=$7			cyellow        =    $7
=$9			cbrown         =    $9
=$a			clightred      =    $a
=$b			cdarkgray      =    $b
=$c			cmidgray       =    $c
=$d			clightgreen    =    $d
=$e			clightblue     =    $e
=$f			clightgray     =    $f
=$00			vnoir          =    %00000000
=$00			vblack         =    %00000000
=$01			vblanc         =    %00000001
=$01			vwhite         =    %00000001
=$02			vrouge         =    %00000010
=$02			vred           =    %00000010
=$03			vocean         =    %00000011
=$03			vcyan          =    %00000011
=$04			vmauve         =    %00000100
=$04			vpurple        =    %00000100
=$05			vvert          =    %00000101
=$05			vgreen         =    %00000101
=$06			vbleu          =    %00000110
=$06			vblue          =    %00000110
=$07			vjaune         =    %00000111
=$07			vyellow        =    %00000111
=$08			vorange        =    %00001000
=$09			vbrun          =    %00001001
=$09			vbrown         =    %00001001
=$0a			vrose          =    %00001010
=$0a			vpink          =    %00001010
=$0b			vgris          =    %00001011
=$0b			vgray          =    %00001011
=$0b			vgrey          =    %00001011
=$0c			vgris1         =    %00001100
=$0c			vgray1         =    %00001100
=$0c			vgrey1         =    %00001100
=$0d			vvert1         =    %00001101
=$0d			vgreen1        =    %00001101
=$0e			vbleu1         =    %00001110
=$0e			vblue1         =    %00001110
=$0f			vgris2         =    %00001111
=$0f			vgray2         =    %00001111
=$0f			vgrey2         =    %00001111
=$e1d4			setprms= $e1d4 ; Set parameters for LOAD, SAVE, and verify
=$ed09			stalk  = $ed09 ; Send Talk command to serial bus.
=$ed0c			slisten= $ed0c ; Send LISTEN command to serial bus.
=$ed40			sflush = $ed40 ; Flush serial bus output cache at memory address $0095, to
=$edb9			slisten2= $edb9 ; Send LISTEN secondary addressto serial bus.
=$edb9			stalk2 = $edb9 ; Send TALK secondary addressto serial bus.
=$eddd			sbout  = $eddd ; Write byte to serial bus.
=$edef			sutalk = $edef ; Send UNTalk command to serial bus.
=$edfe			sulisten= $edfe ; Send UNLISTEN command to serial bus.
=$ee85			sclkhigh= $ee85 ; Set CLOCK OUT to High
=$ee8e			sclklow= $ee8e ; Set CLOCK OUT to low
=$ee97			sdathigh= $ee97 ; Set DATA OUT to High
=$eea0			sdatlow= $eea0 ; Set DATA OUT to low
=$eea9			sclkdta= $eea9 ; Read CLOCK IN and DATA IN.
=$f1ad			sbread = $f1ad ; Read one byte from serial port.
=$f237			sstdin = $F237 ; Define serial bus as standard input; do not send TALK
=$f279			sstdout= $F279 ; Define serial bus as standard output; do not send LISTEN
=$f3d5			sfopen = $F3D5 ; Open file on serial bus; do not send file name if secondary
=$f528			sutclose= $F528 ; Send UNTALK and CLOSE command to serial bus.
=$f63f			sulclose= $F63F ; Send UNLISTEN and CLOSE command to serial bus.
=$f642			sfclose= $F642 ; Close file on serial bus; do not send CLOSE secondary address
=$fe21			stimeout= $FE21 ; Unknown. (Set serial bus timeout.)
=$ffa5			acptr  = $ffa5 ; jmp $ee13 Recoit un caractere provenant du port serie
=$ffc6			chkin  = $ffc6 ; jmp ($031e) Define an input channel.
=$ffc9			chkout = $ffc9 ; jmp ($0320) Define an output channel.
=$ffcf			chrin  = $ffcf ; jmp ($0324) Get a character from the input channel
=$ffd2			chrout = $ffd2 ; jmp ($0326) Output a character
=$ff81			cint   = $ff81 ; jsr $e518 Initialize the screen editor and vic-ii chip
=$ffa8			ciout  = $ffa8 ; jmp $eddd Transmit a byte over the serial bus
=$ffe7			clall  = $ffe7 ; jmp ($032c) Close all open files
=$ffc3			close  = $ffc3 ; jmp ($031c) Close a logical file
=$ffcc			clrchn = $ffcc ; jmp ($0322) - Clear all i/o channels.
=$ffe4			getin  = $ffe4 ; jmp ($032a) Get a character.
=$fff3			iobase = $fff3 ; jmp $e500 Define i/o memory page
=$ff84			ioinit = $ff84 ; ($fda3) Initialize i/o devices.
=$ffb1			listen = $ffb1 ; jmp ($ed0c) Command a device on the serial bus to listen.
=$ffd5			load   = $ffd5 ; jmp $f4e9 Load device to RAM.
=$ff9c			membot = $ff9c ; jmp $fe34 Get/set bottom of memory.
=$ff99			memtop = $ff99 ; jmp $fe25 Get/Set top of ram
=$ffc0			open   = $ffc0 ; jmp ($031a) Open a logical file
=$fff0			plot   = $fff0 ; jmp $e50a Set or retrieve cursor location x=column, y=line
=$ff87			ramtas = $ff87 ; ($fd50) Initialise ram, tape buffer and screen.
=$ffde			rdtim  = $ffde ; jmp $f6dd Read system clock
=$ffb7			readst = $ffb7 ; jmp $fe07 Read i/o status word
=$ff8a			restor = $ff8a ; jmp $fd15 Restore default I/O vectors.
=$ffd8			save   = $ffd8 ; jmp $f5dd Save memory to a device.
=$ff9f			scnkey = $ff9f ; jmp $ea87 Scan the keyboard
=$ffed			screen = $ffed ; jmp $e505 Return screen format
=$ff93			second = $ff93 ; jmp $edb9 Send secondary address after listen
=$ffba			setlfs = $ffba ; jmp $fe00 Set up a logical file
=$ff90			setmsg = $ff90 ; jmp $fe18 Set kernal message output flag
=$ffbd			setnam = $ffbd ; jmp $fdf9 Set up file name
=$ffdb			settim = $ffdb ; jmp $f6e4 Set the system clock.
=$ffa2			settmo = $ffa2 ; jmp $fe21 Set ieee bus card timeout flag
=$ffe1			stop   = $ffe1 ; jmp ($0328) Check if stop key is pressed.
=$ffb4			talk   = $ffb4 ; jmp $ed09 Command a device on the serial bus to talk
=$ff96			tksa   = $ff96 ; jmp $edc7 Send a secondary address to a device commanded to talk
=$ffea			udtim  = $ffea ; jmp $f69b Update the system clock
=$ffae			unlsn  = $ffae ; jmp $edfe Send an unlisten command
=$ffab			untlk  = $ffab ; jmp $edef Send an untalk command
=$ff8d			vector = $ff8d ; jmp $fd1a Read/set I/O vectors.
=$e043			kd_poly1       =    $e043
=$e059			kd_poly2       =    $e059
=$e08d			kd_rmulc       =    $e08d       ;
=$e092			kd_raddc       =    $e092       ;
=$e097			kd_rnd         =    $e097
=$e12a			kd_sys         =    $e12a
=$e156			kd_save        =    $e156
=$e165			kd_verify      =    $e165
=$e168			kd_load        =    $e168
=$f1ca			kd_chrout      =    $f1ca
=$ff81			kcint          =    cint           ;   , init vic + ecran.
=$ff84			kioinit        =    ioinit         ;   , init i/o dev.
=$ff87			kramtas        =    ramtas         ;   , test de memoire.
=$ffa8			kciout         =    ciout          ;a  ,tx byte  acia
=$ff8a			krestor        =    restor         ;   , set ram plafond
=$ff8d			kvector        =    vector         ;
=$ff90			ksetmsg        =    setmsg         ;a  , set sys. msg. out
=$ff93			ksecond        =    second         ;a  , tx adresse sec.
=$ff96			ktksa          =    tksa           ;a  , talk adresse sec.
=$ff99			kmemtop        =    memtop         ; yx, (c) get mem high
=$ff9c			kmembot        =    membot         ; yx, (c) get mem low
=$ff9f			kscankey       =    scnkey         ;   , scan clavier
=$ffa2			ksettmo        =    settmo         ;a  , set ieee timeout
=$ffa5			kacptr         =    acptr          ;a  ,rx serie.
=$ffab			kuntlk         =    untlk          ;   , iec-cmc stop talk
=$ffae			kunlsn         =    unlsn          ;   , iec-cmd stop lsn
=$ffb1			klisten        =    listen         ;a  , iec-cmd dev ecout
=$ffb4			ktalk          =    talk           ;a  , iec-cmd dev parle
=$ffb7			kreadst        =    readst         ;a  , lecture i/o stats
=$ffba			ksetlfs        =    setlfs         ;ayx, init fich logi.
=$ffbd			ksetnam        =    setnam         ;ayx, init num.nom.fich
=$ffc0			kopen          =    open           ;axy, ouvre fich-nom
=$ffc3			kclose         =    close          ;a  , ferme fichier #a.
=$ffc6			kchkin         =    chkin          ;  x,open canal in.
=$ffc9			kchkout        =    chkout         ;  x,open canal out
=$ffcc			kclrchn        =    clrchn         ;   , ferme canaux i/o.
=$ffcf			kchrin         =    chrin          ;a  ,recup. un car.
=$ffd2			kchrout        =    chrout         ;a  ,sort un car.
=$ffd5			kload          =    load           ;ayx, dev->ram
=$ffd8			ksave          =    save           ;   , sauve mem->dev
=$ffdb			ksettim        =    settim         ;axy, init sysclock
=$ffde			krdtim         =    rdtim          ;axy, lecture sysclock
=$ffe1			kstop          =    stop           ;a  , ret. stopkey stat
=$ffe4			kgetin         =    getin          ;a  , recup. car. #dev.
=$ffe7			kclall         =    clall          ;   , ferme fichiers.
=$ffea			kudtim         =    udtim          ;   , maj sysclock
=$ffed			kscreen        =    screen         ; yx, get format ecran
=$fff0			kplot          =    plot           ; yx, (c) get csr pos.
=$fff3			kiobase        =    iobase         ; yx, def. i/o mem page
=$e39a			k_echostartup  =    $e39a
=$e716			k_putch        =    $e716; 52) Print a character.           ;a--;---; a= char
=$e7a0			k_cls          =    $e7a0
=$e87c			k_cursordown   =    $e87c
=$e8ea			k_scrollup     =    $e8ea
=$e94e			k_home         =    $e94e
=$e965			k_insertline   =    $e965
=$e9c8			k_screlldown   =    $e9c8
=$ed0c			k_devsndlstn   =    $ed0c; 55) Send 'LISTEN'>IEEE/Serial.   ;a--;---; a=dev #
=$ee13			k_ieeein       =    $ee13; 60) Input from IEEE/Serial.      ;---;a--; a=Data byte
=$eef6			k_devsndutalk  =    $eef6; 58) Send 'UNTALK'>IEEE/Serial.   ;---;---;
=$ef04			k_devsndulstn  =    $ef04; 59) Send 'UNLISTEN'>IEEE/Serial. ;---;---;
=$f12f			k_putsysmsg    =    $f12f; 53) Print system message.        ;--y;---; y=msg offset
=$f291			k_cloself      =    $f291; 61) Close logical file .         ;a--;---; a=file #
=$f49e			k_loadsub      =    $f49e; 63) LOAD subroutine.             ;axy;---; a=# start=yyxx
=$f5af			k_prnsrch      =    $f5af; 64) Print SEARCHING if imm mode. ;---;---;
=$f5b3			k_echosearch   =    $f5b3; 64b) Skipping test part of 64.   ;---;---;
=$f5c1			k_prnfnam      =    $f5c1; 65) Print filename.              ;---;---;
=$f6ed			k_stop         =    $f6ed; 62) Check for STOP key.          ;---;---; z=1 pressed
=$f7ea			k_gettaphdblk  =    $f7ea; 66) Find a tape hdr blk.         ;a--;---; a=len
=$f7ea			k_fndtaphdblk  =    $f7ea; 67) Find any tape hdr blk.       ;---;---;
=$f817			k_waittapplay  =    $f817; 68) Press PLAY... (wait)         ;---;---;
=$f841			k_rdtape2buff  =    $f841; 69) Read tape to buffer.         ;---;---;
=$f847			k_readtape     =    $f847; 70) Read tape.                   ;---;---;
=$f864			k_wrbuff2tape  =    $f864; 71) write buffer to tape.        ;---;---;
=$f869			k_wrtape       =    $f869; 72) write tape.                  ;a--;---; a=ldr len
=$fb8e			k_resettapeio  =    $fb8e; 73) Reset tape I/O.              ;---;---;
=$fcbd			k_setintvect   =    $fcbd; 74) set interupt vector.         ;---;---;
=$fce2			k_coldreset    =    $fce2; 75) Power on reset.              ;---;---;
=$fce2			k_coldstart    =    $fce2; 75) Power on reset.              ;---;---;
=$fce2			k_coldboot     =    $fce2; 75) Power on reset.              ;---;---;
=$fe66			k_warmreset    =    $fe66;     Warm resetstart
=$fe66			k_warmboot     =    $fe66;     Warm resetstart
=$fe66			k_warmstart    =    $fe66;     Warm resetstart
=$ff93			k_devsndaddr2  =    $ff93; 56) Send second address.         ;a--;---; a=SAor#$60
=$5f			arrowleft      =    $5f
=$06			ctrl_al        =    $06
=$5f			escape         =    $5f
=$06			ctrl_escape    =    $06
=$a9			pound          =    $a9
=$13			home           =    $13
=$93			clear          =    $93
=$5e			uparrow        =    $5e
=$de			pisign         =    $de
=$03			runstop        =    $03
=$11			cursd          =    $11
=$91			cursu          =    $91
=$1d			cursr          =    $1d
=$9d			cursl          =    $9d
=$85			key_f1         =    $85
=$86			key_f3         =    $86
=$87			key_f5         =    $87
=$88			key_f7         =    $88
=$89			key_f2         =    $89
=$8a			key_f4         =    $8a
=$8b			key_f6         =    $8b
=$8c			key_f8         =    $8c
=$0d			enter          =    $0d
=$8d			comd_enter     =    $8d
=$41			key_a          =    $41
=$42			key_b          =    $42
=$43			key_c          =    $43
=$44			key_d          =    $44
=$45			key_e          =    $45
=$46			key_f          =    $46
=$47			key_g          =    $47
=$48			key_h          =    $48
=$49			key_i          =    $49
=$4a			key_j          =    $4a
=$4b			key_k          =    $4b
=$4c			key_l          =    $4c
=$4d			key_m          =    $4d
=$4e			key_n          =    $4e
=$4f			key_o          =    $4f
=$50			key_p          =    $50
=$51			key_q          =    $51
=$52			key_r          =    $52
=$53			key_s          =    $53
=$54			key_t          =    $54
=$55			key_u          =    $55
=$56			key_v          =    $56
=$57			key_w          =    $57
=$58			key_x          =    $58
=$59			key_y          =    $59
=$5a			key_z          =    $5a
=$c1			shift_a        =    $c1
=$c2			shift_b        =    $c2
=$c3			shift_c        =    $c3
=$c4			shift_d        =    $c4
=$c5			shift_e        =    $c5
=$c6			shift_f        =    $c6
=$c7			shift_g        =    $c7
=$c8			shift_h        =    $c8
=$c9			shift_i        =    $c9
=$ca			shift_j        =    $ca
=$cb			shift_k        =    $cb
=$cc			shift_l        =    $cc
=$cd			shift_m        =    $cd
=$ce			shift_n        =    $ce
=$cf			shift_o        =    $cf
=$d0			shift_p        =    $d0
=$d1			shift_q        =    $d1
=$d2			shift_r        =    $d2
=$d3			shift_s        =    $d3
=$d4			shift_t        =    $d4
=$d5			shift_u        =    $d5
=$d6			shift_v        =    $d6
=$d7			shift_w        =    $d7
=$d8			shift_x        =    $d8
=$d9			shift_y        =    $d9
=$da			shift_z        =    $da
=$01			ctrl_a         =    $01
=$02			ctrl_b         =    $02
=$03			ctrl_c         =    $03
=$04			ctrl_d         =    $04
=$05			ctrl_e         =    $05
=$06			ctrl_f         =    $06
=$07			ctrl_g         =    $07
=$08			ctrl_h         =    $08
=$09			ctrl_i         =    $09
=$0a			ctrl_j         =    $0a
=$0b			ctrl_k         =    $0b
=$0c			ctrl_l         =    $0c
=$0d			ctrl_m         =    $0d
=$0d			key_enter      =    $0d
=$0e			ctrl_n         =    $0e
=$0f			ctrl_o         =    $0f
=$10			ctrl_p         =    $10
=$11			ctrl_q         =    $11
=$12			ctrl_r         =    $12
=$13			ctrl_s         =    $13
=$14			ctrl_t         =    $14
=$15			ctrl_u         =    $15
=$16			ctrl_v         =    $16
=$17			ctrl_w         =    $17
=$18			ctrl_x         =    $18
=$19			ctrl_y         =    $19
=$1a			ctrl_z         =    $1a
=$b0			comd_a         =    $b0
=$bf			comd_b         =    $bf
=$bc			comd_c         =    $bc
=$ac			comd_d         =    $ac
=$b1			comd_e         =    $b1
=$bb			comd_f         =    $bb
=$a5			comd_g         =    $a5
=$b4			comd_h         =    $b4
=$a2			comd_i         =    $a2
=$b5			comd_j         =    $b5
=$a1			comd_k         =    $a1
=$b6			comd_l         =    $b6
=$a7			comd_m         =    $a7
=$aa			comd_n         =    $aa
=$b9			comd_o         =    $b9
=$af			comd_p         =    $af
=$ab			comd_q         =    $ab
=$b2			comd_r         =    $b2
=$ae			comd_s         =    $ae
=$a3			comd_t         =    $a3
=$b8			comd_u         =    $b8
=$be			comd_v         =    $be
=$b3			comd_w         =    $b3
=$bd			comd_x         =    $bd
=$b7			comd_y         =    $b7
=$ad			comd_z         =    $ad
=0			kerr00         =    0    ; routine ended by the stop key.
=1			kerr01         =    1    ; too many files open.
=2			kerr02         =    2    ; file already open.
=3			kerr03         =    3    ; file not open.
=4			kerr04         =    4    ; file not found.
=5			kerr05         =    5    ; device not present.
=6			kerr06         =    6    ; file is not an input file.
=7			kerr07         =    7    ; file is not an output file.
=8			kerr08         =    8    ; file name is missing.
=9			kerr09         =    9    ; illegal device number.
=240			kerrf0         =    240  ; top-of-memory change rs-232 buffer allocation.
.caad	4c 54 08	libtart        jmp  main           ; Programme principale doit s'appeler "main"

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/map-c64-basic2.asm

=144			b_black        =    144  ;0,  ctrl-1
=5			b_white        =    5    ;1,  ctrl-2
=28			b_red          =    28   ;2,  ctrl-3
=159			b_cyan         =    159  ;3,  ctrl-4
=156			b_purple       =    156  ;4,  ctrl-5
=30			b_green        =    30   ;5,  ctrl-6
=31			b_blue         =    31   ;6,  ctrl-7
=158			b_yellow       =    158  ;7,  ctrl-8
=129			b_orange       =    129  ;8,  C=-1
=149			b_brown        =    149  ;9,  C=-2
=150			b_ltred        =    150  ;10, C=-3
=155			b_gray3        =    155  ;11, C=-4
=155			b_grey3        =    155  ;11, C=-4
=152			b_gray2        =    152  ;12, C=-5
=152			b_grey2        =    152  ;13, C=-5
=153			b_ltgreen      =    153  ;13, C=-6
=154			b_ltblue       =    154  ;14, C=-7
=151			b_gray1        =    151  ;15, C=-8
=151			b_grey1        =    151  ;15, C=-8
=18			b_rvs_on       =    18   ;    ctrl-9
=146			b_rvs_off      =    146  ;    ctrl-0
=14			b_lowercase    =    14
=142			b_uppercase    =    142
=145			b_crsr_up      =    145
=17			b_crsr_down    =    17
=157			b_crsr_left    =    157
=29			b_crsr_right   =    29
=19			b_home         =    19
=147			b_clr_home     =    147
=20			b_insert       =    20
=141			b_shft_ret     =    141
=148			b_delete       =    148
=133			b_f1           =    133
=137			b_f2           =    137
=134			b_f3           =    134
=138			b_f4           =    138
=135			b_f5           =    135
=139			b_f6           =    139
=136			b_f7           =    136
=140			b_f8           =    140
=8			b_dis_cmd      =    8
=9			b_ena_cmd      =    9
=172			b_ul           =    172
=187			b_ur           =    187
=188			b_ll           =    188
=190			b_lr           =    190
=182			b_vl           =    182
=181			b_vr           =    181
=184			b_bo           =    184
=185			b_to           =    185
=$00			b_eot          =    $00
=$0200			b_inpbuff      =    $0200
=$0d			b_crlf         =    $0d
=$20			b_space        =    $20
=$61			b_fac1         =    $61
=$69			b_fac2         =    $69
=$a3bb			b_opentxtspc   = $a3bb ; Open space in BASIC text.   ;a-y;---; Array top $yyaa
=$a408			b_chkavailmem  = $a408 ; Check available Memory. *1  ;a-y;---; Array top $yyaa
=$a435			b_outofmem     = $a435 ; ?Out of memory.             ;---;---;
=$a437			b_errormesg    = $a437 ; Send BASIC error message.   ;a--;---; a = errno
=$a474			b_warmstart    = $a474 ; Basic warm start.           ;---;---;
=$a48a			b_chrgetentry  = $a48a ; Main CHRGET entry.          ;---;---;
=$a49c			b_newline      = $a49c ; Crunch tokens, insert line. ;-x-;---; x = buff len
=$a52a			b_clrready     = $a52a ; Fix chaining CLR and READY. ;---;---;
=$a533			b_fixchaining  = $a533 ; Fix chaining.               ;---;---;
=$a560			b_kbgetline    = $a560 ; Recieve line from keyboard.
=$a579			b_crunchtkns   = $a579 ; Crunch token. *7            ;-x-;---: x = buff len
=$a613			b_findline     = $a613 ; Find line in BASIC.         ;ax-;---; strBAS = $xxaa
=$a642			b_new          = $a642 ; Do NEW                      ;---;---;
=$a659			b_resetclr     = $a659 ; Reset BASIC and do CLR      ;---;---;
=$a65e			b_clr          = $a65e ; Do CLR                      ;---;---;
=$a68e			b_rstchrget    = $a68e ; Rst CHRGET to BASIC start   ;---;a--; strBAS hi
=$a857			b_continue     = $a857 ; Do CONTINUE.                ;a-y;---; curline $yyaa
=$a96b			b_getint       = $a96b ; Get int from BASIX text.    ;---;---;
=$aad3			b_sndcr        = $aad3 ; Send RETURN, LF in scr mode.;---;a--; a = LF
=$aad7			b_sndcrlf      = $aad7 ; Send RETURN, LINEFEED.      ;---;a--; a = LF
=$ab1e			b_outstr_ay    = $ab1e ; Print string from $yyaa.    ;a-y;---; sptr = $yyaa
=$ab1e			b_puts         = b_outstr_ay
=$ab24			b_outstrprep   = $ab24 ; Print precomputated string. ;a--;---; a = strlen
=$ab45			b_printqm      = $ab45 ; Print '?'.                  ;---;---;
=$ab47			b_sendchar     = $ab47 ; Send char in a to device.   ;a--;a--; a = char
=$abf9			b_intobuff     = $abf9 ; Input characters from std in anf write to buff. at $200.
=$ad8a			b_frmnum       = $ad8a ; Evaluate numeric expression and/or check for data type mismatch
=$ad9e			b_evalexpr     = $ad9e ; Evaluate expression.
=$aefd			b_chk4comma    = $aefd ; Check for coma.             ;---;a--; a = char
=$aefa			b_chk4lpar     = $aefa ; check for '('.              ;---;a--; a = char
=$aef7			b_chk4rpar     = $aef7 ; check for ')'.              ;---;a--; a = char
=$af08			b_syntaxerr    = $af08 ; send 'SYNTAX ERROR'.        ;---;---;
=$afe6			b_fort         = $afe6 ; FAC1 = FAC1 or FAC2.
=$afe9			b_fandt        = $afe9 ; FAC1 = FAC1 and FAC2.
=$b0e7			b_fndfloatvar  = $b0e7 ; find float var by name.     ;---;a-y; addr = $yyaa
=$b185			b_bumpvaraddr  = $b185 ; Bumb var addr by 2. *31     ;---;a-y; addr = $yyaa
=$b1aa			b_ftoint       = $b1aa ; FAC1 to word in $aayy       ;---;a-y; imt = $aayy
=$b1bf			b_float2int    = $b1bf ; FAC1 to int in $64(lsb),$65(msb).
=$b1d2			b_num2int      = $b1d2 ; Converts float num expr to int in $64(lsb),$65(msb).
=$b248			b_fcerr        = $b248 ; Print ILLEGAL QUANTITY error message.
=$b391			b_int2float    = $b391 ; Int to float in Acc#1.      ;---;---;
=$b3a2			b_ytofac1      = $b3a2 ; Convert int(y) to FAC1.     ;--y;---;
=$b79e			b_getacc1lsb   = $b79e ; Get Acc#1 LSB in x.         ;---;-x-; x = Acc#1 LSB
=$b7a1			b_fac1tox      = $b7a1 ; Conv FAC1 to byte in x.     ;---;-x-; x = byte
=$b7b5			b_str2float    = $b7b5 ; Evaluate str to float (VAL) ;---;---;
=$b7b9			b_strxy2float  = $b7b9 ; Eval. float from str in xy. ;---;-xy; strptr = $yyxx
=$b7e9			b_evfint2x     = $b7e9 ; Conv FAC1 to byte in x.     ;---;-x-; x = byte
=$b7eb			b_getpokeprms  = $b7eb ; Get 2 params for POKE, WAIT.;---;-x-; x = Param2
=$b7f7			b_getadr       = $b7f7 ; Convert Floating point number to an Unsighed TwoByte Integer.
=$b849			b_faddh        = $b849 ; FAC1 = FAC1 + 0.5
=$b850			b_fsub         = $b850 ; FAC1 = FVAR - FAC1.         ;a-y;---; ptr = $yyaa
=$b853			b_fsubt        = $b853 ; FAC1 = FAC2 - FAC1.         ;---;---;
=$b867			b_fadd         = $b867 ; FAC1 = FVAR + FAC1.         ;a-y;---; ptr = $yyaa
=$b867			b_memfloatadd  = $b867 ; Add from memory.            ;a-y;---; ptr = $yyaa
=$b86a			b_faddt        = $b86a ; FAC1 = FAC2 + FCA1
=$b86a			b_f2addf1      = $b86a ; FAC1 = FAC2 + FCA1
=$b947			b_fcomp2       = $b947 ; FAC1 = INV(FAC1) + 1
=$ba28			b_fmulv        = $ba28 ; FCA1 = FAC1 * FVAR.         ;a-y;---; ptr = $yyaa
=$ba28			b_memfloatmul  = $ba28 ; Multiply from memory.       ;a-y;---; ptr = $yyaa
=$ba2b			b_fmult        = $ba2b ; FAC1 = FAC1 * FAC2
=$ba8c			b_conupk       = $ba8c ; Copy FVAR to FAC2.          ;a-y;---; ptr = $yyaa
=$bae2			b_mul10        = $bae2 ; FAC1 = FAC1 * 10.
=$bae2			b_acc1mul10    = $bae2 ; Multiply Acc#1 by 10.       ;---;---; ptr = $yyaa
=$bafe			B_fdiv10       = $bafe ; FAC1 = FAC1 / 10.
=$bb0f			b_fdiv         = $bb0f ;
=$bb0f			b_vdivf        = $bb0f ; FAC1 = FVAR / FAC1.         ;a-y;---; ptr = $yyaa
=$bb12			b_fdivt        = $bb12 ; FAC1 = FAC2 / FAC1.
=$bba2			b_movfm        = $bba2 ; Copy FVAR to FAC1.          ;a-y;---; ptr = $yyaa
=$bba2			b_memvar2acc1  = $bba2 ; Unpack mem var to Acc#1.    ;a-y;---; ptr = $yyaa
=$bbc7			b_cpfac1tow2   = $bbc7 ; Copy FAC1 to WORK#2 ($5c-$60)
=$bbca			b_cpfac1tow1   = $bbca ; Copy FAC1 to WORK#1 ($57-$5b)
=$bbd0			b_cpfac1to49   = $bbd0 ; Copy FAC1 to FORPNT ($49-$4a)
=$bbd4			b_fac1toaddr   = $bbd4 ; Copy FAC1 to memory.        ;-xy;---; ptr = $yyxx
=$bbd7			b_cpfac1toxy   = $bbd7 ; Copy Acc#1 to mem location. ;-xy;---; ptr = $yyxx
=$bbfc			b_movfa        = $bbfc ;
=$bbfc			b_acc2toacc1   = $bbfc ; Copy Acc#2 to Acc#1.        ;---;---;
=$bc2b			b_fac1sign     = $bc2b ; Check sign of FAC1
=$bc39			b_sgn          = $bc39 ; FAC1 = SIGN(FAC1)
=$bc3c			b_atofac1      = $bc3c ; Convert int a to FAC1       ;a--;---; a = int
=$bc44			b_int2fac1     = $bc44 ; $62(lsb),$63(msb) int to FAC1
=$bc58			b_abs          = $bc58 ; FAC1 = ABS(FAC1)
=$bc5b			b_fcomp        = $bc5b ; FAC1 = FAC1 comp(FVAR).     ;a-y;---; ptr = $yyaa
=$bc0c			b_movaf        = $bc0c ;
=$bc0c			b_rndac1ac2    = $bc0c ; Move rnd Acc#1 to Acc#2.    ;---;---;
=$bc0f			b_urndac1ac2   = $bc0f ; Move unrnd Acc#1 to Acc#2.  ;---;---;
=$bc1b			b_round        = $bc1b ;
=$bc1b			b_rndac1       = $bc1b ; Round Acc#1.                ;---;---;
=$bc9b			b_qint         = $bc9b ; Converts FAC1 to int in FAC1.
=$bccc			b_int          = $bccc ; FAC1 = INT(FAC1)
=$bcf3			b_fin          = $bcf3 ; Conv. ascii dec num to FAC1,
=$bd7e			b_addf1acc     = $bd7e ; Add Acc to FAC1 (a=0-9)     ;a--;---;
=$bdcd			b_linptr       = $bdcd ; Print fix point value.      ;ax-;---; Value = $xxaa
=$bdcd			b_putint       = $bdcd ; Print fix point value.      ;ax-;---; Value = $xxaa
=$bdd7			b_putfloat     = $bdd7 ; Print Acc#1 float.          ;---;---;
=$bddd			b_fout         = $bddd ;
=$bddd			b_num2str      = $bddd ; Cnv num to str at $0100. *48;a-y;---; a=#$00, y=#$01
=$bf71			b_sqr          = $bf71 ; FAC1 = SQRT(FAC1).
=$bf7b			b_fpwrt        = $bf7b ; FAC1 = FAC1 ^ FAC2.
=$e059			b_poly2        = $e059 ; Ploynomial evaluation
=$e3bf			b_initcgt      = $e3bf ; Initialize all Basic zero page fixed value lication.
=$bdcd			b_axout        = $bdcd ; Print fix point value.      ;ax-;---; Value = $xxaa
=$e3bf			b_intcgt       = $e3bf ; Initialize all Basic zero page fixed value lication.
=$bcf3			b_ascflt       = $bcf3 ; Conv. ascii dec num to FAC1,
=$abf9			b_prompt       = $abf9 ; Input characters from std in anf write to buff. at $200.
=$0073			b_chrget       = $0073
=$0079			b_chrgot       = $0079
=$bddd			b_facasc       = $bddd ; Cnv num to str at $0100. *48;a-y;---; a=#$00, y=#$01
=$bba2			b_fvtf1        = $bba2 ; Copy FVAR to FAC1.          ;a-y;---; ptr = $yyaa
=$ab24			b_strout       = $ab24 ; Print precomputated string. ;a--;---; a = strlen
=$bbca			b_f1t57        = $bbca ; Copy FAC1 to WORK#1 ($57-$5b)
=$ba28			b_f1xfv        = $ba28 ; Multiply from memory.       ;a-y;---; ptr = $yyaa
=$bbd4			b_f1tmem       = $bbd4 ; Copy FAC1 to memory.        ;-xy;---; ptr = $yyxx
=$bae2			b_f1x10        = $bae2 ; Multiply Acc#1 by 10.       ;---;---; ptr = $yyaa
=$bafe			b_f1d10        = $bafe ; FAC1 = FAC1 / 10.
=$bc2b			b_sgnf1        = $bc2b ; Check sign of FAC1
=$bc0c			b_f1tf2        = $bc0c ; Move rnd Acc#1 to Acc#2.    ;---;---;
=$ba2b			b_f1xf2        = $ba2b ; FAC1 = FAC1 * FAC2
=$bb0f			b_fvdf1        = $bb0f ; FAC1 = FVAR / FAC1.         ;a-y;---; ptr = $yyaa
=$ba8c			b_memtf2       = $ba8c ; Copy FVAR to FAC2.          ;a-y;---; ptr = $yyaa
=$bb12			b_f2df1        = $bb12 ; FAC1 = FAC2 / FAC1.
=$b867			b_f1pfv        = $b867 ; FAC1 = FAC1 + FVAR.         ;a-y;---; ptr = $yyaa
=$b853			b_f2sf1        = $b853 ; FAC1 = FAC2 - FAC1.         ;---;---;
=$b850			b_fvsf1        = $b850 ; FAC1 = FVAR - FAC1.         ;a-y;---; ptr = $yyaa
=$bd7e			b_f1pacc       = $bd7e ; Add Acc to FAC1 (a=0-9)     ;a--;---;
=$b86a			b_f1pf2        = $b86a ; FAC1 = FAC2 + FCA1
=$bf7b			b_expon        = $bf7b ; FAC1 = FAC1 ^ FAC2.
=$afe9			b_fpand        = $afe9 ; FAC1 = FAC1 and FAC2.
=$afe6			b_f1orf2       = $afe6 ; FAC1 = FAC1 or FAC2.
=$bf71			b_sqrtf1       = $bf71 ; FAC1 = SQRT(FAC1).
=$bccc			b_intf1        = $bccc ; FAC1 = INT(FAC1)
=$bbc7			b_f1t5c        = $bbc7 ; Copy FAC1 to WORK#2 ($5c-$60)
=$bc5b			b_f1cfv        = $bc5b ; FAC1 = FAC1 comp(FVAR).     ;a-y;---; ptr = $yyaa
=$bc5b			b_comp         = $bc5b ; FAC1 = FAC1 comp(FVAR).     ;a-y;---; ptr = $yyaa
=$b7a1			b_f1tx         = $b7a1 ; Conv FAC1 to byte in x.     ;---;-x-; x = byte
=$b1aa			b_fltay        = $b1aa ; FAC1 to word in $aayy       ;---;a-y; imt = $aayy
=$b3a2			b_ytfl1        = $b3a2 ; Convert int(y) to FAC1.     ;--y;---;
=$e059			b_poly         = $e059 ; Ploynomial evaluation

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/map-c64-vicii.asm

=$0400			viciiscn    =   $0400
=$0400			viciiscn0   =   $0400
=$04f0			viciiscn1   =   $04f0
=$05e0			viciiscn2   =   $05e0
=$06d0			viciiscn3   =   $06d0
=$d000			vic = $d000			; VicII C64 memorymap base address
=53248			vicsprt0x = vic+$00	; $d000, 53248 Sprt 0 Horizontal position (X)
=53249			vicsprt0y = vic+$01	; $d001, 53249 Sprt 0 Vertical position (Y)
=53250			vicsprt1x = vic+$02	; $d002, 53250 Sprt 1 Horizontal position (X)
=53251			vicsprt1y = vic+$03	; $d003, 53251 Sprt 1 Vertical position (Y)
=53252			vicsprt2x = vic+$04	; $d004, 53252 Sprt 2 Horizontal position (X)
=53253			vicsprt2y = vic+$05	; $d005, 53253 Sprt 2 Vertical position (Y)
=53254			vicsprt3x = vic+$06	; $d006, 53254 Sprt 3 Horizontal position (X)
=53255			vicsprt3y = vic+$07	; $d007, 53255 Sprt 3 Vertical position (Y)
=53256			vicsprt4x = vic+$08	; $d008, 53256 Sprt 4 Horizontal position (X)
=53257			vicsprt4y = vic+$09	; $d009, 53257 Sprt 4 Vertical position (Y)
=53258			vicsprt5x = vic+$0a	; $d00a, 53258 Sprt 5 Horizontal position (X)
=53259			vicsprt5y = vic+$0b	; $d00b, 53259 Sprt 5 Vertical position (Y)
=53260			vicsprt6x = vic+$0c	; $d00c, 53260 Sprt 6 Horizontal position (X)
=53261			vicsprt6y = vic+$0d	; $d00d, 53261 Sprt 6 Vertical position (Y)
=53262			vicsprt7x = vic+$0e	; $d00e, 53262 Sprt 7 Horizontal position (X)
=53263			vicsprt7y = vic+$0f	; $d00f, 53263 Sprt 7 Vertical position (Y)
=53264			vicspxmsb = vic+$10	; $D010, 53264
=53265			vicctrl0v  = vic+$11	; $d011, 53265
=53265			vicmiscfnc = vicctrl0v
=53266			vicraster = vic+$12	; $d012, 53266	     	|b7|b6|b5|b4|b3|b2|b1|b0|
=53267			viclpenhp = vic+$13	; $d013, 53267	     	|b7|b6|b5|b4|b3|b2|b1|b0|
=53268			viclpenvp = vic+$14	; $d014, 53268	     	|b7|b6|b5|b4|b3|b2|b1|b0|
=53269			vicsprctl = vic+$15	; $d015, 53269	     	|s7|s6|s5|s4|s3|s2|s1|s0|
=53270			vicctrl1h = vic+$16	; $d016, 53270
=53271			vicsprtexv = vic+$17	; $d017, 53271	     |s7|s6|s5|s4|s3|s2|s1|s0|
=53272			vicmemptr  = vic+$18	; $d018, 53272
=53273			vicirqreg  = vic+$19	; $d019, 53273
=53274			vicirqena  = vic+$1a	; $d01a, 53274
=53275			vicsprtprio = vic+$1b 	; $d01b, 53275		|s7|s6|s5|s4|s3|s2|s1|s0|
=53276			vicsprtmcol = vic+$1c 	; $d01c, 53276		|s7|s6|s5|s4|s3|s2|s1|s0|
=53277			vicsprtexh = vic+$1d 	; $d01d, 53277		|s7|s6|s5|s4|s3|s2|s1|s0|
=53278			vicsprscol = vic+$1e 	; $d01e, 53278		|s7|s6|s5|s4|s3|s2|s1|s0|
=53279			vicsprbakcol = vic+$1f ; $d01f, 53279		|s7|s6|s5|s4|s3|s2|s1|s0|
=53280			vicbordcol = vic+$20 	; $d020, 53280		|--|--|--|--|c3|c2|c1|c0|
=53281			vicbackcol  = vic+$21 	; $d021, 53281
=53281			vicback0col = vic+$21 	; $d021, 53281		|--|--|--|--|c3|c2|c1|c0|
=53281			vicbackcol0 = vic+$21 	; $d021, 53281		|--|--|--|--|c3|c2|c1|c0|
=53282			vicback1col = vic+$22 	; $d022, 53282		|--|--|--|--|c3|c2|c1|c0|
=53282			vicbackcol1 = vic+$22 	; $d022, 53282		|--|--|--|--|c3|c2|c1|c0|
=53283			vicback2col = vic+$23 	; $d023, 53283		|--|--|--|--|c3|c2|c1|c0|
=53283			vicbackcol2 = vic+$23 	; $d023, 53283		|--|--|--|--|c3|c2|c1|c0|
=53284			vicback3col = vic+$24 	; $d024, 53284		|--|--|--|--|c3|c2|c1|c0|
=53284			vicbackcol3 = vic+$24 	; $d024, 53284		|--|--|--|--|c3|c2|c1|c0|
=53285			vicsprtmcol0 = vic+$25 	; $d025, 53285		|--|--|--|--|c3|c2|c1|c0|
=53286			vicsprtmcol1 = vic+$26 	; $d026, 53286		|--|--|--|--|c3|c2|c1|c0|
=53287			vicsprt0col = vic+$27 	; $d027, 53287		|--|--|--|--|c3|c2|c1|c0|
=53288			vicsprt1col = vic+$28 	; $d028, 53288		|--|--|--|--|c3|c2|c1|c0|
=53289			vicsprt2col = vic+$29 	; $d029, 53289		|--|--|--|--|c3|c2|c1|c0|
=53290			vicsprt3col = vic+$2a 	; $d02a, 53290		|--|--|--|--|c3|c2|c1|c0|
=53291			vicsprt4col = vic+$2b 	; $d02b, 53291		|--|--|--|--|c3|c2|c1|c0|
=53292			vicsprt5col = vic+$2c 	; $d02c, 53292		|--|--|--|--|c3|c2|c1|c0|
=53293			vicsprt6col = vic+$2d 	; $d02d, 53293		|--|--|--|--|c3|c2|c1|c0|
=53294			vicsprt7col = vic+$2e 	; $d02e, 53294		|--|--|--|--|c3|c2|c1|c0|

;******  Return to file: libtest00.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/macros-64tass.asm


;******  Return to file: libtest00.asm


;******  End of listing
