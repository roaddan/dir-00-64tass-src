
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/C64/lib -i -L jbmon64.txt -o jbmon64.prg jbmon64.asm
; Sat Jan 31 20:24:11 2026

;Offset	;Hex		;Source

;******  Processing input file: jbmon64.asm

=$c1			tmp0    = $c1               ; used to return input, often holds end address
=$c3			tmp2    = $c3               ; usually holds start address
=$90			satus   = $90               ; kernal i/o status word
=$b7			fnlen   = $b7               ; length of current filename
=$b9			sadd    = $b9               ; current secondary address (official name sa)
=$ba			fa      = $ba               ; current device number
=$bb			fnadr   = $bb               ; pointer to current filename
=$c6			ndx     = $c6               ; number of characters in keyboard buffer
=$0277			keyd    = $0277             ; keyboard buffer
=$0316			bkvec   = $0316             ; brk instruction vector (official name cbinv)
>0100			acmd    .fill 1             ; addressing command
>0101			length  .fill 1             ; length of operand
>0102			mnemw   .fill 3             ; 3 letter mnemonic buffer
>0105			savx    .fill 1             ; 1 byte temp storage, often to save x register
>0106			opcode  .fill 1             ; current opcode for assembler/disassembler
>0107			upflg   .fill 1             ; flag: count up (bit 7 clear) or down (bit 7 set)
>0108			digcnt  .fill 1             ; digit count
>0109			indig   .fill 1             ; numeric value of single digit
>010a			numbit  .fill 1             ; numeric base of input
>010b			stash   .fill 2             ; 2-byte temp storage
>010d			u0aa0   .fill 10            ; work buffer
=$0117			u0aae   =*                  ; end of work buffer
>0117			stage   .fill 30            ; staging buffer for filename, search, etc.
=$0135			estage  =*                  ; end of staging buffer
>0200			inbuff  .fill 40            ; 40-character input buffer
=$0228			endin   =*                  ; end of input buffer
>0228			pch     .fill 1             ; program counter high byte
>0229			pcl     .fill 1             ; program counter low byte
>022a			sr      .fill 1             ; status register
>022b			acc     .fill 1             ; accumulator
>022c			xr      .fill 1             ; x register
>022d			yr      .fill 1             ; y register
>022e			sp      .fill 1             ; stack pointer
>022f			store   .fill 2             ; 2-byte temp storage
>0231			chrpnt  .fill 1             ; current position in input buffer
>0232			savy    .fill 1             ; temp storage, often to save y register
>0233			u9f     .fill 1             ; index into assembler work buffer
=$ff90			setmsg  = $ff90             ; set kernel message control flag
=$ff93			second  = $ff93             ; set secondary address after listen
=$ff96			tksa    = $ff96             ; send secondary address after talk
=$ffb1			listen  = $ffb1             ; command serial bus device to listen
=$ffb4			talk    = $ffb4             ; command serial bus device to talk
=$ffba			setlfs  = $ffba             ; set logical file parameters
=$ffbd			setnam  = $ffbd             ; set filename
=$ffa5			acptr   = $ffa5             ; input byte from serial bus
=$ffa8			ciout   = $ffa8             ; output byte to serial bus
=$ffab			untlk   = $ffab             ; command serial bus device to untalk
=$ffae			unlsn   = $ffae             ; command serial bus device to unlisten
=$ffc6			chkin   = $ffc6             ; define input channel
=$ffcc			clrchn  = $ffcc             ; restore default devices
=$ffcf			input   = $ffcf             ; input a character (official name chrin)
=$ffd2			chrout  = $ffd2             ; output a character
=$ffd5			load    = $ffd5             ; load from device
=$ffd8			save    = $ffd8             ; save to device
=$ffe1			stop    = $ffe1             ; check the stop key
=$ffe4			getin   = $ffe4             ; get a character
=$c000			org     = $c000;36000;$9519
.c000	20 40 c0	super   jsr setcolors
.c003	a0 33		        ldy #msg9-msgbas    ; display "      < < < < < supermon > > > > >"
.c005	20 b2 c9	        jsr sndmsg
.c008	a0 56		        ldy #msga-msgbas    ; display " by jim butterfield  (r.i.p. 1936-2007)"
.c00a	20 b2 c9	        jsr sndmsg
.c00d	20 0b c7	        jsr crlf
.c010	a0 20		        ldy #msg4-msgbas    ; display "..sys "
.c012	20 b2 c9	        jsr sndmsg
.c015	ad 5e cb	        lda supad           ; store entry point address in tmp0
.c018	85 c1		        sta tmp0
.c01a	ad 5f cb	        lda supad+1
.c01d	85 c2		        sta tmp0+1
.c01f	20 3c c8	        jsr cvtdec          ; convert address to decimal
.c022	a9 00		        lda #0
.c024	a2 06		        ldx #6
.c026	a0 03		        ldy #3
.c028	20 76 c8	        jsr nmprnt          ; print entry point address
.c02b	20 0b c7	        jsr crlf
.c02e	ad 5c cb	        lda linkad          ; set brk vector
.c031	8d 16 03	        sta bkvec
.c034	ad 5d cb	        lda linkad+1
.c037	8d 17 03	        sta bkvec+1
.c03a	a9 80		        lda #$80            ; disable kernel control messages
.c03c	20 90 ff	        jsr setmsg          ; and enable error messages
.c03f	00		        brk
.c040			setcolors
.c040	08		                php
.c041	48		                pha
.c042	a9 0c		                lda     #12  ;and #$0a #$0b
.c044	8d 20 d0	                sta     border
.c047	a9 0b		                lda     #11
.c049	8d 21 d0	                sta     screen
.c04c	a9 01		                lda     #$01
.c04e	8d 86 02	                sta     texte
.c051	a9 93		                lda     #147
.c053	20 d2 ff	                jsr     $ffd2
.c056	a9 13		                lda     #19
.c058	20 d2 ff	                jsr     $ffd2
.c05b	68		                pla
.c05c	28		                plp
.c05d	60		                rts
=53281			screen  =       53281
=53280			border  =       53280
=646			texte   =       646
.c05e	a2 05		break   ldx #$05            ; pull registers off the stack
.c060	68		bstack  pla                 ; order: y,x,a,sr,pcl,pch
.c061	9d 28 02	        sta pch,x           ; store in memory
.c064	ca		        dex
.c065	10 f9		        bpl bstack
.c067	d8		        cld                 ; disable bcd mode
.c068	ba		        tsx                 ; store stack pointer in memory
.c069	8e 2e 02	        stx sp
.c06c	58		        cli                 ; enable interupts
.c06d	a0 00		dsplyr  ldy #msg2-msgbas    ; display headers
.c06f	20 9f c9	        jsr sndclr
.c072	a9 3b		        lda #$3b            ; prefix registers with "; " to allow editing
.c074	20 d2 ff	        jsr chrout
.c077	a9 20		        lda #$20
.c079	20 d2 ff	        jsr chrout
.c07c	ad 28 02	        lda pch             ; print 2-byte program counter
.c07f	20 24 c7	        jsr wrtwo
.c082	a0 01		        ldy #1              ; start 1 byte after pc high byte
.c084	b9 28 02	disj    lda pch,y           ; loop through rest of the registers
.c087	20 00 c7	        jsr wrbyte          ; print 1-byte register value
.c08a	c8		        iny
.c08b	c0 07		        cpy #7              ; there are a total of 5 registers to print
.c08d	90 f5		        bcc disj
.c08f	20 0b c7	strt    jsr crlf            ; new line
.c092	a2 00		        ldx #0              ; point at start of input buffer
.c094	8e 31 02	        stx chrpnt
.c097	20 cf ff	smove   jsr input           ; chrin kernal call to input a character
.c09a	9d 00 02	        sta inbuff,x        ; store in input buffer
.c09d	e8		        inx
.c09e	e0 28		        cpx #endin-inbuff   ; error if buffer is full
.c0a0	b0 1c		        bcs error
.c0a2	c9 0d		        cmp #$0d            ; keep reading until cr
.c0a4	d0 f1		        bne smove
.c0a6	a9 00		        lda #0              ; null-terminate input buffer
.c0a8	9d ff 01	        sta inbuff-1,x      ; (replacing the cr)
.c0ab	20 4c c7	st1     jsr getchr          ; get a character from the buffer
.c0ae	f0 df		        beq strt            ; start over if buffer is empty
.c0b0	c9 20		        cmp #$20            ; skip leading spaces
.c0b2	f0 f7		        beq st1
.c0b4	a2 16		s0      ldx #keytop-keyw    ; loop through valid command characters
.c0b6	dd 20 cb	s1      cmp keyw,x          ; see if input character matches
.c0b9	f0 0b		        beq s2              ; command matched, dispatch it
.c0bb	ca		        dex                 ; no match, check next command
.c0bc	10 f8		        bpl s1              ; keep trying until we've checked them all
.c0be	a0 1e		error   ldy #msg3-msgbas    ; display "?" to indicate error and go to new line
.c0c0	20 b2 c9	        jsr sndmsg
.c0c3	4c 8f c0	        jmp strt            ; back to main loop
.c0c6	e0 13		s2      cpx #$13            ; last 3 commands in table are load/save/validate
.c0c8	b0 12		        bcs lsv             ;   which are handled by the same subroutine
.c0ca	e0 0f		        cpx #$0f            ; next 4 commands are base conversions
.c0cc	b0 14		        bcs cnvlnk          ;   which are handled by the same subroutine
.c0ce	8a		        txa                 ; remaining commands dispatch through vector table
.c0cf	0a		        asl a               ; multiply index of command by 2
.c0d0	aa		        tax                 ;   since table contains 2-byte addresses
.c0d1	bd 37 cb	        lda kaddr+1,x       ; push address from vector table onto stack
.c0d4	48		        pha                 ;   so that the rts from getpar will jump there
.c0d5	bd 36 cb	        lda kaddr,x
.c0d8	48		        pha
.c0d9	4c 2d c6	        jmp getpar          ; get the first parameter for the command
.c0dc	8d 32 02	lsv     sta savy            ; handle load/save/validate
.c0df	4c af c2	        jmp ld
.c0e2	4c f1 c7	cnvlnk  jmp convrt          ; handle base conversion
.c0e5	6c 02 a0	exit    jmp ($a002)         ; jump to warm-start vector to reinitialize basic
.c0e8	b0 08		dsplym  bcs dspm11          ; start from previous end addr if no address given
.c0ea	20 66 c7	        jsr copy12          ; save start address in tmp2
.c0ed	20 2d c6	        jsr getpar          ; get end address in tmp0
.c0f0	90 06		        bcc dsmnew          ; did user specify one?
.c0f2	a9 0b		dspm11  lda #$0b            ; if not, show 12 lines by default
.c0f4	85 c1		        sta tmp0
.c0f6	d0 0e		        bne dspbyt          ; always true, but bne uses 1 byte less than jmp
.c0f8	20 6f c7	dsmnew  jsr sub12           ; end addr given, calc bytes between start and end
.c0fb	90 1e		        bcc merror          ; error if start is after end
.c0fd	a2 03		        ldx #3              ; divide by 8 (shift right 3 times)
.c0ff	46 c2		dspm01  lsr tmp0+1
.c101	66 c1		        ror tmp0
.c103	ca		        dex
.c104	d0 f9		        bne dspm01
.c106	20 e1 ff	dspbyt  jsr stop            ; check for stop key
.c109	f0 0d		        beq dspmx           ; exit early if pressed
.c10b	20 8b c1	        jsr dispmem         ; display 1 line containing 8 bytes
.c10e	a9 08		        lda #8              ; increase start address by 8 bytes
.c110	20 a5 c7	        jsr bumpad2
.c113	20 7d c7	        jsr suba1           ; decrement line counter
.c116	b0 ee		        bcs dspbyt          ; show another line until it's < 0
.c118	4c 8f c0	dspmx   jmp strt            ; back to main loop
.c11b	4c be c0	merror  jmp error           ; handle error
.c11e	20 bd c7	altr    jsr copy1p          ; store first parameter in pc
.c121	a0 00		        ldy #0              ; init counter
.c123	20 2d c6	altr1   jsr getpar          ; get value for next register
.c126	b0 0a		        bcs altrx           ; exit early if no more values given
.c128	a5 c1		        lda tmp0            ; store in memory, offset from sr
.c12a	99 2a 02	        sta sr,y            ; these locations will be transferred to the
.c12d	c8		        iny                 ;   actual registers before exiting the monitor
.c12e	c0 05		        cpy #$05            ; have we updated all 5 yet?
.c130	90 f1		        bcc altr1           ; if not, get next
.c132	4c 8f c0	altrx   jmp strt            ; back to main loop
.c135	b0 13		altm    bcs altmx           ; exit if no parameter provided
.c137	20 66 c7	        jsr copy12          ; copy parameter to start address
.c13a	a0 00		        ldy #0
.c13c	20 2d c6	altm1   jsr getpar          ; get value for next byte of memory
.c13f	b0 09		        bcs altmx           ; if none given, exit early
.c141	a5 c1		        lda tmp0            ; poke value into memory at start address + y
.c143	91 c3		        sta (tmp2),y
.c145	c8		        iny                 ; next byte
.c146	c0 08		        cpy #8              ; have we read 8 bytes yet?
.c148	90 f2		        bcc altm1           ; if not, read the next one
.c14a	a9 91		altmx   lda #$91            ; move cursor up
.c14c	20 d2 ff	        jsr chrout
.c14f	20 8b c1	        jsr dispmem         ; re-display line to make ascii match hex
.c152	4c 8f c0	        jmp strt            ; back to main loop
.c155	ae 2e 02	goto    ldx sp              ; load stack pointer from memory
.c158	9a		        txs                 ; save in sp register
.c159	20 bd c7	goto2   jsr copy1p          ; copy provided address to pc
.c15c	78		        sei                 ; disable interrupts
.c15d	ad 28 02	        lda pch             ; push pc high byte on stack
.c160	48		        pha
.c161	ad 29 02	        lda pcl             ; push pc low byte on stack
.c164	48		        pha
.c165	ad 2a 02	        lda sr              ; push status byte on stack
.c168	48		        pha
.c169	ad 2b 02	        lda acc             ; load accumulator from memory
.c16c	ae 2c 02	        ldx xr              ; load x from memory
.c16f	ac 2d 02	        ldy yr              ; load y from memory
.c172	40		        rti                 ; return from interrupt (pops pc and sr)
.c173	ae 2e 02	jsub    ldx sp              ; load stack pointer from memory
.c176	9a		        txs                 ; save value in sp register
.c177	20 59 c1	        jsr goto2           ; same as goto command
.c17a	8c 2d 02	        sty yr              ; save y to memory
.c17d	8e 2c 02	        stx xr              ; save x to memory
.c180	8d 2b 02	        sta acc             ; save accumulator to memory
.c183	08		        php                 ; push processor status on stack
.c184	68		        pla                 ; pull processor status into a
.c185	8d 2a 02	        sta sr              ; save processor status to memory
.c188	4c 6d c0	        jmp dsplyr          ; display registers
.c18b	20 0b c7	dispmem jsr crlf            ; new line
.c18e	a9 3e		        lda #">"            ; prefix > so memory can be edited in place
.c190	20 d2 ff	        jsr chrout
.c193	20 f6 c6	        jsr showad          ; show address of first byte on line
.c196	a0 00		        ldy #0
.c198	f0 03		        beq dmemgo          ; showad already printed a space after the address
.c19a	20 03 c7	dmemlp  jsr space           ; print space between bytes
.c19d	b1 c3		dmemgo  lda (tmp2),y        ; load byte from start address + y
.c19f	20 24 c7	        jsr wrtwo           ; output hex digits for byte
.c1a2	c8		        iny                 ; next byte
.c1a3	c0 08		        cpy #8              ; have we output 8 bytes yet?
.c1a5	90 f3		        bcc dmemlp          ; if not, output next byte
.c1a7	a0 26		        ldy #msg5-msgbas    ; if so, output : and turn on reverse video
.c1a9	20 b2 c9	        jsr sndmsg          ;   before displaying ascii representation
.c1ac	a0 00		        ldy #0              ; back to first byte in line
.c1ae	b1 c3		dchar   lda (tmp2),y        ; load byte at start address + y
.c1b0	aa		        tax                 ; stash in x
.c1b1	29 bf		        and #$bf            ; clear 6th bit
.c1b3	c9 22		        cmp #$22            ; is it a quote ("")?
.c1b5	f0 08		        beq ddot            ; if so, print . instead
.c1b7	8a		        txa                 ; if not, restore character
.c1b8	29 7f		        and #$7f            ; clear top bit
.c1ba	c9 20		        cmp #$20            ; is it a printable character (>= $20)?
.c1bc	8a		        txa                 ; restore character
.c1bd	b0 02		        bcs dchrok          ; if printable, output character
.c1bf	a9 2e		ddot    lda #$2e            ; if not, output '.' instaed
.c1c1	20 d2 ff	dchrok  jsr chrout
.c1c4	c8		        iny                 ; next byte
.c1c5	c0 08		        cpy #8              ; have we output 8 bytes yet?
.c1c7	90 e5		        bcc dchar           ; if not, output next byte
.c1c9	60		        rts
.c1ca	a9 00		compar  lda #0              ; bit 7 clear signals compare
>c1cc	2c		        .byte $2c           ; absolute bit opcode consumes next word (lda #$80)
.c1cd	a9 80		trans   lda #$80            ; bit 7 set signals transfer
.c1cf	8d 32 02	        sta savy            ; save compare/transfer flag in savy
.c1d2	a9 00		        lda #0              ; assume we're counting up (bit 7 clear)
.c1d4	8d 07 01	        sta upflg           ; save direction flag
.c1d7	20 ca c7	        jsr getdif          ; get two addresses and calculate difference
.c1da	b0 05		        bcs terror          ; carry set indicates error
.c1dc	20 2d c6	        jsr getpar          ; get destination address in tmp0
.c1df	90 03		        bcc tokay           ; carry set indicates error
.c1e1	4c be c0	terror  jmp error           ; handle error
.c1e4	2c 32 02	tokay   bit savy            ; transfer or compare?
.c1e7	10 27		        bpl compar1         ; high bit clear indicates compare
.c1e9	a5 c3		        lda tmp2            ; if it's a transfer, we must take steps
.c1eb	c5 c1		        cmp tmp0            ;   to avoid overwriting the source bytes before
.c1ed	a5 c4		        lda tmp2+1          ;   they have been transferred
.c1ef	e5 c2		        sbc tmp0+1          ; compare source (tmp2) to destination (tmp0)
.c1f1	b0 1d		        bcs compar1         ; and count up if source is before than desitnation
.c1f3	ad 2f 02	        lda store           ; otherwise, start at end and count down...
.c1f6	65 c1		        adc tmp0            ; add length (store) to desintation (tmp0)
.c1f8	85 c1		        sta tmp0            ; to calculate end of destination
.c1fa	ad 30 02	        lda store+1
.c1fd	65 c2		        adc tmp0+1
.c1ff	85 c2		        sta tmp0+1
.c201	a2 01		        ldx #1              ; change source pointer from beginning to end
.c203	bd 0b 01	tdown   lda stash,x         ; tmp2 = source end (stash)
.c206	95 c3		        sta tmp2,x
.c208	ca		        dex
.c209	10 f8		        bpl tdown
.c20b	a9 80		        lda #$80            ; high bit set in upflg means count down
.c20d	8d 07 01	        sta upflg
.c210	20 0b c7	compar1 jsr crlf            ; new line
.c213	a0 00		        ldy #0              ; no offset from pointer
.c215	20 e1 ff	tcloop  jsr stop            ; check for stop key
.c218	f0 31		        beq texit           ; exit if pressed
.c21a	b1 c3		        lda (tmp2),y        ; load byte from source
.c21c	2c 32 02	        bit savy            ; transfer or compare?
.c21f	10 02		        bpl compar2         ; skip store if comparing
.c221	91 c1		        sta (tmp0),y        ; otherwise, store in destination
.c223	d1 c1		compar2 cmp (tmp0),y        ; compare to destination
.c225	f0 03		        beq tmvad           ; don't show address if equal
.c227	20 f6 c6	        jsr showad          ; show address
.c22a	2c 07 01	tmvad   bit upflg           ; counting up or down?
.c22d	30 0b		        bmi tdecad          ; high bit set means we're counting down
.c22f	e6 c1		        inc tmp0            ; increment destination low byte
.c231	d0 10		        bne tincok
.c233	e6 c2		        inc tmp0+1          ; carry to high byte if necessary
.c235	d0 0c		        bne tincok
.c237	4c be c0	        jmp error           ; error if high byte overflowed
.c23a	20 7d c7	tdecad  jsr suba1           ; decrement destination (tmp0)
.c23d	20 af c7	        jsr sub21           ; decrement source (tmp2)
.c240	4c 46 c2	        jmp tmor
.c243	20 a3 c7	tincok  jsr adda2           ; increment source (tmp2)
.c246	20 91 c7	tmor    jsr sub13           ; decrement length
.c249	b0 ca		        bcs tcloop          ; loop until length is 0
.c24b	4c 8f c0	texit   jmp strt            ; back to main loop
.c24e	20 ca c7	hunt    jsr getdif          ; get start (tmp2) and end (tmp0) of haystack
.c251	b0 59		        bcs herror          ; carry indicates error
.c253	a0 00		        ldy #0
.c255	20 4c c7	        jsr getchr          ; get a single character
.c258	c9 27		        cmp #"'"            ; is it a single quote?
.c25a	d0 16		        bne nostrh          ; if not, input needle as hex bytes
.c25c	20 4c c7	        jsr getchr          ; if so, input needle as string
.c25f	c9 00		        cmp #0
.c261	f0 49		        beq herror          ; error if needle isn't at least one byte
.c263	99 17 01	hpar    sta stage,y         ; save char in staging area
.c266	c8		        iny
.c267	20 4c c7	        jsr getchr          ; get another char
.c26a	f0 18		        beq htgo            ; if it's null start searching
.c26c	c0 1e		        cpy #estage-stage   ; have we filled up the needle staging area?
.c26e	d0 f3		        bne hpar            ; if not, get another character
.c270	f0 12		        beq htgo            ; if so, start searching
.c272	20 2a c6	nostrh  jsr rdpar           ; read hex bytes if string not indicated
.c275	a5 c1		hlp     lda tmp0            ; save last read byte in staging area
.c277	99 17 01	        sta stage,y
.c27a	c8		        iny                 ; get another hex byte
.c27b	20 2d c6	        jsr getpar
.c27e	b0 04		        bcs htgo            ; if there is none, start searching
.c280	c0 1e		        cpy #estage-stage   ; have we filled up the needle staging area?
.c282	d0 f1		        bne hlp             ; if not, get another byte
.c284	8c 32 02	htgo    sty savy            ; save length of needle
.c287	20 0b c7	        jsr crlf            ; new line
.c28a	a0 00		hscan   ldy #0
.c28c	b1 c3		hlp3    lda (tmp2),y        ; get first byte in haystack
.c28e	d9 17 01	        cmp stage,y         ; compare it to first byte of needle
.c291	d0 09		        bne hnoft           ; if it doesn't match, we haven't found anything
.c293	c8		        iny                 ; if it does, check the next byte
.c294	cc 32 02	        cpy savy            ; have we reached the end of the needle?
.c297	d0 f3		        bne hlp3            ; if not, keep comparing bytes
.c299	20 f6 c6	        jsr showad          ; match found, show address
.c29c	20 e1 ff	hnoft   jsr stop            ; no match, check for stop key
.c29f	f0 08		        beq hexit           ; exit prematurely if pressed
.c2a1	20 a3 c7	        jsr adda2           ; increment haystack pointer
.c2a4	20 91 c7	        jsr sub13           ; decrement haystack length
.c2a7	b0 e1		        bcs hscan           ; still more haystack? keep searching
.c2a9	4c 8f c0	hexit   jmp strt            ; back to main loop
.c2ac	4c be c0	herror  jmp error           ; handle error
.c2af	a0 01		ld      ldy #1              ; default to reading from tape, device #1
.c2b1	84 ba		        sty fa
.c2b3	84 b9		        sty sadd            ; default to secondary address #1
.c2b5	88		        dey
.c2b6	84 b7		        sty fnlen           ; start with an empty filename
.c2b8	84 90		        sty satus           ; clear status
.c2ba	a9 01		        lda #>stage         ; set filename pointer to staging buffer
.c2bc	85 bc		        sta fnadr+1
.c2be	a9 17		        lda #<stage
.c2c0	85 bb		        sta fnadr
.c2c2	20 4c c7	l1      jsr getchr          ; get a character
.c2c5	f0 59		        beq lshort          ; no filename given, try load or verify from tape
.c2c7	c9 20		        cmp #$20            ; skip leading spaces
.c2c9	f0 f7		        beq l1
.c2cb	c9 22		        cmp #$22            ; error if filename doesn't start with a quote
.c2cd	d0 16		        bne lerror
.c2cf	ae 31 02	        ldx chrpnt          ; load current char pointer into index reg
.c2d2	bd 00 02	l3      lda inbuff,x        ; load current char from buffer to accumulator
.c2d5	f0 49		        beq lshort          ; no filename given, try load or verify from tape
.c2d7	e8		        inx                 ; next char
.c2d8	c9 22		        cmp #$22            ; is it a quote?
.c2da	f0 0c		        beq l8              ; if so, we've reached the end of the filename
.c2dc	91 bb		        sta (fnadr),y       ; if not, save character in filename buffer
.c2de	e6 b7		        inc fnlen           ; increment filename length
.c2e0	c8		        iny
.c2e1	c0 1e		        cpy #estage-stage   ; check whether buffer is full
.c2e3	90 ed		        bcc l3              ; if not, get another character
.c2e5	4c be c0	lerror  jmp error           ; if so, handle error
.c2e8	8e 31 02	l8      stx chrpnt          ; set character pointer to the current index
.c2eb	20 4c c7	        jsr getchr          ; eat separator between filename and device #
.c2ee	f0 30		        beq lshort          ; no separator, try to load or verify from tape
.c2f0	20 2d c6	        jsr getpar          ; get device number
.c2f3	b0 2b		        bcs lshort          ; no device # given, try load or verify from tape
.c2f5	a5 c1		        lda tmp0            ; set device number for kernal routines
.c2f7	85 ba		        sta fa
.c2f9	20 2d c6	        jsr getpar          ; get start address for load or save in tmp0
.c2fc	b0 22		        bcs lshort          ; no start address, try to load or verify
.c2fe	20 66 c7	        jsr copy12          ; transfer start address to tmp2
.c301	20 2d c6	        jsr getpar          ; get end address for save in tmp0
.c304	b0 3d		        bcs ldaddr          ; no end address, try to load to given start addr
.c306	20 0b c7	        jsr crlf            ; new line
.c309	a6 c1		        ldx tmp0            ; put low byte of end address in x
.c30b	a4 c2		        ldy tmp0+1          ; put high byte of end address in y
.c30d	ad 32 02	        lda savy            ; confirm that we're doing a save
.c310	c9 53		        cmp #"s"
.c312	d0 d1		        bne lerror          ; if not, error due to too many params
.c314	a9 00		        lda #0
.c316	85 b9		        sta sadd            ; set secondary address to 0
.c318	a9 c3		        lda #tmp2           ; put addr of zero-page pointer to data in a
.c31a	20 d8 ff	        jsr save            ; call kernal save routine
.c31d	4c 8f c0	lsvxit  jmp strt            ; back to mainloop
.c320	ad 32 02	lshort  lda savy            ; check which command we received
.c323	c9 56		        cmp #"v"
.c325	f0 06		        beq loadit          ; we're doing a verify so don't set a to 0
.c327	c9 4c		        cmp #"l"
.c329	d0 ba		        bne lerror          ; error due to not enough params for save
.c32b	a9 00		        lda #0              ; 0 in a signals load, anything else is verify
.c32d	20 d5 ff	loadit  jsr load            ; call kernal load routine
.c330	a5 90		        lda satus           ; get i/o status
.c332	29 10		        and #$10            ; check bit 5 for checksum error
.c334	f0 e7		        beq lsvxit          ; if no error go back to mainloop
.c336	ad 32 02	        lda savy            ; ?? not sure what these two lines are for...
.c339	f0 aa		        beq lerror          ; ?? savy will never be 0, so why check?
.c33b	a0 28		        ldy #msg6-msgbas    ; display "error" if checksum didn't match
.c33d	20 b2 c9	        jsr sndmsg
.c340	4c 8f c0	        jmp strt            ; back to mainloop
.c343	a6 c3		ldaddr  ldx tmp2            ; load address low byte in x
.c345	a4 c4		        ldy tmp2+1          ; load address high byte in y
.c347	a9 00		        lda #0              ; 0 in a signals load
.c349	85 b9		        sta sadd            ; secondary addr 0 means load to addr in x and y
.c34b	f0 d3		        beq lshort          ; execute load
.c34d	20 ca c7	fill    jsr getdif          ; start in tmp2, end in stash, length in store
.c350	b0 59		        bcs aerror          ; carry set indicates error
.c352	20 2d c6	        jsr getpar          ; get value to fill in tmp0
.c355	b0 54		        bcs aerror          ; carry set indicates error
.c357	20 4c c7	        jsr getchr          ; any more characters triggers an error
.c35a	d0 4f		        bne aerror
.c35c	a0 00		        ldy #0              ; no offset
.c35e	a5 c1		fillp   lda tmp0            ; load value to fill in accumulator
.c360	91 c3		        sta (tmp2),y        ; store fill value in current address
.c362	20 e1 ff	        jsr stop            ; check for stop key
.c365	f0 08		        beq fstart          ; if pressed, back to main loop
.c367	20 a3 c7	        jsr adda2           ; increment address
.c36a	20 91 c7	        jsr sub13           ; decrement length
.c36d	b0 ef		        bcs fillp           ; keep going until length reaches 0
.c36f	4c 8f c0	fstart  jmp strt            ; back to main loop
.c372	b0 37		assem   bcs aerror          ; error if no address given
.c374	20 66 c7	        jsr copy12          ; copy address to tmp2
.c377	a2 00		aget1   ldx #0
.c379	8e 0e 01	        stx u0aa0+1         ; clear byte that mnemonic gets shifted into
.c37c	8e 08 01	        stx digcnt          ; clear digit count
.c37f	20 4c c7	aget2   jsr getchr          ; get a char
.c382	d0 04		        bne almor           ; proceed if the character isn't null
.c384	e0 00		        cpx #0              ; it's null, have read a mnemonic yet?
.c386	f0 e7		        beq fstart          ; if not, silently go back to main loop
.c388	c9 20		almor   cmp #$20            ; skip leading spaces
.c38a	f0 eb		        beq aget1
.c38c	9d 02 01	        sta mnemw,x         ; put character in mnemonic buffer
.c38f	e8		        inx
.c390	e0 03		        cpx #3              ; have we read 3 characters yet?
.c392	d0 eb		        bne aget2           ; if not, get next character
.c394	ca		asqeez  dex                 ; move to previous char
.c395	30 17		        bmi aoprnd          ; if we're done with mnemonic, look for operand
.c397	bd 02 01	        lda mnemw,x         ; get current character
.c39a	38		        sec                 ; pack 3-letter mnemonic into 2 bytes (15 bits)
.c39b	e9 3f		        sbc #$3f            ; subtract $3f from ascii code so a-z = 2 to 27
.c39d	a0 05		        ldy #$05            ; letters now fit in 5 bits; shift them out
.c39f	4a		ashift  lsr a               ;   into the first two bytes of the inst buffer
.c3a0	6e 0e 01	        ror u0aa0+1         ; catch the low bit from accumulator in right byte
.c3a3	6e 0d 01	        ror u0aa0           ; catch the low bit from right byte in left byte
.c3a6	88		        dey                 ; count down bits
.c3a7	d0 f6		        bne ashift          ; keep looping until we reach zero
.c3a9	f0 e9		        beq asqeez          ; unconditional branch to handle next char
.c3ab	4c be c0	aerror  jmp error           ; handle error
.c3ae	a2 02		aoprnd  ldx #2              ; mnemonic is in first two bytes so start at third
.c3b0	ad 08 01	ascan   lda digcnt          ; did we find address digits last time?
.c3b3	d0 2d		        bne aform1          ; if so, look for mode chars
.c3b5	20 55 c6	        jsr rdval           ; otherwise, look for an address
.c3b8	f0 25		        beq aform0          ; we didn't find an address, look for characters
.c3ba	b0 ef		        bcs aerror          ; carry flag indicates error
.c3bc	a9 24		        lda #"$"
.c3be	9d 0d 01	        sta u0aa0,x         ; prefix addresses with $
.c3c1	e8		        inx                 ; next position in buffer
.c3c2	a0 04		        ldy #4              ; non-zero page addresses are 4 hex digits
.c3c4	ad 0a 01	        lda numbit          ; check numeric base in which address was given
.c3c7	c9 08		        cmp #8              ; for addresses given in octal or binary
.c3c9	90 05		        bcc aaddr           ;   use only the high byte to determine page
.c3cb	cc 08 01	        cpy digcnt          ; for decimal or hex, force non-zero page addressing
.c3ce	f0 06		        beq afill0          ;   if address was given with four digits or more
.c3d0	a5 c2		aaddr   lda tmp0+1          ; check whether high byte of address is zero
.c3d2	d0 02		        bne afill0          ; non-zero high byte means we're not in zero page
.c3d4	a0 02		        ldy #2              ; if it's in zero page, addr is 2 hex digits
.c3d6	a9 30		afill0  lda #$30            ; use 0 as placeholder for each hex digit in addr
.c3d8	9d 0d 01	afil0l  sta u0aa0,x         ; put placeholder in assembly buffer
.c3db	e8		        inx                 ; move to next byte in buffer
.c3dc	88		        dey                 ; decrement number of remaining digits
.c3dd	d0 f9		        bne afil0l          ; loop until all digits have been placed
.c3df	ce 31 02	aform0  dec chrpnt          ; non-numeric input; back 1 char to see what it was
.c3e2	20 4c c7	aform1  jsr getchr          ; get next character
.c3e5	f0 0e		        beq aescan          ; if there is none, we're finished scanning
.c3e7	c9 20		        cmp #$20            ; skip spaces
.c3e9	f0 c5		        beq ascan
.c3eb	9d 0d 01	        sta u0aa0,x         ; store character in assembly buffer
.c3ee	e8		        inx                 ; move to next byte in buffer
.c3ef	e0 0a		        cpx #u0aae-u0aa0    ; is instruction buffer full?
.c3f1	90 bd		        bcc ascan           ; if not, keep scanning
.c3f3	b0 b6		        bcs aerror          ; error if buffer is full
.c3f5	8e 2f 02	aescan  stx store           ; save number of bytes in assembly buffer
.c3f8	a2 00		        ldx #0              ; start at opcode $00 and check every one until
.c3fa	8e 06 01	        stx opcode          ;   we find one that matches our criteria
.c3fd	a2 00		atryop  ldx #0
.c3ff	8e 33 02	        stx u9f             ; reset index into work buffer
.c402	ad 06 01	        lda opcode
.c405	20 bc c5	        jsr instxx          ; look up instruction format for current opcode
.c408	ae 00 01	        ldx acmd            ; save addressing command for later
.c40b	8e 30 02	        stx store+1
.c40e	aa		        tax                 ; use current opcode as index
.c40f	bd dc ca	        lda mnemr,x         ; check right byte of compressed mnemonic
.c412	20 e3 c4	        jsr chekop
.c415	bd 9c ca	        lda mneml,x         ; check left byte of compressed mnemonic
.c418	20 e3 c4	        jsr chekop
.c41b	a2 06		        ldx #6              ; 6 possible characters to check against operand
.c41d	e0 03		tryit   cpx #3              ; are we on character 3?
.c41f	d0 14		        bne trymod          ; if not, check operand characters
.c421	ac 01 01	        ldy length          ; otherwise, check number of bytes in operand
.c424	f0 0f		        beq trymod          ; if zero, check operand characters
.c426	ad 00 01	tryad   lda acmd            ; otherwise, look for an address
.c429	c9 e8		        cmp #$e8            ; special case for relative addressing mode
.c42b	a9 30		        lda #$30            ; '0' is the digit placeholder we're looking for
.c42d	b0 1e		        bcs try4b           ; acmd >= $e8 indicates relative addressing
.c42f	20 e0 c4	        jsr chek2b          ; acmd < $e8 indicates normal addressing
.c432	88		        dey                 ; consume byte
.c433	d0 f1		        bne tryad           ; check for 2 more digits if not zero-page
.c435	0e 00 01	trymod  asl acmd            ; shift a bit out of the addressing command
.c438	90 0e		        bcc ub4df           ; if it's zero, skip checking current character
.c43a	bd 8f ca	        lda char1-1,x
.c43d	20 e3 c4	        jsr chekop          ; otherwise first character against operand
.c440	bd 95 ca	        lda char2-1,x       ; get second character to check
.c443	f0 03		        beq ub4df           ; if it's zero, skip checking it
.c445	20 e3 c4	        jsr chekop          ; otherwise check it against hte operand
.c448	ca		ub4df   dex                 ; move to next character
.c449	d0 d2		        bne tryit           ; repeat tests
.c44b	f0 06		        beq trybran
.c44d	20 e0 c4	try4b   jsr chek2b          ; check for 4 digit address placeholder
.c450	20 e0 c4	        jsr chek2b          ;   by checking for 2 digits twice
.c453	ad 2f 02	trybran lda store           ; get number of bytes in assembly buffer
.c456	cd 33 02	        cmp u9f             ; more bytes left to check?
.c459	f0 03		        beq abran           ; if not, we've found a match; build instruction
.c45b	4c f0 c4	        jmp bumpop          ; if so, this opcode doesn't match; try the next
.c45e	ac 01 01	abran   ldy length          ; get number of bytes in operand
.c461	f0 32		        beq a1byte          ; if none, just output the opcode
.c463	ad 30 02	        lda store+1         ; otherwise check the address format
.c466	c9 9d		        cmp #$9d            ; is it a relative branch?
.c468	d0 23		        bne objput          ; if not, skip relative branch calculation
.c46a	a5 c1		        lda tmp0            ; calculate the difference between the current
.c46c	e5 c3		        sbc tmp2            ;   address and the branch target (low byte)
.c46e	aa		        tax                 ; save it in x
.c46f	a5 c2		        lda tmp0+1          ; borrow from the high byte if necessary
.c471	e5 c4		        sbc tmp2+1
.c473	90 08		        bcc abback          ; if result is negative, we're branching back
.c475	d0 66		        bne serror          ; high bytes must be equal when branching forward
.c477	e0 82		        cpx #$82            ; difference between low bytes must be < 130
.c479	b0 62		        bcs serror          ; error if the address is too far away
.c47b	90 08		        bcc abranx
.c47d	a8		abback  tay                 ; when branching backward high byte of target must
.c47e	c8		        iny                 ;   be 1 less than high byte of current address
.c47f	d0 5c		        bne serror          ; if not, it's too far away
.c481	e0 82		        cpx #$82            ; difference between low bytes must be < 130
.c483	90 58		        bcc serror          ; if not, it's too far away
.c485	ca		abranx  dex                 ; adjust branch target relative to the
.c486	ca		        dex                 ;   instruction following this one
.c487	8a		        txa
.c488	ac 01 01	        ldy length          ; load length of operand
.c48b	d0 03		        bne objp2           ; don't use the absolute address
.c48d	b9 c0 00	objput  lda tmp0-1,y        ; get the operand
.c490	91 c3		objp2   sta (tmp2),y        ; store it after the opcode
.c492	88		        dey
.c493	d0 f8		        bne objput          ; copy the other byte of operand if there is one
.c495	ad 06 01	a1byte  lda opcode          ; put opcode into instruction
.c498	91 c3		        sta (tmp2),y
.c49a	20 0b c7	        jsr crlf            ; carriage return
.c49d	a9 91		        lda #$91            ; back up one line
.c49f	20 d2 ff	        jsr chrout
.c4a2	a0 2e		        ldy #msg7-msgbas    ; "a " prefix
.c4a4	20 9f c9	        jsr sndclr          ; clear line
.c4a7	20 3e c5	        jsr dislin          ; disassemble the instruction we just assembled
.c4aa	ee 01 01	        inc length          ; instruction length = operand length + 1 byte
.c4ad	ad 01 01	        lda length          ;   for the opcode
.c4b0	20 a5 c7	        jsr bumpad2         ; increment address by length of instruction
.c4b3	a9 41		        lda #"a"            ; stuff keyboard buffer with next assemble command:
.c4b5	8d 77 02	        sta keyd            ;   "a xxxx " where xxxx is the next address
.c4b8	a9 20		        lda #" "            ;   after the previously assembled instruction
.c4ba	8d 78 02	        sta keyd+1
.c4bd	8d 7d 02	        sta keyd+6
.c4c0	a5 c4		        lda tmp2+1          ; convert high byte of next address to hex
.c4c2	20 34 c7	        jsr asctwo
.c4c5	8d 79 02	        sta keyd+2          ; put it in the keyboard buffer
.c4c8	8e 7a 02	        stx keyd+3
.c4cb	a5 c3		        lda tmp2            ; convert low byte of next address to hex
.c4cd	20 34 c7	        jsr asctwo
.c4d0	8d 7b 02	        sta keyd+4          ; put it in the keyboard buffer
.c4d3	8e 7c 02	        stx keyd+5
.c4d6	a9 07		        lda #7              ; set number of chars in keyboard buffer
.c4d8	85 c6		        sta ndx
.c4da	4c 8f c0	        jmp strt            ; back to main loop
.c4dd	4c be c0	serror  jmp error           ; handle error
.c4e0	20 e3 c4	chek2b  jsr chekop          ; check two bytes against value in accumulator
.c4e3	8e 05 01	chekop  stx savx            ; stash x
.c4e6	ae 33 02	        ldx u9f             ; get current index into work buffer
.c4e9	dd 0d 01	        cmp u0aa0,x         ; check whether this opcode matches the buffer
.c4ec	f0 0a		        beq opok            ;   matching so far, check the next criteria
.c4ee	68		        pla                 ; didn't match, so throw away return address
.c4ef	68		        pla                 ;   on the stack because we're starting over
.c4f0	ee 06 01	bumpop  inc opcode          ; check the next opcode
.c4f3	f0 e8		        beq serror          ; error if we tried every opcode and none fit
.c4f5	4c fd c3	        jmp atryop          ; start over with new opcode
.c4f8	ee 33 02	opok    inc u9f             ; opcode matches so far; check the next criteria
.c4fb	ae 05 01	        ldx savx            ; restore x
.c4fe	60		        rts
.c4ff	b0 08		disass  bcs dis0ad          ; if no address was given, start from last address
.c501	20 66 c7	        jsr copy12          ; copy start address to tmp2
.c504	20 2d c6	        jsr getpar          ; get end address in tmp0
.c507	90 06		        bcc dis2ad          ; if one was given, skip default
.c509	a9 14		dis0ad  lda #$14            ; disassemble 14 bytes by default
.c50b	85 c1		        sta tmp0            ; store length in tmp0
.c50d	d0 05		        bne disgo           ; skip length calculation
.c50f	20 6f c7	dis2ad  jsr sub12           ; calculate number of bytes between start and end
.c512	90 1f		        bcc derror          ; error if end address is before start address
.c514	20 99 c9	disgo   jsr cline           ; clear the current line
.c517	20 e1 ff	        jsr stop            ; check for stop key
.c51a	f0 14		        beq disexit         ; exit early if pressed
.c51c	20 36 c5	        jsr dsout1          ; output disassembly prefix ". "
.c51f	ee 01 01	        inc length
.c522	ad 01 01	        lda length          ; add length of last instruction to start address
.c525	20 a5 c7	        jsr bumpad2
.c528	ad 01 01	        lda length          ; subtract length of last inst from end address
.c52b	20 7f c7	        jsr suba2
.c52e	b0 e4		        bcs disgo
.c530	4c 8f c0	disexit jmp strt            ; back to mainloop
.c533	4c be c0	derror  jmp error
.c536	a9 2e		dsout1  lda #"."            ; output ". " prefix to allow edit and reassemble
.c538	20 d2 ff	        jsr chrout
.c53b	20 03 c7	        jsr space
.c53e	20 f6 c6	dislin  jsr showad          ; show the address of the instruction
.c541	20 03 c7	        jsr space           ; insert a space
.c544	a0 00		        ldy #0              ; no offset
.c546	b1 c3		        lda (tmp2),y        ; load operand of current instruction
.c548	20 bc c5	        jsr instxx          ; get mnemonic and addressing mode for opcode
.c54b	48		        pha                 ; save index into mnemonic table
.c54c	ae 01 01	        ldx length          ; get length of operand
.c54f	e8		        inx                 ; add 1 byte for opcode
.c550	ca		dsbyt   dex                 ; decrement index
.c551	10 0e		        bpl dshex           ; show hex for byte being disassembled
.c553	8c 32 02	        sty savy            ; save index
.c556	a0 30		        ldy #msg8-msgbas    ; skip 3 spaces
.c558	20 b2 c9	        jsr sndmsg
.c55b	ac 32 02	        ldy savy            ; restore index
.c55e	4c 66 c5	        jmp nxbyt
.c561	b1 c3		dshex   lda (tmp2),y        ; show hex for byte
.c563	20 00 c7	        jsr wrbyte
.c566	c8		nxbyt   iny                 ; next byte
.c567	c0 03		        cpy #3              ; have we output 3 bytes yet?
.c569	90 e5		        bcc dsbyt           ; if not, loop
.c56b	68		        pla                 ; restore index into mnemonic table
.c56c	a2 03		        ldx #3              ; 3 letters in mnemonic
.c56e	20 04 c6	        jsr propxx          ; print mnemonic
.c571	a2 06		        ldx #6              ; 6 possible address mode character combos
.c573	e0 03		pradr1  cpx #3              ; have we checked the third combo yet?
.c575	d0 16		        bne pradr3          ; if so, output the leading characters
.c577	ac 01 01	        ldy length          ; get the length of the operand
.c57a	f0 11		        beq pradr3          ; if it's zero, there's no operand to print
.c57c	ad 00 01	pradr2  lda acmd            ; otherwise, get the addressing mode
.c57f	c9 e8		        cmp #$e8            ; check for relative addressing
.c581	08		        php                 ; save result of check
.c582	b1 c3		        lda (tmp2),y        ; get the operand
.c584	28		        plp                 ; restore result of check
.c585	b0 1d		        bcs relad           ; handle a relative address
.c587	20 24 c7	        jsr wrtwo           ; output digits from address
.c58a	88		        dey
.c58b	d0 ef		        bne pradr2          ; repeat for next byte of operand, if there is one
.c58d	0e 00 01	pradr3  asl acmd            ; check whether addr mode uses the current char
.c590	90 0e		        bcc pradr4          ; if not, skip it
.c592	bd 8f ca	        lda char1-1,x       ; look up the first char in the table
.c595	20 d2 ff	        jsr chrout          ; print first char
.c598	bd 95 ca	        lda char2-1,x       ; look up the second char in the table
.c59b	f0 03		        beq pradr4          ; if there's no second character, skip it
.c59d	20 d2 ff	        jsr chrout          ; print second char
.c5a0	ca		pradr4  dex                 ; next potential address mode character
.c5a1	d0 d0		        bne pradr1          ; loop if we haven't checked them all yet
.c5a3	60		        rts                 ; back to caller
.c5a4	20 b0 c5	relad   jsr ub64d           ; calculate absolute address from relative
.c5a7	18		        clc
.c5a8	69 01		        adc #1              ; adjust address relative to next instruction
.c5aa	d0 01		        bne relend          ; don't increment high byte unless we overflowed
.c5ac	e8		        inx                 ; increment high byte
.c5ad	4c fa c6	relend  jmp wraddr          ; print address
.c5b0	a6 c4		ub64d   ldx tmp2+1          ; get high byte of current address
.c5b2	a8		        tay                 ; is relative address positive or negative?
.c5b3	10 01		        bpl relc2           ; if positive, leave high byte alone
.c5b5	ca		        dex                 ; if negative, decrement high byte
.c5b6	65 c3		relc2   adc tmp2            ; add relative address to low byte
.c5b8	90 01		        bcc relc3           ; if there's no carry, we're done
.c5ba	e8		        inx                 ; if there's a carry, increment the high byte
.c5bb	60		relc3   rts
.c5bc	a8		instxx  tay                 ; stash opcode in accumulator in y for later
.c5bd	4a		        lsr a               ; is opcode even or odd?
.c5be	90 0b		        bcc ieven
.c5c0	4a		        lsr a
.c5c1	b0 17		        bcs err             ; invalid opcodes xxxxxx11
.c5c3	c9 22		        cmp #$22
.c5c5	f0 13		        beq err             ; invalid opcode 10001001
.c5c7	29 07		        and #$07            ; mask bits to 10000xxx
.c5c9	09 80		        ora #$80
.c5cb	4a		ieven   lsr a               ; lsb determines whether to use left/right nybble
.c5cc	aa		        tax                 ; get format index using remaining high bytes
.c5cd	bd 3e ca	        lda mode,x
.c5d0	b0 04		        bcs rtmode          ; look at left or right nybble based on carry bit
.c5d2	4a		        lsr a               ; if carry = 0, use left nybble
.c5d3	4a		        lsr a
.c5d4	4a		        lsr a
.c5d5	4a		        lsr a
.c5d6	29 0f		rtmode  and #$0f            ; if carry = 1, use right nybble
.c5d8	d0 04		        bne getfmt
.c5da	a0 80		err     ldy #$80            ; substitute 10000000 for invalid opcodes
.c5dc	a9 00		        lda #0
.c5de	aa		getfmt  tax
.c5df	bd 82 ca	        lda mode2,x         ; lookup operand format using selected nybble
.c5e2	8d 00 01	        sta acmd            ; save for later use
.c5e5	29 03		        and #$03            ; lower 2 bits indicate number of bytes in operand
.c5e7	8d 01 01	        sta length
.c5ea	98		        tya                 ; restore original opcode
.c5eb	29 8f		        and #$8f            ; mask bits to x000xxxx
.c5ed	aa		        tax                 ; save it
.c5ee	98		        tya                 ; restore original opcode
.c5ef	a0 03		        ldy #3
.c5f1	e0 8a		        cpx #$8a            ; check if opcode = 1xxx1010
.c5f3	f0 0b		        beq gtfm4
.c5f5	4a		gtfm2   lsr a               ; transform opcode into index for mnemonic table
.c5f6	90 08		        bcc gtfm4
.c5f8	4a		        lsr a               ; opcodes transformed as follows:
.c5f9	4a		gtfm3   lsr a               ; 1xxx1010->00101xxx
.c5fa	09 20		        ora #$20            ; xxxyyy01->00111xxx
.c5fc	88		        dey                 ; xxxyyy10->00111xxx
.c5fd	d0 fa		        bne gtfm3           ; xxxyy100->00110xxx
.c5ff	c8		        iny                 ; xxxxx000->000xxxxx
.c600	88		gtfm4   dey
.c601	d0 f2		        bne gtfm2
.c603	60		        rts
.c604	a8		propxx  tay                 ; use index in accumulator to look up mnemonic
.c605	b9 9c ca	        lda mneml,y         ;   and place a temporary copy in store
.c608	8d 2f 02	        sta store
.c60b	b9 dc ca	        lda mnemr,y
.c60e	8d 30 02	        sta store+1
.c611	a9 00		prmn1   lda #0              ; clear accumulator
.c613	a0 05		        ldy #$05            ; shift 5 times
.c615	0e 30 02	prmn2   asl store+1         ; shift right byte
.c618	2e 2f 02	        rol store           ; rotate bits from right byte into left byte
.c61b	2a		        rol a               ; rotate bits from left byte into accumulator
.c61c	88		        dey                 ; next bit
.c61d	d0 f6		        bne prmn2           ; loop until all bits shifted
.c61f	69 3f		        adc #$3f            ; calculate ascii code for letter by adding to '?'
.c621	20 d2 ff	        jsr chrout          ; output letter
.c624	ca		        dex                 ; next letter
.c625	d0 ea		        bne prmn1           ; loop until all 3 letters are output
.c627	4c 03 c7	        jmp space           ; output space
.c62a	ce 31 02	rdpar   dec chrpnt          ; back up one char
.c62d	20 55 c6	getpar  jsr rdval           ; read the value
.c630	b0 17		        bcs gterr           ; carry set indicates error
.c632	20 49 c7	        jsr gotchr          ; check previous character
.c635	d0 0a		        bne ckterm          ; if it's not null, check if it's a valid separator
.c637	ce 31 02	        dec chrpnt          ; back up one char
.c63a	ad 08 01	        lda digcnt          ; get number of digits read
.c63d	d0 11		        bne getgot          ; found some digits
.c63f	f0 0d		        beq gtnil           ; didn't find any digits
.c641	c9 20		ckterm  cmp #$20            ; space or comma are valid separators
.c643	f0 0b		        beq getgot          ; anything else is an error
.c645	c9 2c		        cmp #","
.c647	f0 07		        beq getgot
.c649	68		gterr   pla                 ; encountered error
.c64a	68		        pla                 ; get rid of command vector pushed on stack
.c64b	4c be c0	        jmp error           ; handle error
.c64e	38		gtnil   sec                 ; set carry to indicate no parameter found
>c64f	24		        .byte $24           ; bit zp opcode consumes next byte (clc)
.c650	18		getgot  clc                 ; clear carry to indicate paremeter returned
.c651	ad 08 01	        lda digcnt          ; return number of digits in a
.c654	60		        rts                 ; return to address pushed from vector table
.c655	a9 00		rdval   lda #0              ; clear temp
.c657	85 c1		        sta tmp0
.c659	85 c2		        sta tmp0+1
.c65b	8d 08 01	        sta digcnt          ; clear digit counter
.c65e	8a		        txa                 ; save x and y
.c65f	48		        pha
.c660	98		        tya
.c661	48		        pha
.c662	20 4c c7	rdvmor  jsr getchr          ; get next character from input buffer
.c665	f0 1e		        beq rdnilk          ; null at end of buffer
.c667	c9 20		        cmp #$20            ; skip spaces
.c669	f0 f7		        beq rdvmor
.c66b	a2 03		        ldx #3              ; check numeric base [$+&%]
.c66d	dd 2f cb	gnmode  cmp hikey,x
.c670	f0 07		        beq gotmod          ; got a match, set up base
.c672	ca		        dex
.c673	10 f8		        bpl gnmode          ; check next base
.c675	e8		        inx                 ; default to hex
.c676	ce 31 02	        dec chrpnt          ; back up one character
.c679	bc 54 cb	gotmod  ldy modtab,x        ; get base value
.c67c	bd 58 cb	        lda lentab,x        ; get bits per digit
.c67f	8d 0a 01	        sta numbit          ; store bits per digit
.c682	20 4c c7	nudig   jsr getchr          ; get next char in a
.c685	f0 63		rdnilk  beq rdnil           ; end of number if no more characters
.c687	38		        sec
.c688	e9 30		        sbc #$30            ; subtract ascii value of 0 to get numeric value
.c68a	90 5e		        bcc rdnil           ; end of number if character was less than 0
.c68c	c9 0a		        cmp #$0a
.c68e	90 06		        bcc digmor          ; not a hex digit if less than a
.c690	e9 07		        sbc #$07            ; 7 chars between ascii 9 and a, so subtract 7
.c692	c9 10		        cmp #$10            ; end of number if char is greater than f
.c694	b0 54		        bcs rdnil
.c696	8d 09 01	digmor  sta indig           ; store the digit
.c699	cc 09 01	        cpy indig           ; compare base with the digit
.c69c	90 4a		        bcc rderr           ; error if the digit >= the base
.c69e	f0 48		        beq rderr
.c6a0	ee 08 01	        inc digcnt          ; increment the number of digits
.c6a3	c0 0a		        cpy #10
.c6a5	d0 0a		        bne nodecm          ; skip the next part if not using base 10
.c6a7	a2 01		        ldx #1
.c6a9	b5 c1		declp1  lda tmp0,x          ; stash the previous 16-bit value for later use
.c6ab	9d 0b 01	        sta stash,x
.c6ae	ca		        dex
.c6af	10 f8		        bpl declp1
.c6b1	ae 0a 01	nodecm  ldx numbit          ; number of bits to shift
.c6b4	06 c1		times2  asl tmp0            ; shift 16-bit value by specified number of bits
.c6b6	26 c2		        rol tmp0+1
.c6b8	b0 2e		        bcs rderr           ; error if we overflowed 16 bits
.c6ba	ca		        dex
.c6bb	d0 f7		        bne times2          ; shift remaining bits
.c6bd	c0 0a		        cpy #10
.c6bf	d0 18		        bne nodec2          ; skip the next part if not using base 10
.c6c1	0e 0b 01	        asl stash           ; shift the previous 16-bit value one bit left
.c6c4	2e 0c 01	        rol stash+1
.c6c7	b0 1f		        bcs rderr           ; error if we overflowed 16 bits
.c6c9	ad 0b 01	        lda stash           ; add shifted previous value to current value
.c6cc	65 c1		        adc tmp0
.c6ce	85 c1		        sta tmp0
.c6d0	ad 0c 01	        lda stash+1
.c6d3	65 c2		        adc tmp0+1
.c6d5	85 c2		        sta tmp0+1
.c6d7	b0 0f		        bcs rderr           ; error if we overflowed 16 bits
.c6d9	18		nodec2  clc
.c6da	ad 09 01	        lda indig           ; load current digit
.c6dd	65 c1		        adc tmp0            ; add current digit to low byte
.c6df	85 c1		        sta tmp0            ; and store result back in low byte
.c6e1	8a		        txa                 ; a=0
.c6e2	65 c2		        adc tmp0+1          ; add carry to high byte
.c6e4	85 c2		        sta tmp0+1          ; and store result back in high byte
.c6e6	90 9a		        bcc nudig           ; get next digit if we didn't overflow
.c6e8	38		rderr   sec                 ; set carry to indicate error
>c6e9	24		        .byte $24           ; bit zp opcode consumes next byte (clc)
.c6ea	18		rdnil   clc                 ; clear carry to indicate success
.c6eb	8c 0a 01	        sty numbit          ; save base of number
.c6ee	68		        pla                 ; restore x and y
.c6ef	a8		        tay
.c6f0	68		        pla
.c6f1	aa		        tax
.c6f2	ad 08 01	        lda digcnt          ; return number of digits in a
.c6f5	60		        rts
.c6f6	a5 c3		showad  lda tmp2
.c6f8	a6 c4		        ldx tmp2+1
.c6fa	48		wraddr  pha                 ; save low byte
.c6fb	8a		        txa                 ; put high byte in a
.c6fc	20 24 c7	        jsr wrtwo           ; output high byte
.c6ff	68		        pla                 ; restore low byte
.c700	20 24 c7	wrbyte  jsr wrtwo           ; output byte in a
.c703	a9 20		space   lda #$20            ; output space
.c705	d0 0f		        bne flip
.c707	c9 0d		chout   cmp #$0d            ; output char with special handling of cr
.c709	d0 0b		        bne flip
.c70b	a9 0d		crlf    lda #$0d            ; load cr in a
.c70d	24 13		        bit $13             ; check default channel
.c70f	10 05		        bpl flip            ; if high bit is clear output cr only
.c711	20 d2 ff	        jsr chrout          ; otherwise output cr+lf
.c714	a9 0a		        lda #$0a            ; output lf
.c716	4c d2 ff	flip    jmp chrout
.c719	20 0b c7	fresh   jsr crlf            ; output cr
.c71c	a9 20		        lda #$20            ; load space in a
.c71e	20 d2 ff	        jsr chrout
.c721	4c a2 c9	        jmp snclr
.c724	8e 05 01	wrtwo   stx savx            ; save x
.c727	20 34 c7	        jsr asctwo          ; get hex chars for byte in x (lower) and a (upper)
.c72a	20 d2 ff	        jsr chrout          ; output upper nybble
.c72d	8a		        txa                 ; transfer lower to a
.c72e	ae 05 01	        ldx savx            ; restore x
.c731	4c d2 ff	        jmp chrout          ; output lower nybble
.c734	48		asctwo  pha                 ; save byte
.c735	20 3e c7	        jsr ascii           ; do low nybble
.c738	aa		        tax                 ; save in x
.c739	68		        pla                 ; restore byte
.c73a	4a		        lsr a               ; shift upper nybble down
.c73b	4a		        lsr a
.c73c	4a		        lsr a
.c73d	4a		        lsr a
.c73e	29 0f		ascii   and #$0f            ; clear upper nibble
.c740	c9 0a		        cmp #$0a            ; if less than a, skip next step
.c742	90 02		        bcc asc1
.c744	69 06		        adc #6              ; skip ascii chars between 9 and a
.c746	69 30		asc1    adc #$30            ; add ascii char 0 to value
.c748	60		        rts
.c749	ce 31 02	gotchr  dec chrpnt
.c74c	8e 05 01	getchr  stx savx
.c74f	ae 31 02	        ldx chrpnt          ; get pointer to next char
.c752	bd 00 02	        lda inbuff,x        ; load next char in a
.c755	f0 06		        beq nochar          ; null, :, or ? signal end of buffer
.c757	c9 3a		        cmp #":"
.c759	f0 02		        beq nochar
.c75b	c9 3f		        cmp #"?"
.c75d	08		nochar  php
.c75e	ee 31 02	        inc chrpnt          ; next char
.c761	ae 05 01	        ldx savx
.c764	28		        plp                 ; z flag will signal last character
.c765	60		        rts
.c766	a5 c1		copy12  lda tmp0            ; low byte
.c768	85 c3		        sta tmp2
.c76a	a5 c2		        lda tmp0+1          ; high byte
.c76c	85 c4		        sta tmp2+1
.c76e	60		        rts
.c76f	38		sub12   sec
.c770	a5 c1		        lda tmp0            ; subtract low byte
.c772	e5 c3		        sbc tmp2
.c774	85 c1		        sta tmp0
.c776	a5 c2		        lda tmp0+1
.c778	e5 c4		        sbc tmp2+1          ; subtract high byte
.c77a	85 c2		        sta tmp0+1
.c77c	60		        rts
.c77d	a9 01		suba1   lda #1              ; shortcut to decrement by 1
.c77f	8d 05 01	suba2   sta savx            ; subtrahend in accumulator
.c782	38		        sec
.c783	a5 c1		        lda tmp0            ; minuend in low byte
.c785	ed 05 01	        sbc savx
.c788	85 c1		        sta tmp0
.c78a	a5 c2		        lda tmp0+1          ; borrow from high byte
.c78c	e9 00		        sbc #0
.c78e	85 c2		        sta tmp0+1
.c790	60		        rts
.c791	38		sub13   sec
.c792	ad 2f 02	        lda store
.c795	e9 01		        sbc #1              ; decrement low byte
.c797	8d 2f 02	        sta store
.c79a	ad 30 02	        lda store+1
.c79d	e9 00		        sbc #0              ; borrow from high byte
.c79f	8d 30 02	        sta store+1
.c7a2	60		        rts
.c7a3	a9 01		adda2   lda #1              ; shortcut to increment by 1
.c7a5	18		bumpad2 clc
.c7a6	65 c3		        adc tmp2            ; add value in accumulator to low byte
.c7a8	85 c3		        sta tmp2
.c7aa	90 02		        bcc bumpex
.c7ac	e6 c4		        inc tmp2+1          ; carry to high byte
.c7ae	60		bumpex  rts
.c7af	38		sub21   sec
.c7b0	a5 c3		        lda tmp2            ; decrement low byte
.c7b2	e9 01		        sbc #1
.c7b4	85 c3		        sta tmp2
.c7b6	a5 c4		        lda tmp2+1          ; borrow from high byte
.c7b8	e9 00		        sbc #0
.c7ba	85 c4		        sta tmp2+1
.c7bc	60		        rts
.c7bd	b0 0a		copy1p  bcs cpy1px          ; do nothing if parameter is empty
.c7bf	a5 c1		        lda tmp0            ; copy low byte
.c7c1	a4 c2		        ldy tmp0+1          ; copy high byte
.c7c3	8d 29 02	        sta pcl
.c7c6	8c 28 02	        sty pch
.c7c9	60		cpy1px  rts
.c7ca	b0 23		getdif  bcs gdifx           ; exit with error if no parameter given
.c7cc	20 66 c7	        jsr copy12          ; save start address in tmp2
.c7cf	20 2d c6	        jsr getpar          ; get end address in tmp0
.c7d2	b0 1b		        bcs gdifx           ; exit with error if no parameter given
.c7d4	a5 c1		        lda tmp0            ; save end address in stash
.c7d6	8d 0b 01	        sta stash
.c7d9	a5 c2		        lda tmp0+1
.c7db	8d 0c 01	        sta stash+1
.c7de	20 6f c7	        jsr sub12           ; subtract start address from end address
.c7e1	a5 c1		        lda tmp0
.c7e3	8d 2f 02	        sta store           ; save difference in store
.c7e6	a5 c2		        lda tmp0+1
.c7e8	8d 30 02	        sta store+1
.c7eb	90 02		        bcc gdifx           ; error if start address is after end address
.c7ed	18		        clc                 ; clear carry to indicate success
>c7ee	24		        .byte $24           ; bit zp opcode consumes next byte (sec)
.c7ef	38		gdifx   sec                 ; set carry to indicate error
.c7f0	60		        rts
.c7f1	20 2a c6	convrt  jsr rdpar           ; read a parameter
.c7f4	20 19 c7	        jsr fresh           ; next line and clear
.c7f7	a9 24		        lda #"$"            ; output $ sigil for hex
.c7f9	20 d2 ff	        jsr chrout
.c7fc	a5 c1		        lda tmp0            ; load the 16-bit value entered
.c7fe	a6 c2		        ldx tmp0+1
.c800	20 fa c6	        jsr wraddr          ; print it in 4 hex digits
.c803	20 19 c7	        jsr fresh
.c806	a9 2b		        lda #"+"            ; output + sigil for decimal
.c808	20 d2 ff	        jsr chrout
.c80b	20 3c c8	        jsr cvtdec          ; convert to bcd using hardware mode
.c80e	a9 00		        lda #0              ; clear digit counter
.c810	a2 06		        ldx #6              ; max digits + 1
.c812	a0 03		        ldy #3              ; bits per digit - 1
.c814	20 76 c8	        jsr nmprnt          ; print result without leading zeros
.c817	20 19 c7	        jsr fresh           ; next line and clear
.c81a	a9 26		        lda #"&"            ; print & sigil for octal
.c81c	20 d2 ff	        jsr chrout
.c81f	a9 00		        lda #0              ; clear digit counter
.c821	a2 08		        ldx #8              ; max digits + 1
.c823	a0 02		        ldy #2              ; bits per digit - 1
.c825	20 65 c8	        jsr prinum          ; output number
.c828	20 19 c7	        jsr fresh           ; next line and clear
.c82b	a9 25		        lda #"%"            ; print % sigil for binary
.c82d	20 d2 ff	        jsr chrout
.c830	a9 00		        lda #0              ; clear digit counter
.c832	a2 18		        ldx #$18            ; max digits + 1
.c834	a0 00		        ldy #0              ; bits per digit - 1
.c836	20 65 c8	        jsr prinum          ; output number
.c839	4c 8f c0	        jmp strt            ; back to mainloop
.c83c	20 66 c7	cvtdec  jsr copy12          ; copy value from tmp0 to tmp2
.c83f	a9 00		        lda #0
.c841	a2 02		        ldx #2              ; clear 3 bytes in work buffer
.c843	9d 0d 01	decml1  sta u0aa0,x
.c846	ca		        dex
.c847	10 fa		        bpl decml1
.c849	a0 10		        ldy #16             ; 16 bits in input
.c84b	08		        php                 ; save status register
.c84c	78		        sei                 ; make sure no interrupts occur with bcd enabled
.c84d	f8		        sed
.c84e	06 c3		decml2  asl tmp2            ; rotate bytes out of input low byte
.c850	26 c4		        rol tmp2+1          ; .. into high byte and carry bit
.c852	a2 02		        ldx #2              ; process 3 bytes
.c854	bd 0d 01	decdbl  lda u0aa0,x         ; load current value of byte
.c857	7d 0d 01	        adc u0aa0,x         ; add it to itself plus the carry bit
.c85a	9d 0d 01	        sta u0aa0,x         ; store it back in the same location
.c85d	ca		        dex                 ; decrement byte counter
.c85e	10 f4		        bpl decdbl          ; loop until all bytes processed
.c860	88		        dey                 ; decrement bit counter
.c861	d0 eb		        bne decml2          ; loop until all bits processed
.c863	28		        plp                 ; restore processor status
.c864	60		        rts
.c865	48		prinum  pha                 ; save accumulator
.c866	a5 c1		        lda tmp0            ; copy input low byte to work buffer
.c868	8d 0f 01	        sta u0aa0+2
.c86b	a5 c2		        lda tmp0+1          ; copy input high byte to work buffer
.c86d	8d 0e 01	        sta u0aa0+1
.c870	a9 00		        lda #0              ; clear overflow byte in work buffer
.c872	8d 0d 01	        sta u0aa0
.c875	68		        pla                 ; restore accumulator
.c876	8d 08 01	nmprnt  sta digcnt          ; number of digits in accumulator
.c879	8c 0a 01	        sty numbit          ; bits per digit passed in y register
.c87c	ac 0a 01	digout  ldy numbit          ; get bits to process
.c87f	a9 00		        lda #0              ; clear accumulator
.c881	0e 0f 01	rolbit  asl u0aa0+2         ; shift bits out of low byte
.c884	2e 0e 01	        rol u0aa0+1         ; ... into high byte
.c887	2e 0d 01	        rol u0aa0           ; ... into overflow byte
.c88a	2a		        rol a               ; ... into accumulator
.c88b	88		        dey                 ; decrement bit counter
.c88c	10 f3		        bpl rolbit          ; loop until all bits processed
.c88e	a8		        tay                 ; check whether accumulator is 0
.c88f	d0 09		        bne nzero           ; if not, print it
.c891	e0 01		        cpx #1              ; have we output the max number of digits?
.c893	f0 05		        beq nzero           ; if not, print it
.c895	ac 08 01	        ldy digcnt          ; how many digits have we output?
.c898	f0 08		        beq zersup          ; skip output if digit is 0
.c89a	ee 08 01	nzero   inc digcnt          ; increment digit counter
.c89d	09 30		        ora #$30            ; add numeric value to ascii '0' to get ascii char
.c89f	20 d2 ff	        jsr chrout          ; output character
.c8a2	ca		zersup  dex                 ; decrement number of leading zeros
.c8a3	d0 d7		        bne digout          ; next digit
.c8a5	60		        rts
.c8a6	d0 03		dstat   bne chgdev          ; if device address was given, use it
.c8a8	a2 08		        ldx #8              ; otherwise, default to 8
>c8aa	2c		        .byte $2c           ; absolute bit opcode consumes next word (ldx tmp0)
.c8ab	a6 c1		chgdev  ldx tmp0            ; load device address from parameter
.c8ad	e0 04		        cpx #4              ; make sure device address is in range 4-31
.c8af	90 58		        bcc ioerr
.c8b1	e0 20		        cpx #32
.c8b3	b0 54		        bcs ioerr
.c8b5	86 c1		        stx tmp0
.c8b7	a9 00		        lda #0              ; clear status
.c8b9	85 90		        sta satus
.c8bb	85 b7		        sta fnlen           ; empty filename
.c8bd	20 4c c7	        jsr getchr          ; get next character
.c8c0	f0 24		        beq instat1         ; null, display status
.c8c2	ce 31 02	        dec chrpnt          ; back up 1 char
.c8c5	c9 24		        cmp #"$"            ; $, display directory
.c8c7	f0 43		        beq direct
.c8c9	a5 c1		        lda tmp0            ; command specified device to listen
.c8cb	20 b1 ff	        jsr listen
.c8ce	a9 6f		        lda #$6f            ; secondary address 15 (only low nybble used)
.c8d0	20 93 ff	        jsr second
.c8d3	ae 31 02	dcomd   ldx chrpnt          ; get next character from buffer
.c8d6	ee 31 02	        inc chrpnt
.c8d9	bd 00 02	        lda inbuff,x
.c8dc	f0 05		        beq instat          ; break out of loop if it's null
.c8de	20 a8 ff	        jsr ciout           ; otherwise output it to the serial bus
.c8e1	90 f0		        bcc dcomd           ; unconditional loop: ciout clears carry before rts
.c8e3	20 ae ff	instat  jsr unlsn           ; command device to unlisten
.c8e6	20 0b c7	instat1 jsr crlf            ; new line
.c8e9	a5 c1		        lda tmp0            ; load device address
.c8eb	20 b4 ff	        jsr talk            ; command device to talk
.c8ee	a9 6f		        lda #$6f            ; secondary address 15 (only low nybble used)
.c8f0	20 96 ff	        jsr tksa
.c8f3	20 a5 ff	rdstat  jsr acptr           ; read byte from serial bus
.c8f6	20 d2 ff	        jsr chrout          ; print it
.c8f9	c9 0d		        cmp #$0d            ; if the byte is cr, exit loop
.c8fb	f0 06		        beq dexit
.c8fd	a5 90		        lda satus           ; check status
.c8ff	29 bf		        and #$bf            ; ignore eoi bit
.c901	f0 f0		        beq rdstat          ; if no errors, read next byte
.c903	20 ab ff	dexit   jsr untlk           ; command device to stop talking
.c906	4c 8f c0	        jmp strt            ; back to mainloop
.c909	4c be c0	ioerr   jmp error           ; handle error
.c90c	a5 c1		direct  lda tmp0            ; load device address
.c90e	20 b1 ff	        jsr listen          ; command device to listen
.c911	a9 f0		        lda #$f0            ; secondary address 0 (only low nybble used)
.c913	20 93 ff	        jsr second
.c916	ae 31 02	        ldx chrpnt          ; get index of next character
.c919	bd 00 02	dir2    lda inbuff,x        ; get next character from buffer
.c91c	f0 06		        beq dir3            ; break if it's null
.c91e	20 a8 ff	        jsr ciout           ; send character to device
.c921	e8		        inx                 ; increment characer index
.c922	d0 f5		        bne dir2            ; loop if it hasn't wrapped to zero
.c924	20 ae ff	dir3    jsr unlsn           ; command device to unlisten
.c927	20 0b c7	        jsr crlf            ; new line
.c92a	a5 c1		        lda tmp0            ; load device address
.c92c	48		        pha                 ; save on stack
.c92d	20 b4 ff	        jsr talk            ; command device to talk
.c930	a9 60		        lda #$60            ; secondary address 0 (only low nybble used)
.c932	20 96 ff	        jsr tksa
.c935	a0 03		        ldy #3              ; read 3 16-bit values from device
.c937	8c 2f 02	dirlin  sty store           ;   ignore the first 2; 3rd is file size
.c93a	20 a5 ff	dlink   jsr acptr           ; read low byte from device
.c93d	85 c1		        sta tmp0            ; store it
.c93f	a5 90		        lda satus           ; check status
.c941	d0 44		        bne drexit          ; exit if error or eof occurred
.c943	20 a5 ff	        jsr acptr           ; read high byte from device
.c946	85 c2		        sta tmp0+1          ; store it
.c948	a5 90		        lda satus           ; check status
.c94a	d0 3b		        bne drexit          ; exit if error or eof cocurred
.c94c	ce 2f 02	        dec store           ; decrement byte count
.c94f	d0 e9		        bne dlink           ; loop if bytes remain
.c951	20 3c c8	        jsr cvtdec          ; convert last 16-bit value to decimal
.c954	a9 00		        lda #0              ; clear digit count
.c956	a2 06		        ldx #6              ; max 6 digits
.c958	a0 03		        ldy #3              ; 3 bits per digit
.c95a	20 76 c8	        jsr nmprnt          ; output number
.c95d	a9 20		        lda #" "            ; output space
.c95f	20 d2 ff	        jsr chrout
.c962	20 a5 ff	dname   jsr acptr           ; get a filename character from the device
.c965	f0 0a		        beq dmore           ; if it's null, break out of loop
.c967	a6 90		        ldx satus           ; check for errors or eof
.c969	d0 1c		        bne drexit          ; if found exit early
.c96b	20 d2 ff	        jsr chrout          ; output character
.c96e	18		        clc
.c96f	90 f1		        bcc dname           ; unconditional branch to read next char
.c971	20 0b c7	dmore   jsr crlf
.c974	20 e1 ff	        jsr stop            ; check for stop key
.c977	f0 0e		        beq drexit          ; exit early if pressed
.c979	20 e4 ff	        jsr getin           ; pause if a key was pressed
.c97c	f0 05		        beq nopaws
.c97e	20 e4 ff	paws    jsr getin           ; wait until another key is pressed
.c981	f0 fb		        beq paws
.c983	a0 02		nopaws  ldy #2
.c985	d0 b0		        bne dirlin          ; unconditional branch to read next file
.c987	20 ab ff	drexit  jsr untlk           ; command device to untalk
.c98a	68		        pla                 ; restore accumulator
.c98b	20 b1 ff	        jsr listen          ; command device to listen
.c98e	a9 e0		        lda #$e0            ; secondary address 0 (only low nybble is used)
.c990	20 93 ff	        jsr second
.c993	20 ae ff	        jsr unlsn           ; command device to unlisten
.c996	4c 8f c0	        jmp strt            ; back to mainloop
.c999	20 0b c7	cline   jsr crlf            ; send cr+lf
.c99c	4c a2 c9	        jmp snclr           ; clear line
.c99f	20 b2 c9	sndclr  jsr sndmsg
.c9a2	a0 28		snclr   ldy #$28            ; loop 40 times
.c9a4	a9 20		snclp   lda #$20            ; output space character
.c9a6	20 d2 ff	        jsr chrout
.c9a9	a9 14		        lda #$14            ; output delete character
.c9ab	20 d2 ff	        jsr chrout
.c9ae	88		        dey
.c9af	d0 f3		        bne snclp
.c9b1	60		        rts
.c9b2	b9 c0 c9	sndmsg  lda msgbas,y        ; y contains offset in msg table
.c9b5	08		        php
.c9b6	29 7f		        and #$7f            ; strip high bit before output
.c9b8	20 07 c7	        jsr chout
.c9bb	c8		        iny
.c9bc	28		        plp
.c9bd	10 f3		        bpl sndmsg          ; loop until high bit is set
.c9bf	60		        rts
=$c9c0			msgbas  =*
>c9c0	0d		msg2    .byte $0d               ; header for registers
>c9c1	20 20 20 50	        .text "   pc  sr ac xr yr sp   v1.2"
>c9c5	43 20 20 53 52 20 41 43 20 58 52 20 59 52 20 53
>c9d5	50 20 20 20 56 31 2e 32
>c9dd	8d		        .byte $0d+$80
>c9de	1d bf		msg3    .byte $1d,$3f+$80       ; syntax error: move right, display "?"
>c9e0	2e 2e 53 59	msg4    .text "..sys"           ; sys call to enter monitor
>c9e4	53
>c9e5	a0		        .byte $20+$80
>c9e6	3a 92		msg5    .byte $3a,$12+$80       ; ":" then rvs on for memory ascii dump
>c9e8	20 45 52 52	msg6    .text " erro"           ; i/o error: display " error"
>c9ec	4f
>c9ed	d2		        .byte "r"+$80
>c9ee	41 a0		msg7    .byte $41,$20+$80       ; assemble next instruction: "a " + addr
>c9f0	20 20		msg8    .text "  "              ; pad non-existent byte: skip 3 spaces
>c9f2	a0		        .byte $20+$80
>c9f3	1d 1d 1d 1d	msg9    .byte 29,29,29,29,29,29
>c9f7	1d 1d
>c9f9	3c 20 3c 20	        .text "< < < < < supermon > > > > >"
>c9fd	3c 20 3c 20 3c 20 53 55 50 45 52 4d 4f 4e 20 3e
>ca0d	20 3e 20 3e 20 3e 20 3e
>ca15	8d		        .byte $0d+$80
>ca16	20 42 59 20	msga    .text " by jim butterfield  (r.i.p. 1936-2007)"
>ca1a	4a 49 4d 20 42 55 54 54 45 52 46 49 45 4c 44 20
>ca2a	20 28 52 2e 49 2e 50 2e 20 31 39 33 36 2d 32 30
>ca3a	30 37 29
>ca3d	8d		        .byte $0d+$80
>ca3e	40 02 45 03	mode    .byte $40,$02,$45,$03   ; even opcodes
>ca42	d0 08 40 09	        .byte $d0,$08,$40,$09
>ca46	30 22 45 33	        .byte $30,$22,$45,$33
>ca4a	d0 08 40 09	        .byte $d0,$08,$40,$09
>ca4e	40 02 45 33	        .byte $40,$02,$45,$33
>ca52	d0 08 40 09	        .byte $d0,$08,$40,$09
>ca56	40 02 45 b3	        .byte $40,$02,$45,$b3
>ca5a	d0 08 40 09	        .byte $d0,$08,$40,$09
>ca5e	00 22 44 33	        .byte $00,$22,$44,$33
>ca62	d0 8c 44 00	        .byte $d0,$8c,$44,$00
>ca66	11 22 44 33	        .byte $11,$22,$44,$33
>ca6a	d0 8c 44 9a	        .byte $d0,$8c,$44,$9a
>ca6e	10 22 44 33	        .byte $10,$22,$44,$33
>ca72	d0 08 40 09	        .byte $d0,$08,$40,$09
>ca76	10 22 44 33	        .byte $10,$22,$44,$33
>ca7a	d0 08 40 09	        .byte $d0,$08,$40,$09
>ca7e	62 13 78 a9	        .byte $62,$13,$78,$a9   ; opcodes ending in 01
>ca82	00		mode2   .byte $00   ; 000 000    00                  0   error
>ca83	21		        .byte $21   ; 001 000    01      #$00        1   immediate
>ca84	81		        .byte $81   ; 100 000    01      $00         2   zero-page
>ca85	82		        .byte $82   ; 100 000    10      $0000       3   absolute
>ca86	00		        .byte $00   ; 000 000    00                  4   implied
>ca87	00		        .byte $00   ; 000 000    00                  5   accumulator
>ca88	59		        .byte $59   ; 010 110    01      ($00,x)     6   indirect,x
>ca89	4d		        .byte $4d   ; 010 011    01      ($00),y     7   indirect,y
>ca8a	91		        .byte $91   ; 100 100    01      $00,x       8   zero-page,x
>ca8b	92		        .byte $92   ; 100 100    10      $0000,x     9   absolute,x
>ca8c	86		        .byte $86   ; 100 001    10      $0000,y     a   absolute,y
>ca8d	4a		        .byte $4a   ; 010 010    10      ($0000)     b   indirect
>ca8e	85		        .byte $85   ; 100 001    01      $00,y       c   zero-page,y
>ca8f	9d		        .byte $9d   ; 100 111    01      $0000*      d   relative
>ca90	2c 29 2c	char1   .byte $2c,$29,$2c       ; ","  ")"  ","
>ca93	23 28 24	        .byte $23,$28,$24       ; "#"  "("  "$"
>ca96	59 00 58	char2   .byte $59,$00,$58       ; "y"   0   "x"
>ca99	24 24 00	        .byte $24,$24,$00       ; "$"  "$"   0
>ca9c	1c 8a 1c 23	mneml   .byte $1c,$8a,$1c,$23   ; brk php bpl clc
>caa0	5d 8b 1b a1	        .byte $5d,$8b,$1b,$a1   ; jsr plp bmi sec
>caa4	9d 8a 1d 23	        .byte $9d,$8a,$1d,$23   ; rti pha bvc cli
>caa8	9d 8b 1d a1	        .byte $9d,$8b,$1d,$a1   ; rts pla bvs sei
>caac	00 29 19 ae	        .byte $00,$29,$19,$ae   ; ??? dey bcc tya
>cab0	69 a8 19 23	        .byte $69,$a8,$19,$23   ; ldy tay bcs clv
>cab4	24 53 1b 23	        .byte $24,$53,$1b,$23   ; cpy iny bne cld
>cab8	24 53 19 a1	        .byte $24,$53,$19,$a1   ; cpx inx beq sed
>cabc	00 1a 5b 5b	        .byte $00,$1a,$5b,$5b   ; ??? bit jmp jmp
>cac0	a5 69 24 24	        .byte $a5,$69,$24,$24   ; sty ldy cpy cpx
>cac4	ae ae a8 ad	        .byte $ae,$ae,$a8,$ad   ; txa txs tax tsx
>cac8	29 00 7c 00	        .byte $29,$00,$7c,$00   ; dex ??? nop ???
>cacc	15 9c 6d 9c	        .byte $15,$9c,$6d,$9c   ; asl rol lsr ror
>cad0	a5 69 29 53	        .byte $a5,$69,$29,$53   ; stx ldx dec inc
>cad4	84 13 34 11	        .byte $84,$13,$34,$11   ; ora and eor adc
>cad8	a5 69 23 a0	        .byte $a5,$69,$23,$a0   ; sta lda cmp sbc
>cadc	d8 62 5a 48	mnemr   .byte $d8,$62,$5a,$48   ; brk php bpl clc
>cae0	26 62 94 88	        .byte $26,$62,$94,$88   ; jsr plp bmi sec
>cae4	54 44 c8 54	        .byte $54,$44,$c8,$54   ; rti pha bvc cli
>cae8	68 44 e8 94	        .byte $68,$44,$e8,$94   ; rts pla bvs sei
>caec	00 b4 08 84	        .byte $00,$b4,$08,$84   ; ??? dey bcc tya
>caf0	74 b4 28 6e	        .byte $74,$b4,$28,$6e   ; ldy tay bcs clv
>caf4	74 f4 cc 4a	        .byte $74,$f4,$cc,$4a   ; cpy iny bne cld
>caf8	72 f2 a4 8a	        .byte $72,$f2,$a4,$8a   ; cpx inx beq sed
>cafc	00 aa a2 a2	        .byte $00,$aa,$a2,$a2   ; ??? bit jmp jmp
>cb00	74 74 74 72	        .byte $74,$74,$74,$72   ; sty ldy cpy cpx
>cb04	44 68 b2 32	        .byte $44,$68,$b2,$32   ; txa txs tax tsx
>cb08	b2 00 22 00	        .byte $b2,$00,$22,$00   ; dex ??? nop ???
>cb0c	1a 1a 26 26	        .byte $1a,$1a,$26,$26   ; asl rol lsr ror
>cb10	72 72 88 c8	        .byte $72,$72,$88,$c8   ; stx ldx dec inc
>cb14	c4 ca 26 48	        .byte $c4,$ca,$26,$48   ; ora and eor adc
>cb18	44 44 a2 c8	        .byte $44,$44,$a2,$c8   ; sta lda cmp sbc
>cb1c	0d 20 20 20	        .byte $0d,$20,$20,$20
>cb20	41 43 44 46	keyw    .text "acdfghjmrtx@.>;"
>cb24	47 48 4a 4d 52 54 58 40 2e 3e 3b
>cb2f	24 2b 26 25	hikey   .text "$+&%lsv"
>cb33	4c 53 56
=$cb36			keytop  =*
>cb36	71 c3 c9 c1	kaddr   .word assem-1,compar-1,disass-1,fill-1
>cb3a	fe c4 4c c3
>cb3e	54 c1 4d c2	        .word goto-1,hunt-1,jsub-1,dsplym-1
>cb42	72 c1 e7 c0
>cb46	6c c0 cc c1	        .word dsplyr-1,trans-1,exit-1,dstat-1
>cb4a	e4 c0 a5 c8
>cb4e	71 c3 34 c1	        .word assem-1,altm-1,altr-1
>cb52	1d c1
>cb54	10 0a 08 02	modtab  .byte $10,$0a,$08,02    ; modulo number systems
>cb58	04 03 03 01	lentab  .byte $04,$03,$03,$01   ; bits per digit
>cb5c	5e c0		linkad  .word break             ; address of brk handler
>cb5e	00 c0		supad   .word super             ; address of entry point

;******  End of listing
