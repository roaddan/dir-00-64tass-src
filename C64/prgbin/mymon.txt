
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib -i -L mymon.txt -o mymon.prg mymon.asm
; Fri Nov 14 01:15:30 2025

;Offset	;Hex		;Source

;******  Processing input file: mymon.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/lib/header-c64.asm

>0801	29 08		bcmd1          .word bcmd2         ;Adresse de la commande basic suivante.
>0803	01 00		               .word 1             ;Numero de la ligne Basic.
>0805	8f		               .byte $8F           ;Le token de la commande REM du Basic
>0806	20 50 52 4f	               .text " programmation assembleur sur c64."
>080a	47 52 41 4d 4d 41 54 49 4f 4e 20 41 53 53 45 4d
>081a	42 4c 45 55 52 20 53 55 52 20 43 36 34 2e
>0828	00		               .byte $00           ;Un zéro pour indiquer la fin de cette
>0829	44 08		bcmd2          .word bcmd3         ;Adresse de la commande basic suivante.
>082b	02 00		               .word 2             ;Numero de la ligne Basic.
>082d	8f		               .byte $8F           ;Le token de la commande REM du Basic
>082e	20 50 41 52	               .text " par daniel lafrance."
>0832	20 44 41 4e 49 45 4c 20 4c 41 46 52 41 4e 43 45
>0842	2e
>0843	00		               .byte $00           ;Un zéro pour indiquer la fin de cette
>0844	4f 08		bcmd3          .word bcmd4         ;Adresse de la commande basic suivante.
>0846	03 00		               .word 3             ;Numero de la ligne Basic.
>0848	9e		               .byte $9e           ;Le token de la commande SYS du Basic
>0849	30 32 31 32	               .text format("%05d",hpgmstart)
>084d	39
>084e	00		               .byte $00           ;Un zéro pour indiquer la fin de cette
>084f	00 00		bcmd4          .word $0000         ;L'adresse de la commande Basic suivante.
.0851	20 55 08	hpgmstart     jsr   main           ; Le programme principale doit s'appeler "main"
.0854	60		              rts                  ; ... doit se rerminer par un RTS.

;******  Return to file: mymon.asm

.0855			main
.0855	a9 93		                lda #147
.0857	20 d2 ff	                jsr chrout
.085a	20 ca cc	                jsr greetsmall
.085d	60		                rts
=$c1			tmp0            = $c1               ; used to return input, often holds end address
=$c3			tmp2            = $c3               ; usually holds start address
=$90			satus           = $90               ; kernal i/o status word
=$b7			fnlen           = $b7               ; length of current filename
=$b9			sadd            = $b9               ; current secondary address (official name sa)
=$ba			fa              = $ba               ; current device number
=$bb			fnadr           = $bb               ; pointer to current filename
=$c6			ndx             = $c6               ; number of characters in keyboard buffer
=$0277			keyd            = $0277             ; keyboard buffer
=$0316			bkvec           = $0316             ; brk instruction vector (official name cbinv)
>0100			acmd            .fill 1             ; addressing command
>0101			length          .fill 1             ; length of operand
>0102			mnemw           .fill 3             ; 3 letter mnemonic buffer
>0105			savx            .fill 1             ; 1 byte temp storage, often to save x register
>0106			opcode          .fill 1             ; current opcode for assembler/disassembler
>0107			upflg           .fill 1             ; flag: count up (bit 7 clear) or down (bit 7 set)
>0108			digcnt          .fill 1             ; digit count
>0109			indig           .fill 1             ; numeric value of single digit
>010a			numbit          .fill 1             ; numeric base of input
>010b			stash           .fill 2             ; 2-byte temp storage
>010d			u0aa0           .fill 10            ; work buffer
=$0117			u0aae           =*                  ; end of work buffer
>0117			stage           .fill 30            ; staging buffer for filename, search, etc.
=$0135			estage          =*                  ; end of staging buffer
>0200			inbuff          .fill 40            ; 40-character input buffer
=$0228			endin           =*                  ; end of input buffer
>0228			pch             .fill 1             ; program counter high byte
>0229			pcl             .fill 1             ; program counter low byte
>022a			sr              .fill 1             ; status register
>022b			acc             .fill 1             ; accumulator
>022c			xr              .fill 1             ; x register
>022d			yr              .fill 1             ; y register
>022e			sp              .fill 1             ; stack pointer
>022f			store           .fill 2             ; 2-byte temp storage
>0231			chrpnt          .fill 1             ; current position in input buffer
>0232			savy            .fill 1             ; temp storage, often to save y register
>0233			u9f             .fill 1             ; index into assembler work buffer
=$ff90			setmsg          = $ff90             ; set kernel message control flag
=$ff93			second          = $ff93             ; set secondary address after listen
=$ff96			tksa            = $ff96             ; send secondary address after talk
=$ffb1			listen          = $ffb1             ; command serial bus device to listen
=$ffb4			talk            = $ffb4             ; command serial bus device to talk
=$ffba			setlfs          = $ffba             ; set logical file parameters
=$ffbd			setnam          = $ffbd             ; set filename
=$ffa5			acptr           = $ffa5             ; input byte from serial bus
=$ffa8			ciout           = $ffa8             ; output byte to serial bus
=$ffab			untlk           = $ffab             ; command serial bus device to untalk
=$ffae			unlsn           = $ffae             ; command serial bus device to unlisten
=$ffc6			chkin           = $ffc6             ; define input channel
=$ffcc			clrchn          = $ffcc             ; restore default devices
=$ffcf			input           = $ffcf             ; input a character (official name chrin)
=$ffd2			chrout          = $ffd2             ; output a character
=$ffd5			load            = $ffd5             ; load from device
=$ffd8			save            = $ffd8             ; save to device
=$ffe1			stop            = $ffe1             ; check the stop key
=$ffe4			getin           = $ffe4             ; get a character
=49920			org             = $c3e0-$31-$af
.c300	20 39 c3	super           jsr setcolors
.c303	20 d5 cc	                jsr greeting
.c306	20 07 ca	                jsr crlf
.c309	a0 20		                ldy #msg4-msgbas    ; display "..sys "
.c30b	20 ae cc	                jsr sndmsg
.c30e	ad 4f cf	                lda supad           ; store entry point address in tmp0
.c311	85 c1		                sta tmp0
.c313	ad 50 cf	                lda supad+1
.c316	85 c2		                sta tmp0+1
.c318	20 38 cb	                jsr cvtdec          ; convert address to decimal
.c31b	a9 00		                lda #0
.c31d	a2 06		                ldx #6
.c31f	a0 03		                ldy #3
.c321	20 72 cb	                jsr nmprnt          ; print entry point address
.c324	20 07 ca	                jsr crlf
.c327	ad 4d cf	                lda linkad          ; set brk vector
.c32a	8d 16 03	                sta bkvec
.c32d	ad 4e cf	                lda linkad+1
.c330	8d 17 03	                sta bkvec+1
.c333	a9 80		                lda #$80            ; disable kernel control messages
.c335	20 90 ff	                jsr setmsg          ; and enable error messages
.c338	00		                brk
.c339			setcolors
.c339	08		                php
.c33a	48		                pha
.c33b	a9 0b		                lda     #$0b ;#$05
.c33d	8d 21 d0	                sta     screen
.c340	a9 0c		                lda     #$0c ; - 8
.c342	8d 20 d0	                sta     border
.c345	a9 01		                lda     #$01
.c347	8d 86 02	                sta     texte
.c34a	a9 93		                lda     #147
.c34c	20 d2 ff	                jsr     $ffd2
.c34f	a9 13		                lda     #19
.c351	20 d2 ff	                jsr     $ffd2
.c354	68		                pla
.c355	28		                plp
.c356	60		                rts
=53281			screen  =       53281
=53280			border  =       53280
=646			texte   =       646
.c357	a2 05		break           ldx #$05            ; pull registers off the stack
.c359	68		bstack          pla                 ; order: y,x,a,sr,pcl,pch
.c35a	9d 28 02	                sta pch,x           ; store in memory
.c35d	ca		                dex
.c35e	10 f9		                bpl bstack
.c360	d8		                cld                 ; disable bcd mode
.c361	ba		                tsx                 ; store stack pointer in memory
.c362	8e 2e 02	                stx sp
.c365	58		                cli                 ; enable interupts
.c366	a0 00		dsplyr          ldy #msg2-msgbas    ; display headers
.c368	20 9b cc	                jsr sndclr
.c36b	a9 3b		                lda #$3b            ; prefix registers with "; " to allow editing
.c36d	20 d2 ff	                jsr chrout
.c370	a9 20		                lda #$20
.c372	20 d2 ff	                jsr chrout
.c375	ad 28 02	                lda pch             ; print 2-byte program counter
.c378	20 20 ca	                jsr wrtwo
.c37b	a0 01		                ldy #1              ; start 1 byte after pc high byte
.c37d	b9 28 02	disj            lda pch,y           ; loop through rest of the registers
.c380	20 fc c9	                jsr wrbyte          ; print 1-byte register value
.c383	c8		                iny
.c384	c0 07		                cpy #7              ; there are a total of 5 registers to print
.c386	90 f5		                bcc disj
.c388	20 07 ca	strt            jsr crlf            ; new line
.c38b	a2 00		                ldx #0              ; point at start of input buffer
.c38d	8e 31 02	                stx chrpnt
.c390	20 cf ff	smove           jsr input           ; chrin kernal call to input a character
.c393	9d 00 02	                sta inbuff,x        ; store in input buffer
.c396	e8		                inx
.c397	e0 28		                cpx #endin-inbuff   ; error if buffer is full
.c399	b0 1c		                bcs error
.c39b	c9 0d		                cmp #$0d            ; keep reading until cr
.c39d	d0 f1		                bne smove
.c39f	a9 00		                lda #0              ; null-terminate input buffer
.c3a1	9d ff 01	                sta inbuff-1,x      ; (replacing the cr)
.c3a4	20 48 ca	st1             jsr getchr          ; get a character from the buffer
.c3a7	f0 df		                beq strt            ; start over if buffer is empty
.c3a9	c9 20		                cmp #$20            ; skip leading spaces
.c3ab	f0 f7		                beq st1
.c3ad	a2 16		s0              ldx #keytop-keyw    ; loop through valid command characters
.c3af	dd 11 cf	s1              cmp keyw,x          ; see if input character matches
.c3b2	f0 0b		                beq s2              ; command matched, dispatch it
.c3b4	ca		                dex                 ; no match, check next command
.c3b5	10 f8		                bpl s1              ; keep trying until we've checked them all
.c3b7	a0 1e		error           ldy #msg3-msgbas    ; display "?" to indicate error and go to new line
.c3b9	20 ae cc	                jsr sndmsg
.c3bc	4c 88 c3	                jmp strt            ; back to main loop
.c3bf	e0 13		s2              cpx #$13            ; last 3 commands in table are load/save/validate
.c3c1	b0 12		                bcs lsv             ;   which are handled by the same subroutine
.c3c3	e0 0f		                cpx #$0f            ; next 4 commands are base conversions
.c3c5	b0 14		                bcs cnvlnk          ;   which are handled by the same subroutine
.c3c7	8a		                txa                 ; remaining commands dispatch through vector table
.c3c8	0a		                asl a               ; multiply index of command by 2
.c3c9	aa		                tax                 ;   since table contains 2-byte addresses
.c3ca	bd 28 cf	                lda kaddr+1,x       ; push address from vector table onto stack
.c3cd	48		                pha                 ;   so that the rts from getpar will jump there
.c3ce	bd 27 cf	                lda kaddr,x
.c3d1	48		                pha
.c3d2	4c 29 c9	                jmp getpar          ; get the first parameter for the command
.c3d5	8d 32 02	lsv             sta savy            ; handle load/save/validate
.c3d8	4c ab c5	                jmp ld
.c3db	4c ed ca	cnvlnk          jmp convrt          ; handle base conversion
.c3de	20 d5 cc	exit            jsr greeting
.c3e1	6c 02 a0	                jmp ($a002)         ; jump to warm-start vector to reinitialize basic
.c3e4	b0 08		dsplym          bcs dspm11          ; start from previous end addr if no address given
.c3e6	20 62 ca	                jsr copy12          ; save start address in tmp2
.c3e9	20 29 c9	                jsr getpar          ; get end address in tmp0
.c3ec	90 06		                bcc dsmnew          ; did user specify one?
.c3ee	a9 0b		dspm11          lda #$0b            ; if not, show 12 lines by default
.c3f0	85 c1		                sta tmp0
.c3f2	d0 0e		                bne dspbyt          ; always true, but bne uses 1 byte less than jmp
.c3f4	20 6b ca	dsmnew          jsr sub12           ; end addr given, calc bytes between start and end
.c3f7	90 1e		                bcc merror          ; error if start is after end
.c3f9	a2 03		                ldx #3              ; divide by 8 (shift right 3 times)
.c3fb	46 c2		dspm01          lsr tmp0+1
.c3fd	66 c1		                ror tmp0
.c3ff	ca		                dex
.c400	d0 f9		                bne dspm01
.c402	20 e1 ff	dspbyt          jsr stop            ; check for stop key
.c405	f0 0d		                beq dspmx           ; exit early if pressed
.c407	20 87 c4	                jsr dispmem         ; display 1 line containing 8 bytes
.c40a	a9 08		                lda #8              ; increase start address by 8 bytes
.c40c	20 a1 ca	                jsr bumpad2
.c40f	20 79 ca	                jsr suba1           ; decrement line counter
.c412	b0 ee		                bcs dspbyt          ; show another line until it's < 0
.c414	4c 88 c3	dspmx           jmp strt            ; back to main loop
.c417	4c b7 c3	merror          jmp error           ; handle error
.c41a	20 b9 ca	altr            jsr copy1p          ; store first parameter in pc
.c41d	a0 00		                ldy #0              ; init counter
.c41f	20 29 c9	altr1           jsr getpar          ; get value for next register
.c422	b0 0a		                bcs altrx           ; exit early if no more values given
.c424	a5 c1		                lda tmp0            ; store in memory, offset from sr
.c426	99 2a 02	                sta sr,y            ; these locations will be transferred to the
.c429	c8		                iny                 ;   actual registers before exiting the monitor
.c42a	c0 05		                cpy #$05            ; have we updated all 5 yet?
.c42c	90 f1		                bcc altr1           ; if not, get next
.c42e	4c 88 c3	altrx           jmp strt            ; back to main loop
.c431	b0 13		altm            bcs altmx           ; exit if no parameter provided
.c433	20 62 ca	                jsr copy12          ; copy parameter to start address
.c436	a0 00		                ldy #0
.c438	20 29 c9	altm1           jsr getpar          ; get value for next byte of memory
.c43b	b0 09		                bcs altmx           ; if none given, exit early
.c43d	a5 c1		                lda tmp0            ; poke value into memory at start address + y
.c43f	91 c3		                sta (tmp2),y
.c441	c8		                iny                 ; next byte
.c442	c0 08		                cpy #8              ; have we read 8 bytes yet?
.c444	90 f2		                bcc altm1           ; if not, read the next one
.c446	a9 91		altmx           lda #$91            ; move cursor up
.c448	20 d2 ff	                jsr chrout
.c44b	20 87 c4	                jsr dispmem         ; re-display line to make ascii match hex
.c44e	4c 88 c3	                jmp strt            ; back to main loop
.c451	ae 2e 02	goto            ldx sp              ; load stack pointer from memory
.c454	9a		                txs                 ; save in sp register
.c455	20 b9 ca	goto2           jsr copy1p          ; copy provided address to pc
.c458	78		                sei                 ; disable interrupts
.c459	ad 28 02	                lda pch             ; push pc high byte on stack
.c45c	48		                pha
.c45d	ad 29 02	                lda pcl             ; push pc low byte on stack
.c460	48		                pha
.c461	ad 2a 02	                lda sr              ; push status byte on stack
.c464	48		                pha
.c465	ad 2b 02	                lda acc             ; load accumulator from memory
.c468	ae 2c 02	                ldx xr              ; load x from memory
.c46b	ac 2d 02	                ldy yr              ; load y from memory
.c46e	40		                rti                 ; return from interrupt (pops pc and sr)
.c46f	ae 2e 02	jsub            ldx sp              ; load stack pointer from memory
.c472	9a		                txs                 ; save value in sp register
.c473	20 55 c4	                jsr goto2           ; same as goto command
.c476	8c 2d 02	                sty yr              ; save y to memory
.c479	8e 2c 02	                stx xr              ; save x to memory
.c47c	8d 2b 02	                sta acc             ; save accumulator to memory
.c47f	08		                php                 ; push processor status on stack
.c480	68		                pla                 ; pull processor status into a
.c481	8d 2a 02	                sta sr              ; save processor status to memory
.c484	4c 66 c3	                jmp dsplyr          ; display registers
.c487	20 07 ca	dispmem         jsr crlf            ; new line
.c48a	a9 3e		                lda #">"            ; prefix > so memory can be edited in place
.c48c	20 d2 ff	                jsr chrout
.c48f	20 f2 c9	                jsr showad          ; show address of first byte on line
.c492	a0 00		                ldy #0
.c494	f0 03		                beq dmemgo          ; showad already printed a space after the address
.c496	20 ff c9	dmemlp          jsr space           ; print space between bytes
.c499	b1 c3		dmemgo          lda (tmp2),y        ; load byte from start address + y
.c49b	20 20 ca	                jsr wrtwo           ; output hex digits for byte
.c49e	c8		                iny                 ; next byte
.c49f	c0 08		                cpy #8              ; have we output 8 bytes yet?
.c4a1	90 f3		                bcc dmemlp          ; if not, output next byte
.c4a3	a0 28		                ldy #msg5-msgbas    ; if so, output : and turn on reverse video
.c4a5	20 ae cc	                jsr sndmsg          ;   before displaying ascii representation
.c4a8	a0 00		                ldy #0              ; back to first byte in line
.c4aa	b1 c3		dchar           lda (tmp2),y        ; load byte at start address + y
.c4ac	aa		                tax                 ; stash in x
.c4ad	29 bf		                and #$bf            ; clear 6th bit
.c4af	c9 22		                cmp #$22            ; is it a quote ("")?
.c4b1	f0 08		                beq ddot            ; if so, print . instead
.c4b3	8a		                txa                 ; if not, restore character
.c4b4	29 7f		                and #$7f            ; clear top bit
.c4b6	c9 20		                cmp #$20            ; is it a printable character (>= $20)?
.c4b8	8a		                txa                 ; restore character
.c4b9	b0 02		                bcs dchrok          ; if printable, output character
.c4bb	a9 2e		ddot            lda #$2e            ; if not, output '.' instaed
.c4bd	20 d2 ff	dchrok          jsr chrout
.c4c0	c8		                iny                 ; next byte
.c4c1	c0 08		                cpy #8              ; have we output 8 bytes yet?
.c4c3	90 e5		                bcc dchar           ; if not, output next byte
.c4c5	60		                rts
.c4c6	a9 00		compar          lda #0              ; bit 7 clear signals compare
>c4c8	2c		                .byte $2c           ; absolute bit opcode consumes next word (lda #$80)
.c4c9	a9 80		trans           lda #$80            ; bit 7 set signals transfer
.c4cb	8d 32 02	                sta savy            ; save compare/transfer flag in savy
.c4ce	a9 00		                lda #0              ; assume we're counting up (bit 7 clear)
.c4d0	8d 07 01	                sta upflg           ; save direction flag
.c4d3	20 c6 ca	                jsr getdif          ; get two addresses and calculate difference
.c4d6	b0 05		                bcs terror          ; carry set indicates error
.c4d8	20 29 c9	                jsr getpar          ; get destination address in tmp0
.c4db	90 03		                bcc tokay           ; carry set indicates error
.c4dd	4c b7 c3	terror          jmp error           ; handle error
.c4e0	2c 32 02	tokay           bit savy            ; transfer or compare?
.c4e3	10 27		                bpl compar1         ; high bit clear indicates compare
.c4e5	a5 c3		                lda tmp2            ; if it's a transfer, we must take steps
.c4e7	c5 c1		                cmp tmp0            ;   to avoid overwriting the source bytes before
.c4e9	a5 c4		                lda tmp2+1          ;   they have been transferred
.c4eb	e5 c2		                sbc tmp0+1          ; compare source (tmp2) to destination (tmp0)
.c4ed	b0 1d		                bcs compar1         ; and count up if source is before than desitnation
.c4ef	ad 2f 02	                lda store           ; otherwise, start at end and count down...
.c4f2	65 c1		                adc tmp0            ; add length (store) to desintation (tmp0)
.c4f4	85 c1		                sta tmp0            ; to calculate end of destination
.c4f6	ad 30 02	                lda store+1
.c4f9	65 c2		                adc tmp0+1
.c4fb	85 c2		                sta tmp0+1
.c4fd	a2 01		                ldx #1              ; change source pointer from beginning to end
.c4ff	bd 0b 01	tdown           lda stash,x         ; tmp2 = source end (stash)
.c502	95 c3		                sta tmp2,x
.c504	ca		                dex
.c505	10 f8		                bpl tdown
.c507	a9 80		                lda #$80            ; high bit set in upflg means count down
.c509	8d 07 01	                sta upflg
.c50c	20 07 ca	compar1         jsr crlf            ; new line
.c50f	a0 00		                ldy #0              ; no offset from pointer
.c511	20 e1 ff	tcloop          jsr stop            ; check for stop key
.c514	f0 31		                beq texit           ; exit if pressed
.c516	b1 c3		                lda (tmp2),y        ; load byte from source
.c518	2c 32 02	                bit savy            ; transfer or compare?
.c51b	10 02		                bpl compar2         ; skip store if comparing
.c51d	91 c1		                sta (tmp0),y        ; otherwise, store in destination
.c51f	d1 c1		compar2         cmp (tmp0),y        ; compare to destination
.c521	f0 03		                beq tmvad           ; don't show address if equal
.c523	20 f2 c9	                jsr showad          ; show address
.c526	2c 07 01	tmvad           bit upflg           ; counting up or down?
.c529	30 0b		                bmi tdecad          ; high bit set means we're counting down
.c52b	e6 c1		                inc tmp0            ; increment destination low byte
.c52d	d0 10		                bne tincok
.c52f	e6 c2		                inc tmp0+1          ; carry to high byte if necessary
.c531	d0 0c		                bne tincok
.c533	4c b7 c3	                jmp error           ; error if high byte overflowed
.c536	20 79 ca	tdecad          jsr suba1           ; decrement destination (tmp0)
.c539	20 ab ca	                jsr sub21           ; decrement source (tmp2)
.c53c	4c 42 c5	                jmp tmor
.c53f	20 9f ca	tincok          jsr adda2           ; increment source (tmp2)
.c542	20 8d ca	tmor            jsr sub13           ; decrement length
.c545	b0 ca		                bcs tcloop          ; loop until length is 0
.c547	4c 88 c3	texit           jmp strt            ; back to main loop
.c54a	20 c6 ca	hunt            jsr getdif          ; get start (tmp2) and end (tmp0) of haystack
.c54d	b0 59		                bcs herror          ; carry indicates error
.c54f	a0 00		                ldy #0
.c551	20 48 ca	                jsr getchr          ; get a single character
.c554	c9 27		                cmp #"'"            ; is it a single quote?
.c556	d0 16		                bne nostrh          ; if not, input needle as hex bytes
.c558	20 48 ca	                jsr getchr          ; if so, input needle as string
.c55b	c9 00		                cmp #0
.c55d	f0 49		                beq herror          ; error if needle isn't at least one byte
.c55f	99 17 01	hpar            sta stage,y         ; save char in staging area
.c562	c8		                iny
.c563	20 48 ca	                jsr getchr          ; get another char
.c566	f0 18		                beq htgo            ; if it's null start searching
.c568	c0 1e		                cpy #estage-stage   ; have we filled up the needle staging area?
.c56a	d0 f3		                bne hpar            ; if not, get another character
.c56c	f0 12		                beq htgo            ; if so, start searching
.c56e	20 26 c9	nostrh          jsr rdpar           ; read hex bytes if string not indicated
.c571	a5 c1		hlp             lda tmp0            ; save last read byte in staging area
.c573	99 17 01	                sta stage,y
.c576	c8		                iny                 ; get another hex byte
.c577	20 29 c9	                jsr getpar
.c57a	b0 04		                bcs htgo            ; if there is none, start searching
.c57c	c0 1e		                cpy #estage-stage   ; have we filled up the needle staging area?
.c57e	d0 f1		                bne hlp             ; if not, get another byte
.c580	8c 32 02	htgo            sty savy            ; save length of needle
.c583	20 07 ca	                jsr crlf            ; new line
.c586	a0 00		hscan           ldy #0
.c588	b1 c3		hlp3            lda (tmp2),y        ; get first byte in haystack
.c58a	d9 17 01	                cmp stage,y         ; compare it to first byte of needle
.c58d	d0 09		                bne hnoft           ; if it doesn't match, we haven't found anything
.c58f	c8		                iny                 ; if it does, check the next byte
.c590	cc 32 02	                cpy savy            ; have we reached the end of the needle?
.c593	d0 f3		                bne hlp3            ; if not, keep comparing bytes
.c595	20 f2 c9	                jsr showad          ; match found, show address
.c598	20 e1 ff	hnoft           jsr stop            ; no match, check for stop key
.c59b	f0 08		                beq hexit           ; exit prematurely if pressed
.c59d	20 9f ca	                jsr adda2           ; increment haystack pointer
.c5a0	20 8d ca	                jsr sub13           ; decrement haystack length
.c5a3	b0 e1		                bcs hscan           ; still more haystack? keep searching
.c5a5	4c 88 c3	hexit           jmp strt            ; back to main loop
.c5a8	4c b7 c3	herror          jmp error           ; handle error
.c5ab	a0 01		ld              ldy #1              ; default to reading from tape, device #1
.c5ad	84 ba		                sty fa
.c5af	84 b9		                sty sadd            ; default to secondary address #1
.c5b1	88		                dey
.c5b2	84 b7		                sty fnlen           ; start with an empty filename
.c5b4	84 90		                sty satus           ; clear status
.c5b6	a9 01		                lda #>stage         ; set filename pointer to staging buffer
.c5b8	85 bc		                sta fnadr+1
.c5ba	a9 17		                lda #<stage
.c5bc	85 bb		                sta fnadr
.c5be	20 48 ca	l1              jsr getchr          ; get a character
.c5c1	f0 59		                beq lshort          ; no filename given, try load or verify from tape
.c5c3	c9 20		                cmp #$20            ; skip leading spaces
.c5c5	f0 f7		                beq l1
.c5c7	c9 22		                cmp #$22            ; error if filename doesn't start with a quote
.c5c9	d0 16		                bne lerror
.c5cb	ae 31 02	                ldx chrpnt          ; load current char pointer into index reg
.c5ce	bd 00 02	l3              lda inbuff,x        ; load current char from buffer to accumulator
.c5d1	f0 49		                beq lshort          ; no filename given, try load or verify from tape
.c5d3	e8		                inx                 ; next char
.c5d4	c9 22		                cmp #$22            ; is it a quote?
.c5d6	f0 0c		                beq l8              ; if so, we've reached the end of the filename
.c5d8	91 bb		                sta (fnadr),y       ; if not, save character in filename buffer
.c5da	e6 b7		                inc fnlen           ; increment filename length
.c5dc	c8		                iny
.c5dd	c0 1e		                cpy #estage-stage   ; check whether buffer is full
.c5df	90 ed		                bcc l3              ; if not, get another character
.c5e1	4c b7 c3	lerror          jmp error           ; if so, handle error
.c5e4	8e 31 02	l8              stx chrpnt          ; set character pointer to the current index
.c5e7	20 48 ca	                jsr getchr          ; eat separator between filename and device #
.c5ea	f0 30		                beq lshort          ; no separator, try to load or verify from tape
.c5ec	20 29 c9	                jsr getpar          ; get device number
.c5ef	b0 2b		                bcs lshort          ; no device # given, try load or verify from tape
.c5f1	a5 c1		                lda tmp0            ; set device number for kernal routines
.c5f3	85 ba		                sta fa
.c5f5	20 29 c9	                jsr getpar          ; get start address for load or save in tmp0
.c5f8	b0 22		                bcs lshort          ; no start address, try to load or verify
.c5fa	20 62 ca	                jsr copy12          ; transfer start address to tmp2
.c5fd	20 29 c9	                jsr getpar          ; get end address for save in tmp0
.c600	b0 3d		                bcs ldaddr          ; no end address, try to load to given start addr
.c602	20 07 ca	                jsr crlf            ; new line
.c605	a6 c1		                ldx tmp0            ; put low byte of end address in x
.c607	a4 c2		                ldy tmp0+1          ; put high byte of end address in y
.c609	ad 32 02	                lda savy            ; confirm that we're doing a save
.c60c	c9 53		                cmp #"s"
.c60e	d0 d1		                bne lerror          ; if not, error due to too many params
.c610	a9 00		                lda #0
.c612	85 b9		                sta sadd            ; set secondary address to 0
.c614	a9 c3		                lda #tmp2           ; put addr of zero-page pointer to data in a
.c616	20 d8 ff	                jsr save            ; call kernal save routine
.c619	4c 88 c3	lsvxit          jmp strt            ; back to mainloop
.c61c	ad 32 02	lshort          lda savy            ; check which command we received
.c61f	c9 56		                cmp #"v"
.c621	f0 06		                beq loadit          ; we're doing a verify so don't set a to 0
.c623	c9 4c		                cmp #"l"
.c625	d0 ba		                bne lerror          ; error due to not enough params for save
.c627	a9 00		                lda #0              ; 0 in a signals load, anything else is verify
.c629	20 d5 ff	loadit          jsr load            ; call kernal load routine
.c62c	a5 90		                lda satus           ; get i/o status
.c62e	29 10		                and #$10            ; check bit 5 for checksum error
.c630	f0 e7		                beq lsvxit          ; if no error go back to mainloop
.c632	ad 32 02	                lda savy            ; ?? not sure what these two lines are for...
.c635	f0 aa		                beq lerror          ; ?? savy will never be 0, so why check?
.c637	a0 2a		                ldy #msg6-msgbas    ; display "error" if checksum didn't match
.c639	20 ae cc	                jsr sndmsg
.c63c	4c 88 c3	                jmp strt            ; back to mainloop
.c63f	a6 c3		ldaddr          ldx tmp2            ; load address low byte in x
.c641	a4 c4		                ldy tmp2+1          ; load address high byte in y
.c643	a9 00		                lda #0              ; 0 in a signals load
.c645	85 b9		                sta sadd            ; secondary addr 0 means load to addr in x and y
.c647	f0 d3		                beq lshort          ; execute load
.c649	20 c6 ca	fill            jsr getdif          ; start in tmp2, end in stash, length in store
.c64c	b0 59		                bcs aerror          ; carry set indicates error
.c64e	20 29 c9	                jsr getpar          ; get value to fill in tmp0
.c651	b0 54		                bcs aerror          ; carry set indicates error
.c653	20 48 ca	                jsr getchr          ; any more characters triggers an error
.c656	d0 4f		                bne aerror
.c658	a0 00		                ldy #0              ; no offset
.c65a	a5 c1		fillp           lda tmp0            ; load value to fill in accumulator
.c65c	91 c3		                sta (tmp2),y        ; store fill value in current address
.c65e	20 e1 ff	                jsr stop            ; check for stop key
.c661	f0 08		                beq fstart          ; if pressed, back to main loop
.c663	20 9f ca	                jsr adda2           ; increment address
.c666	20 8d ca	                jsr sub13           ; decrement length
.c669	b0 ef		                bcs fillp           ; keep going until length reaches 0
.c66b	4c 88 c3	fstart          jmp strt            ; back to main loop
.c66e	b0 37		assem           bcs aerror          ; error if no address given
.c670	20 62 ca	                jsr copy12          ; copy address to tmp2
.c673	a2 00		aget1           ldx #0
.c675	8e 0e 01	                stx u0aa0+1         ; clear byte that mnemonic gets shifted into
.c678	8e 08 01	                stx digcnt          ; clear digit count
.c67b	20 48 ca	aget2           jsr getchr          ; get a char
.c67e	d0 04		                bne almor           ; proceed if the character isn't null
.c680	e0 00		                cpx #0              ; it's null, have read a mnemonic yet?
.c682	f0 e7		                beq fstart          ; if not, silently go back to main loop
.c684	c9 20		almor           cmp #$20            ; skip leading spaces
.c686	f0 eb		                beq aget1
.c688	9d 02 01	                sta mnemw,x         ; put character in mnemonic buffer
.c68b	e8		                inx
.c68c	e0 03		                cpx #3              ; have we read 3 characters yet?
.c68e	d0 eb		                bne aget2           ; if not, get next character
.c690	ca		asqeez          dex                 ; move to previous char
.c691	30 17		                bmi aoprnd          ; if we're done with mnemonic, look for operand
.c693	bd 02 01	                lda mnemw,x         ; get current character
.c696	38		                sec                 ; pack 3-letter mnemonic into 2 bytes (15 bits)
.c697	e9 3f		                sbc #$3f            ; subtract $3f from ascii code so a-z = 2 to 27
.c699	a0 05		                ldy #$05            ; letters now fit in 5 bits; shift them out
.c69b	4a		ashift          lsr a               ;   into the first two bytes of the inst buffer
.c69c	6e 0e 01	                ror u0aa0+1         ; catch the low bit from accumulator in right byte
.c69f	6e 0d 01	                ror u0aa0           ; catch the low bit from right byte in left byte
.c6a2	88		                dey                 ; count down bits
.c6a3	d0 f6		                bne ashift          ; keep looping until we reach zero
.c6a5	f0 e9		                beq asqeez          ; unconditional branch to handle next char
.c6a7	4c b7 c3	aerror          jmp error           ; handle error
.c6aa	a2 02		aoprnd          ldx #2              ; mnemonic is in first two bytes so start at third
.c6ac	ad 08 01	ascan           lda digcnt          ; did we find address digits last time?
.c6af	d0 2d		                bne aform1          ; if so, look for mode chars
.c6b1	20 51 c9	                jsr rdval           ; otherwise, look for an address
.c6b4	f0 25		                beq aform0          ; we didn't find an address, look for characters
.c6b6	b0 ef		                bcs aerror          ; carry flag indicates error
.c6b8	a9 24		                lda #"$"
.c6ba	9d 0d 01	                sta u0aa0,x         ; prefix addresses with $
.c6bd	e8		                inx                 ; next position in buffer
.c6be	a0 04		                ldy #4              ; non-zero page addresses are 4 hex digits
.c6c0	ad 0a 01	                lda numbit          ; check numeric base in which address was given
.c6c3	c9 08		                cmp #8              ; for addresses given in octal or binary
.c6c5	90 05		                bcc aaddr           ;   use only the high byte to determine page
.c6c7	cc 08 01	                cpy digcnt          ; for decimal or hex, force non-zero page addressing
.c6ca	f0 06		                beq afill0          ;   if address was given with four digits or more
.c6cc	a5 c2		aaddr           lda tmp0+1          ; check whether high byte of address is zero
.c6ce	d0 02		                bne afill0          ; non-zero high byte means we're not in zero page
.c6d0	a0 02		                ldy #2              ; if it's in zero page, addr is 2 hex digits
.c6d2	a9 30		afill0          lda #$30            ; use 0 as placeholder for each hex digit in addr
.c6d4	9d 0d 01	afil0l          sta u0aa0,x         ; put placeholder in assembly buffer
.c6d7	e8		                inx                 ; move to next byte in buffer
.c6d8	88		                dey                 ; decrement number of remaining digits
.c6d9	d0 f9		                bne afil0l          ; loop until all digits have been placed
.c6db	ce 31 02	aform0          dec chrpnt          ; non-numeric input; back 1 char to see what it was
.c6de	20 48 ca	aform1          jsr getchr          ; get next character
.c6e1	f0 0e		                beq aescan          ; if there is none, we're finished scanning
.c6e3	c9 20		                cmp #$20            ; skip spaces
.c6e5	f0 c5		                beq ascan
.c6e7	9d 0d 01	                sta u0aa0,x         ; store character in assembly buffer
.c6ea	e8		                inx                 ; move to next byte in buffer
.c6eb	e0 0a		                cpx #u0aae-u0aa0    ; is instruction buffer full?
.c6ed	90 bd		                bcc ascan           ; if not, keep scanning
.c6ef	b0 b6		                bcs aerror          ; error if buffer is full
.c6f1	8e 2f 02	aescan          stx store           ; save number of bytes in assembly buffer
.c6f4	a2 00		                ldx #0              ; start at opcode $00 and check every one until
.c6f6	8e 06 01	                stx opcode          ;   we find one that matches our criteria
.c6f9	a2 00		atryop          ldx #0
.c6fb	8e 33 02	                stx u9f             ; reset index into work buffer
.c6fe	ad 06 01	                lda opcode
.c701	20 b8 c8	                jsr instxx          ; look up instruction format for current opcode
.c704	ae 00 01	                ldx acmd            ; save addressing command for later
.c707	8e 30 02	                stx store+1
.c70a	aa		                tax                 ; use current opcode as index
.c70b	bd cd ce	                lda mnemr,x         ; check right byte of compressed mnemonic
.c70e	20 df c7	                jsr chekop
.c711	bd 8d ce	                lda mneml,x         ; check left byte of compressed mnemonic
.c714	20 df c7	                jsr chekop
.c717	a2 06		                ldx #6              ; 6 possible characters to check against operand
.c719	e0 03		tryit           cpx #3              ; are we on character 3?
.c71b	d0 14		                bne trymod          ; if not, check operand characters
.c71d	ac 01 01	                ldy length          ; otherwise, check number of bytes in operand
.c720	f0 0f		                beq trymod          ; if zero, check operand characters
.c722	ad 00 01	tryad           lda acmd            ; otherwise, look for an address
.c725	c9 e8		                cmp #$e8            ; special case for relative addressing mode
.c727	a9 30		                lda #$30            ; '0' is the digit placeholder we're looking for
.c729	b0 1e		                bcs try4b           ; acmd >= $e8 indicates relative addressing
.c72b	20 dc c7	                jsr chek2b          ; acmd < $e8 indicates normal addressing
.c72e	88		                dey                 ; consume byte
.c72f	d0 f1		                bne tryad           ; check for 2 more digits if not zero-page
.c731	0e 00 01	trymod          asl acmd            ; shift a bit out of the addressing command
.c734	90 0e		                bcc ub4df           ; if it's zero, skip checking current character
.c736	bd 80 ce	                lda char1-1,x
.c739	20 df c7	                jsr chekop          ; otherwise first character against operand
.c73c	bd 86 ce	                lda char2-1,x       ; get second character to check
.c73f	f0 03		                beq ub4df           ; if it's zero, skip checking it
.c741	20 df c7	                jsr chekop          ; otherwise check it against hte operand
.c744	ca		ub4df           dex                 ; move to next character
.c745	d0 d2		                bne tryit           ; repeat tests
.c747	f0 06		                beq trybran
.c749	20 dc c7	try4b           jsr chek2b          ; check for 4 digit address placeholder
.c74c	20 dc c7	                jsr chek2b          ;   by checking for 2 digits twice
.c74f	ad 2f 02	trybran         lda store           ; get number of bytes in assembly buffer
.c752	cd 33 02	                cmp u9f             ; more bytes left to check?
.c755	f0 03		                beq abran           ; if not, we've found a match; build instruction
.c757	4c ec c7	                jmp bumpop          ; if so, this opcode doesn't match; try the next
.c75a	ac 01 01	abran           ldy length          ; get number of bytes in operand
.c75d	f0 32		                beq a1byte          ; if none, just output the opcode
.c75f	ad 30 02	                lda store+1         ; otherwise check the address format
.c762	c9 9d		                cmp #$9d            ; is it a relative branch?
.c764	d0 23		                bne objput          ; if not, skip relative branch calculation
.c766	a5 c1		                lda tmp0            ; calculate the difference between the current
.c768	e5 c3		                sbc tmp2            ;   address and the branch target (low byte)
.c76a	aa		                tax                 ; save it in x
.c76b	a5 c2		                lda tmp0+1          ; borrow from the high byte if necessary
.c76d	e5 c4		                sbc tmp2+1
.c76f	90 08		                bcc abback          ; if result is negative, we're branching back
.c771	d0 66		                bne serror          ; high bytes must be equal when branching forward
.c773	e0 82		                cpx #$82            ; difference between low bytes must be < 130
.c775	b0 62		                bcs serror          ; error if the address is too far away
.c777	90 08		                bcc abranx
.c779	a8		abback          tay                 ; when branching backward high byte of target must
.c77a	c8		                iny                 ;   be 1 less than high byte of current address
.c77b	d0 5c		                bne serror          ; if not, it's too far away
.c77d	e0 82		                cpx #$82            ; difference between low bytes must be < 130
.c77f	90 58		                bcc serror          ; if not, it's too far away
.c781	ca		abranx          dex                 ; adjust branch target relative to the
.c782	ca		                dex                 ;   instruction following this one
.c783	8a		                txa
.c784	ac 01 01	                ldy length          ; load length of operand
.c787	d0 03		                bne objp2           ; don't use the absolute address
.c789	b9 c0 00	objput          lda tmp0-1,y        ; get the operand
.c78c	91 c3		objp2           sta (tmp2),y        ; store it after the opcode
.c78e	88		                dey
.c78f	d0 f8		                bne objput          ; copy the other byte of operand if there is one
.c791	ad 06 01	a1byte          lda opcode          ; put opcode into instruction
.c794	91 c3		                sta (tmp2),y
.c796	20 07 ca	                jsr crlf            ; carriage return
.c799	a9 91		                lda #$91            ; back up one line
.c79b	20 d2 ff	                jsr chrout
.c79e	a0 30		                ldy #msg7-msgbas    ; "a " prefix
.c7a0	20 9b cc	                jsr sndclr          ; clear line
.c7a3	20 3a c8	                jsr dislin          ; disassemble the instruction we just assembled
.c7a6	ee 01 01	                inc length          ; instruction length = operand length + 1 byte
.c7a9	ad 01 01	                lda length          ;   for the opcode
.c7ac	20 a1 ca	                jsr bumpad2         ; increment address by length of instruction
.c7af	a9 41		                lda #"a"            ; stuff keyboard buffer with next assemble command:
.c7b1	8d 77 02	                sta keyd            ;   "a xxxx " where xxxx is the next address
.c7b4	a9 20		                lda #" "            ;   after the previously assembled instruction
.c7b6	8d 78 02	                sta keyd+1
.c7b9	8d 7d 02	                sta keyd+6
.c7bc	a5 c4		                lda tmp2+1          ; convert high byte of next address to hex
.c7be	20 30 ca	                jsr asctwo
.c7c1	8d 79 02	                sta keyd+2          ; put it in the keyboard buffer
.c7c4	8e 7a 02	                stx keyd+3
.c7c7	a5 c3		                lda tmp2            ; convert low byte of next address to hex
.c7c9	20 30 ca	                jsr asctwo
.c7cc	8d 7b 02	                sta keyd+4          ; put it in the keyboard buffer
.c7cf	8e 7c 02	                stx keyd+5
.c7d2	a9 07		                lda #7              ; set number of chars in keyboard buffer
.c7d4	85 c6		                sta ndx
.c7d6	4c 88 c3	                jmp strt            ; back to main loop
.c7d9	4c b7 c3	serror          jmp error           ; handle error
.c7dc	20 df c7	chek2b          jsr chekop          ; check two bytes against value in accumulator
.c7df	8e 05 01	chekop          stx savx            ; stash x
.c7e2	ae 33 02	                ldx u9f             ; get current index into work buffer
.c7e5	dd 0d 01	                cmp u0aa0,x         ; check whether this opcode matches the buffer
.c7e8	f0 0a		                beq opok            ;   matching so far, check the next criteria
.c7ea	68		                pla                 ; didn't match, so throw away return address
.c7eb	68		                pla                 ;   on the stack because we're starting over
.c7ec	ee 06 01	bumpop          inc opcode          ; check the next opcode
.c7ef	f0 e8		                beq serror          ; error if we tried every opcode and none fit
.c7f1	4c f9 c6	                jmp atryop          ; start over with new opcode
.c7f4	ee 33 02	opok            inc u9f             ; opcode matches so far; check the next criteria
.c7f7	ae 05 01	                ldx savx            ; restore x
.c7fa	60		                rts
.c7fb	b0 08		disass          bcs dis0ad          ; if no address was given, start from last address
.c7fd	20 62 ca	                jsr copy12          ; copy start address to tmp2
.c800	20 29 c9	                jsr getpar          ; get end address in tmp0
.c803	90 06		                bcc dis2ad          ; if one was given, skip default
.c805	a9 14		dis0ad          lda #$14            ; disassemble 14 bytes by default
.c807	85 c1		                sta tmp0            ; store length in tmp0
.c809	d0 05		                bne disgo           ; skip length calculation
.c80b	20 6b ca	dis2ad          jsr sub12           ; calculate number of bytes between start and end
.c80e	90 1f		                bcc derror          ; error if end address is before start address
.c810	20 95 cc	disgo           jsr cline           ; clear the current line
.c813	20 e1 ff	                jsr stop            ; check for stop key
.c816	f0 14		                beq disexit         ; exit early if pressed
.c818	20 32 c8	                jsr dsout1          ; output disassembly prefix ". "
.c81b	ee 01 01	                inc length
.c81e	ad 01 01	                lda length          ; add length of last instruction to start address
.c821	20 a1 ca	                jsr bumpad2
.c824	ad 01 01	                lda length          ; subtract length of last inst from end address
.c827	20 7b ca	                jsr suba2
.c82a	b0 e4		                bcs disgo
.c82c	4c 88 c3	disexit         jmp strt            ; back to mainloop
.c82f	4c b7 c3	derror          jmp error
.c832	a9 2e		dsout1          lda #"."            ; output ". " prefix to allow edit and reassemble
.c834	20 d2 ff	                jsr chrout
.c837	20 ff c9	                jsr space
.c83a	20 f2 c9	dislin          jsr showad          ; show the address of the instruction
.c83d	20 ff c9	                jsr space           ; insert a space
.c840	a0 00		                ldy #0              ; no offset
.c842	b1 c3		                lda (tmp2),y        ; load operand of current instruction
.c844	20 b8 c8	                jsr instxx          ; get mnemonic and addressing mode for opcode
.c847	48		                pha                 ; save index into mnemonic table
.c848	ae 01 01	                ldx length          ; get length of operand
.c84b	e8		                inx                 ; add 1 byte for opcode
.c84c	ca		dsbyt           dex                 ; decrement index
.c84d	10 0e		                bpl dshex           ; show hex for byte being disassembled
.c84f	8c 32 02	                sty savy            ; save index
.c852	a0 32		                ldy #msg8-msgbas    ; skip 3 spaces
.c854	20 ae cc	                jsr sndmsg
.c857	ac 32 02	                ldy savy            ; restore index
.c85a	4c 62 c8	                jmp nxbyt
.c85d	b1 c3		dshex           lda (tmp2),y        ; show hex for byte
.c85f	20 fc c9	                jsr wrbyte
.c862	c8		nxbyt           iny                 ; next byte
.c863	c0 03		                cpy #3              ; have we output 3 bytes yet?
.c865	90 e5		                bcc dsbyt           ; if not, loop
.c867	68		                pla                 ; restore index into mnemonic table
.c868	a2 03		                ldx #3              ; 3 letters in mnemonic
.c86a	20 00 c9	                jsr propxx          ; print mnemonic
.c86d	a2 06		                ldx #6              ; 6 possible address mode character combos
.c86f	e0 03		pradr1          cpx #3              ; have we checked the third combo yet?
.c871	d0 16		                bne pradr3          ; if so, output the leading characters
.c873	ac 01 01	                ldy length          ; get the length of the operand
.c876	f0 11		                beq pradr3          ; if it's zero, there's no operand to print
.c878	ad 00 01	pradr2          lda acmd            ; otherwise, get the addressing mode
.c87b	c9 e8		                cmp #$e8            ; check for relative addressing
.c87d	08		                php                 ; save result of check
.c87e	b1 c3		                lda (tmp2),y        ; get the operand
.c880	28		                plp                 ; restore result of check
.c881	b0 1d		                bcs relad           ; handle a relative address
.c883	20 20 ca	                jsr wrtwo           ; output digits from address
.c886	88		                dey
.c887	d0 ef		                bne pradr2          ; repeat for next byte of operand, if there is one
.c889	0e 00 01	pradr3          asl acmd            ; check whether addr mode uses the current char
.c88c	90 0e		                bcc pradr4          ; if not, skip it
.c88e	bd 80 ce	                lda char1-1,x       ; look up the first char in the table
.c891	20 d2 ff	                jsr chrout          ; print first char
.c894	bd 86 ce	                lda char2-1,x       ; look up the second char in the table
.c897	f0 03		                beq pradr4          ; if there's no second character, skip it
.c899	20 d2 ff	                jsr chrout          ; print second char
.c89c	ca		pradr4          dex                 ; next potential address mode character
.c89d	d0 d0		                bne pradr1          ; loop if we haven't checked them all yet
.c89f	60		                rts                 ; back to caller
.c8a0	20 ac c8	relad           jsr ub64d           ; calculate absolute address from relative
.c8a3	18		                clc
.c8a4	69 01		                adc #1              ; adjust address relative to next instruction
.c8a6	d0 01		                bne relend          ; don't increment high byte unless we overflowed
.c8a8	e8		                inx                 ; increment high byte
.c8a9	4c f6 c9	relend          jmp wraddr          ; print address
.c8ac	a6 c4		ub64d           ldx tmp2+1          ; get high byte of current address
.c8ae	a8		                tay                 ; is relative address positive or negative?
.c8af	10 01		                bpl relc2           ; if positive, leave high byte alone
.c8b1	ca		                dex                 ; if negative, decrement high byte
.c8b2	65 c3		relc2           adc tmp2            ; add relative address to low byte
.c8b4	90 01		                bcc relc3           ; if there's no carry, we're done
.c8b6	e8		                inx                 ; if there's a carry, increment the high byte
.c8b7	60		relc3           rts
.c8b8	a8		instxx          tay                 ; stash opcode in accumulator in y for later
.c8b9	4a		                lsr a               ; is opcode even or odd?
.c8ba	90 0b		                bcc ieven
.c8bc	4a		                lsr a
.c8bd	b0 17		                bcs err             ; invalid opcodes xxxxxx11
.c8bf	c9 22		                cmp #$22
.c8c1	f0 13		                beq err             ; invalid opcode 10001001
.c8c3	29 07		                and #$07            ; mask bits to 10000xxx
.c8c5	09 80		                ora #$80
.c8c7	4a		ieven           lsr a               ; lsb determines whether to use left/right nybble
.c8c8	aa		                tax                 ; get format index using remaining high bytes
.c8c9	bd 2f ce	                lda mode,x
.c8cc	b0 04		                bcs rtmode          ; look at left or right nybble based on carry bit
.c8ce	4a		                lsr a               ; if carry = 0, use left nybble
.c8cf	4a		                lsr a
.c8d0	4a		                lsr a
.c8d1	4a		                lsr a
.c8d2	29 0f		rtmode          and #$0f            ; if carry = 1, use right nybble
.c8d4	d0 04		                bne getfmt
.c8d6	a0 80		err             ldy #$80            ; substitute 10000000 for invalid opcodes
.c8d8	a9 00		                lda #0
.c8da	aa		getfmt          tax
.c8db	bd 73 ce	                lda mode2,x         ; lookup operand format using selected nybble
.c8de	8d 00 01	                sta acmd            ; save for later use
.c8e1	29 03		                and #$03            ; lower 2 bits indicate number of bytes in operand
.c8e3	8d 01 01	                sta length
.c8e6	98		                tya                 ; restore original opcode
.c8e7	29 8f		                and #$8f            ; mask bits to x000xxxx
.c8e9	aa		                tax                 ; save it
.c8ea	98		                tya                 ; restore original opcode
.c8eb	a0 03		                ldy #3
.c8ed	e0 8a		                cpx #$8a            ; check if opcode = 1xxx1010
.c8ef	f0 0b		                beq gtfm4
.c8f1	4a		gtfm2           lsr a               ; transform opcode into index for mnemonic table
.c8f2	90 08		                bcc gtfm4
.c8f4	4a		                lsr a               ; opcodes transformed as follows:
.c8f5	4a		gtfm3           lsr a               ; 1xxx1010->00101xxx
.c8f6	09 20		                ora #$20            ; xxxyyy01->00111xxx
.c8f8	88		                dey                 ; xxxyyy10->00111xxx
.c8f9	d0 fa		                bne gtfm3           ; xxxyy100->00110xxx
.c8fb	c8		                iny                 ; xxxxx000->000xxxxx
.c8fc	88		gtfm4           dey
.c8fd	d0 f2		                bne gtfm2
.c8ff	60		                rts
.c900	a8		propxx          tay                 ; use index in accumulator to look up mnemonic
.c901	b9 8d ce	                lda mneml,y         ;   and place a temporary copy in store
.c904	8d 2f 02	                sta store
.c907	b9 cd ce	                lda mnemr,y
.c90a	8d 30 02	                sta store+1
.c90d	a9 00		prmn1           lda #0              ; clear accumulator
.c90f	a0 05		                ldy #$05            ; shift 5 times
.c911	0e 30 02	prmn2           asl store+1         ; shift right byte
.c914	2e 2f 02	                rol store           ; rotate bits from right byte into left byte
.c917	2a		                rol a               ; rotate bits from left byte into accumulator
.c918	88		                dey                 ; next bit
.c919	d0 f6		                bne prmn2           ; loop until all bits shifted
.c91b	69 3f		                adc #$3f            ; calculate ascii code for letter by adding to '?'
.c91d	20 d2 ff	                jsr chrout          ; output letter
.c920	ca		                dex                 ; next letter
.c921	d0 ea		                bne prmn1           ; loop until all 3 letters are output
.c923	4c ff c9	                jmp space           ; output space
.c926	ce 31 02	rdpar           dec chrpnt          ; back up one char
.c929	20 51 c9	getpar          jsr rdval           ; read the value
.c92c	b0 17		                bcs gterr           ; carry set indicates error
.c92e	20 45 ca	                jsr gotchr          ; check previous character
.c931	d0 0a		                bne ckterm          ; if it's not null, check if it's a valid separator
.c933	ce 31 02	                dec chrpnt          ; back up one char
.c936	ad 08 01	                lda digcnt          ; get number of digits read
.c939	d0 11		                bne getgot          ; found some digits
.c93b	f0 0d		                beq gtnil           ; didn't find any digits
.c93d	c9 20		ckterm          cmp #$20            ; space or comma are valid separators
.c93f	f0 0b		                beq getgot          ; anything else is an error
.c941	c9 2c		                cmp #","
.c943	f0 07		                beq getgot
.c945	68		gterr           pla                 ; encountered error
.c946	68		                pla                 ; get rid of command vector pushed on stack
.c947	4c b7 c3	                jmp error           ; handle error
.c94a	38		gtnil           sec                 ; set carry to indicate no parameter found
>c94b	24		                .byte $24           ; bit zp opcode consumes next byte (clc)
.c94c	18		getgot          clc                 ; clear carry to indicate paremeter returned
.c94d	ad 08 01	                lda digcnt          ; return number of digits in a
.c950	60		                rts                 ; return to address pushed from vector table
.c951	a9 00		rdval           lda #0              ; clear temp
.c953	85 c1		                sta tmp0
.c955	85 c2		                sta tmp0+1
.c957	8d 08 01	                sta digcnt          ; clear digit counter
.c95a	8a		                txa                 ; save x and y
.c95b	48		                pha
.c95c	98		                tya
.c95d	48		                pha
.c95e	20 48 ca	rdvmor          jsr getchr          ; get next character from input buffer
.c961	f0 1e		                beq rdnilk          ; null at end of buffer
.c963	c9 20		                cmp #$20            ; skip spaces
.c965	f0 f7		                beq rdvmor
.c967	a2 03		                ldx #3              ; check numeric base [$+&%]
.c969	dd 20 cf	gnmode          cmp hikey,x
.c96c	f0 07		                beq gotmod          ; got a match, set up base
.c96e	ca		                dex
.c96f	10 f8		                bpl gnmode          ; check next base
.c971	e8		                inx                 ; default to hex
.c972	ce 31 02	                dec chrpnt          ; back up one character
.c975	bc 45 cf	gotmod          ldy modtab,x        ; get base value
.c978	bd 49 cf	                lda lentab,x        ; get bits per digit
.c97b	8d 0a 01	                sta numbit          ; store bits per digit
.c97e	20 48 ca	nudig           jsr getchr          ; get next char in a
.c981	f0 63		rdnilk          beq rdnil           ; end of number if no more characters
.c983	38		                sec
.c984	e9 30		                sbc #$30            ; subtract ascii value of 0 to get numeric value
.c986	90 5e		                bcc rdnil           ; end of number if character was less than 0
.c988	c9 0a		                cmp #$0a
.c98a	90 06		                bcc digmor          ; not a hex digit if less than a
.c98c	e9 07		                sbc #$07            ; 7 chars between ascii 9 and a, so subtract 7
.c98e	c9 10		                cmp #$10            ; end of number if char is greater than f
.c990	b0 54		                bcs rdnil
.c992	8d 09 01	digmor          sta indig           ; store the digit
.c995	cc 09 01	                cpy indig           ; compare base with the digit
.c998	90 4a		                bcc rderr           ; error if the digit >= the base
.c99a	f0 48		                beq rderr
.c99c	ee 08 01	                inc digcnt          ; increment the number of digits
.c99f	c0 0a		                cpy #10
.c9a1	d0 0a		                bne nodecm          ; skip the next part if not using base 10
.c9a3	a2 01		                ldx #1
.c9a5	b5 c1		declp1          lda tmp0,x          ; stash the previous 16-bit value for later use
.c9a7	9d 0b 01	                sta stash,x
.c9aa	ca		                dex
.c9ab	10 f8		                bpl declp1
.c9ad	ae 0a 01	nodecm          ldx numbit          ; number of bits to shift
.c9b0	06 c1		times2          asl tmp0            ; shift 16-bit value by specified number of bits
.c9b2	26 c2		                rol tmp0+1
.c9b4	b0 2e		                bcs rderr           ; error if we overflowed 16 bits
.c9b6	ca		                dex
.c9b7	d0 f7		                bne times2          ; shift remaining bits
.c9b9	c0 0a		                cpy #10
.c9bb	d0 18		                bne nodec2          ; skip the next part if not using base 10
.c9bd	0e 0b 01	                asl stash           ; shift the previous 16-bit value one bit left
.c9c0	2e 0c 01	                rol stash+1
.c9c3	b0 1f		                bcs rderr           ; error if we overflowed 16 bits
.c9c5	ad 0b 01	                lda stash           ; add shifted previous value to current value
.c9c8	65 c1		                adc tmp0
.c9ca	85 c1		                sta tmp0
.c9cc	ad 0c 01	                lda stash+1
.c9cf	65 c2		                adc tmp0+1
.c9d1	85 c2		                sta tmp0+1
.c9d3	b0 0f		                bcs rderr           ; error if we overflowed 16 bits
.c9d5	18		nodec2          clc
.c9d6	ad 09 01	                lda indig           ; load current digit
.c9d9	65 c1		                adc tmp0            ; add current digit to low byte
.c9db	85 c1		                sta tmp0            ; and store result back in low byte
.c9dd	8a		                txa                 ; a=0
.c9de	65 c2		                adc tmp0+1          ; add carry to high byte
.c9e0	85 c2		                sta tmp0+1          ; and store result back in high byte
.c9e2	90 9a		                bcc nudig           ; get next digit if we didn't overflow
.c9e4	38		rderr           sec                 ; set carry to indicate error
>c9e5	24		                .byte $24           ; bit zp opcode consumes next byte (clc)
.c9e6	18		rdnil           clc                 ; clear carry to indicate success
.c9e7	8c 0a 01	                sty numbit          ; save base of number
.c9ea	68		                pla                 ; restore x and y
.c9eb	a8		                tay
.c9ec	68		                pla
.c9ed	aa		                tax
.c9ee	ad 08 01	                lda digcnt          ; return number of digits in a
.c9f1	60		                rts
.c9f2	a5 c3		showad          lda tmp2
.c9f4	a6 c4		                ldx tmp2+1
.c9f6	48		wraddr          pha                 ; save low byte
.c9f7	8a		                txa                 ; put high byte in a
.c9f8	20 20 ca	                jsr wrtwo           ; output high byte
.c9fb	68		                pla                 ; restore low byte
.c9fc	20 20 ca	wrbyte          jsr wrtwo           ; output byte in a
.c9ff	a9 20		space           lda #$20            ; output space
.ca01	d0 0f		                bne flip
.ca03	c9 0d		chout           cmp #$0d            ; output char with special handling of cr
.ca05	d0 0b		                bne flip
.ca07	a9 0d		crlf            lda #$0d            ; load cr in a
.ca09	24 13		                bit $13             ; check default channel
.ca0b	10 05		                bpl flip            ; if high bit is clear output cr only
.ca0d	20 d2 ff	                jsr chrout          ; otherwise output cr+lf
.ca10	a9 0a		                lda #$0a            ; output lf
.ca12	4c d2 ff	flip            jmp chrout
.ca15	20 07 ca	fresh           jsr crlf            ; output cr
.ca18	a9 20		                lda #$20            ; load space in a
.ca1a	20 d2 ff	                jsr chrout
.ca1d	4c 9e cc	                jmp snclr
.ca20	8e 05 01	wrtwo           stx savx            ; save x
.ca23	20 30 ca	                jsr asctwo          ; get hex chars for byte in x (lower) and a (upper)
.ca26	20 d2 ff	                jsr chrout          ; output upper nybble
.ca29	8a		                txa                 ; transfer lower to a
.ca2a	ae 05 01	                ldx savx            ; restore x
.ca2d	4c d2 ff	                jmp chrout          ; output lower nybble
.ca30	48		asctwo          pha                 ; save byte
.ca31	20 3a ca	                jsr ascii           ; do low nybble
.ca34	aa		                tax                 ; save in x
.ca35	68		                pla                 ; restore byte
.ca36	4a		                lsr a               ; shift upper nybble down
.ca37	4a		                lsr a
.ca38	4a		                lsr a
.ca39	4a		                lsr a
.ca3a	29 0f		ascii           and #$0f            ; clear upper nibble
.ca3c	c9 0a		                cmp #$0a            ; if less than a, skip next step
.ca3e	90 02		                bcc asc1
.ca40	69 06		                adc #6              ; skip ascii chars between 9 and a
.ca42	69 30		asc1            adc #$30            ; add ascii char 0 to value
.ca44	60		                rts
.ca45	ce 31 02	gotchr          dec chrpnt
.ca48	8e 05 01	getchr          stx savx
.ca4b	ae 31 02	                ldx chrpnt          ; get pointer to next char
.ca4e	bd 00 02	                lda inbuff,x        ; load next char in a
.ca51	f0 06		                beq nochar          ; null, :, or ? signal end of buffer
.ca53	c9 3a		                cmp #":"
.ca55	f0 02		                beq nochar
.ca57	c9 3f		                cmp #"?"
.ca59	08		nochar          php
.ca5a	ee 31 02	                inc chrpnt          ; next char
.ca5d	ae 05 01	                ldx savx
.ca60	28		                plp                 ; z flag will signal last character
.ca61	60		                rts
.ca62	a5 c1		copy12          lda tmp0            ; low byte
.ca64	85 c3		                sta tmp2
.ca66	a5 c2		                lda tmp0+1          ; high byte
.ca68	85 c4		                sta tmp2+1
.ca6a	60		                rts
.ca6b	38		sub12           sec
.ca6c	a5 c1		                lda tmp0            ; subtract low byte
.ca6e	e5 c3		                sbc tmp2
.ca70	85 c1		                sta tmp0
.ca72	a5 c2		                lda tmp0+1
.ca74	e5 c4		                sbc tmp2+1          ; subtract high byte
.ca76	85 c2		                sta tmp0+1
.ca78	60		                rts
.ca79	a9 01		suba1           lda #1              ; shortcut to decrement by 1
.ca7b	8d 05 01	suba2           sta savx            ; subtrahend in accumulator
.ca7e	38		                sec
.ca7f	a5 c1		                lda tmp0            ; minuend in low byte
.ca81	ed 05 01	                sbc savx
.ca84	85 c1		                sta tmp0
.ca86	a5 c2		                lda tmp0+1          ; borrow from high byte
.ca88	e9 00		                sbc #0
.ca8a	85 c2		                sta tmp0+1
.ca8c	60		                rts
.ca8d	38		sub13           sec
.ca8e	ad 2f 02	                lda store
.ca91	e9 01		                sbc #1              ; decrement low byte
.ca93	8d 2f 02	                sta store
.ca96	ad 30 02	                lda store+1
.ca99	e9 00		                sbc #0              ; borrow from high byte
.ca9b	8d 30 02	                sta store+1
.ca9e	60		                rts
.ca9f	a9 01		adda2           lda #1              ; shortcut to increment by 1
.caa1	18		bumpad2         clc
.caa2	65 c3		                adc tmp2            ; add value in accumulator to low byte
.caa4	85 c3		                sta tmp2
.caa6	90 02		                bcc bumpex
.caa8	e6 c4		                inc tmp2+1          ; carry to high byte
.caaa	60		bumpex          rts
.caab	38		sub21           sec
.caac	a5 c3		                lda tmp2            ; decrement low byte
.caae	e9 01		                sbc #1
.cab0	85 c3		                sta tmp2
.cab2	a5 c4		                lda tmp2+1          ; borrow from high byte
.cab4	e9 00		                sbc #0
.cab6	85 c4		                sta tmp2+1
.cab8	60		                rts
.cab9	b0 0a		copy1p          bcs cpy1px          ; do nothing if parameter is empty
.cabb	a5 c1		                lda tmp0            ; copy low byte
.cabd	a4 c2		                ldy tmp0+1          ; copy high byte
.cabf	8d 29 02	                sta pcl
.cac2	8c 28 02	                sty pch
.cac5	60		cpy1px          rts
.cac6	b0 23		getdif          bcs gdifx           ; exit with error if no parameter given
.cac8	20 62 ca	                jsr copy12          ; save start address in tmp2
.cacb	20 29 c9	                jsr getpar          ; get end address in tmp0
.cace	b0 1b		                bcs gdifx           ; exit with error if no parameter given
.cad0	a5 c1		                lda tmp0            ; save end address in stash
.cad2	8d 0b 01	                sta stash
.cad5	a5 c2		                lda tmp0+1
.cad7	8d 0c 01	                sta stash+1
.cada	20 6b ca	                jsr sub12           ; subtract start address from end address
.cadd	a5 c1		                lda tmp0
.cadf	8d 2f 02	                sta store           ; save difference in store
.cae2	a5 c2		                lda tmp0+1
.cae4	8d 30 02	                sta store+1
.cae7	90 02		                bcc gdifx           ; error if start address is after end address
.cae9	18		                clc                 ; clear carry to indicate success
>caea	24		                .byte $24           ; bit zp opcode consumes next byte (sec)
.caeb	38		gdifx           sec                 ; set carry to indicate error
.caec	60		                rts
.caed	20 26 c9	convrt          jsr rdpar           ; read a parameter
.caf0	20 15 ca	                jsr fresh           ; next line and clear
.caf3	a9 24		                lda #"$"            ; output $ sigil for hex
.caf5	20 d2 ff	                jsr chrout
.caf8	a5 c1		                lda tmp0            ; load the 16-bit value entered
.cafa	a6 c2		                ldx tmp0+1
.cafc	20 f6 c9	                jsr wraddr          ; print it in 4 hex digits
.caff	20 15 ca	                jsr fresh
.cb02	a9 2b		                lda #"+"            ; output + sigil for decimal
.cb04	20 d2 ff	                jsr chrout
.cb07	20 38 cb	                jsr cvtdec          ; convert to bcd using hardware mode
.cb0a	a9 00		                lda #0              ; clear digit counter
.cb0c	a2 06		                ldx #6              ; max digits + 1
.cb0e	a0 03		                ldy #3              ; bits per digit - 1
.cb10	20 72 cb	                jsr nmprnt          ; print result without leading zeros
.cb13	20 15 ca	                jsr fresh           ; next line and clear
.cb16	a9 26		                lda #"&"            ; print & sigil for octal
.cb18	20 d2 ff	                jsr chrout
.cb1b	a9 00		                lda #0              ; clear digit counter
.cb1d	a2 08		                ldx #8              ; max digits + 1
.cb1f	a0 02		                ldy #2              ; bits per digit - 1
.cb21	20 61 cb	                jsr prinum          ; output number
.cb24	20 15 ca	                jsr fresh           ; next line and clear
.cb27	a9 25		                lda #"%"            ; print % sigil for binary
.cb29	20 d2 ff	                jsr chrout
.cb2c	a9 00		                lda #0              ; clear digit counter
.cb2e	a2 18		                ldx #$18            ; max digits + 1
.cb30	a0 00		                ldy #0              ; bits per digit - 1
.cb32	20 61 cb	                jsr prinum          ; output number
.cb35	4c 88 c3	                jmp strt            ; back to mainloop
.cb38	20 62 ca	cvtdec          jsr copy12          ; copy value from tmp0 to tmp2
.cb3b	a9 00		                lda #0
.cb3d	a2 02		                ldx #2              ; clear 3 bytes in work buffer
.cb3f	9d 0d 01	decml1          sta u0aa0,x
.cb42	ca		                dex
.cb43	10 fa		                bpl decml1
.cb45	a0 10		                ldy #16             ; 16 bits in input
.cb47	08		                php                 ; save status register
.cb48	78		                sei                 ; make sure no interrupts occur with bcd enabled
.cb49	f8		                sed
.cb4a	06 c3		decml2          asl tmp2            ; rotate bytes out of input low byte
.cb4c	26 c4		                rol tmp2+1          ; .. into high byte and carry bit
.cb4e	a2 02		                ldx #2              ; process 3 bytes
.cb50	bd 0d 01	decdbl          lda u0aa0,x         ; load current value of byte
.cb53	7d 0d 01	                adc u0aa0,x         ; add it to itself plus the carry bit
.cb56	9d 0d 01	                sta u0aa0,x         ; store it back in the same location
.cb59	ca		                dex                 ; decrement byte counter
.cb5a	10 f4		                bpl decdbl          ; loop until all bytes processed
.cb5c	88		                dey                 ; decrement bit counter
.cb5d	d0 eb		                bne decml2          ; loop until all bits processed
.cb5f	28		                plp                 ; restore processor status
.cb60	60		                rts
.cb61	48		prinum          pha                 ; save accumulator
.cb62	a5 c1		                lda tmp0            ; copy input low byte to work buffer
.cb64	8d 0f 01	                sta u0aa0+2
.cb67	a5 c2		                lda tmp0+1          ; copy input high byte to work buffer
.cb69	8d 0e 01	                sta u0aa0+1
.cb6c	a9 00		                lda #0              ; clear overflow byte in work buffer
.cb6e	8d 0d 01	                sta u0aa0
.cb71	68		                pla                 ; restore accumulator
.cb72	8d 08 01	nmprnt          sta digcnt          ; number of digits in accumulator
.cb75	8c 0a 01	                sty numbit          ; bits per digit passed in y register
.cb78	ac 0a 01	digout          ldy numbit          ; get bits to process
.cb7b	a9 00		                lda #0              ; clear accumulator
.cb7d	0e 0f 01	rolbit          asl u0aa0+2         ; shift bits out of low byte
.cb80	2e 0e 01	                rol u0aa0+1         ; ... into high byte
.cb83	2e 0d 01	                rol u0aa0           ; ... into overflow byte
.cb86	2a		                rol a               ; ... into accumulator
.cb87	88		                dey                 ; decrement bit counter
.cb88	10 f3		                bpl rolbit          ; loop until all bits processed
.cb8a	a8		                tay                 ; check whether accumulator is 0
.cb8b	d0 09		                bne nzero           ; if not, print it
.cb8d	e0 01		                cpx #1              ; have we output the max number of digits?
.cb8f	f0 05		                beq nzero           ; if not, print it
.cb91	ac 08 01	                ldy digcnt          ; how many digits have we output?
.cb94	f0 08		                beq zersup          ; skip output if digit is 0
.cb96	ee 08 01	nzero           inc digcnt          ; increment digit counter
.cb99	09 30		                ora #$30            ; add numeric value to ascii '0' to get ascii char
.cb9b	20 d2 ff	                jsr chrout          ; output character
.cb9e	ca		zersup          dex                 ; decrement number of leading zeros
.cb9f	d0 d7		                bne digout          ; next digit
.cba1	60		                rts
.cba2	d0 03		dstat           bne chgdev          ; if device address was given, use it
.cba4	a2 08		                ldx #8              ; otherwise, default to 8
>cba6	2c		                .byte $2c           ; absolute bit opcode consumes next word (ldx tmp0)
.cba7	a6 c1		chgdev          ldx tmp0            ; load device address from parameter
.cba9	e0 04		                cpx #4              ; make sure device address is in range 4-31
.cbab	90 58		                bcc ioerr
.cbad	e0 20		                cpx #32
.cbaf	b0 54		                bcs ioerr
.cbb1	86 c1		                stx tmp0
.cbb3	a9 00		                lda #0              ; clear status
.cbb5	85 90		                sta satus
.cbb7	85 b7		                sta fnlen           ; empty filename
.cbb9	20 48 ca	                jsr getchr          ; get next character
.cbbc	f0 24		                beq instat1         ; null, display status
.cbbe	ce 31 02	                dec chrpnt          ; back up 1 char
.cbc1	c9 24		                cmp #"$"            ; $, display directory
.cbc3	f0 43		                beq direct
.cbc5	a5 c1		                lda tmp0            ; command specified device to listen
.cbc7	20 b1 ff	                jsr listen
.cbca	a9 6f		                lda #$6f            ; secondary address 15 (only low nybble used)
.cbcc	20 93 ff	                jsr second
.cbcf	ae 31 02	dcomd           ldx chrpnt          ; get next character from buffer
.cbd2	ee 31 02	                inc chrpnt
.cbd5	bd 00 02	                lda inbuff,x
.cbd8	f0 05		                beq instat          ; break out of loop if it's null
.cbda	20 a8 ff	                jsr ciout           ; otherwise output it to the serial bus
.cbdd	90 f0		                bcc dcomd           ; unconditional loop: ciout clears carry before rts
.cbdf	20 ae ff	instat          jsr unlsn           ; command device to unlisten
.cbe2	20 07 ca	instat1         jsr crlf            ; new line
.cbe5	a5 c1		                lda tmp0            ; load device address
.cbe7	20 b4 ff	                jsr talk            ; command device to talk
.cbea	a9 6f		                lda #$6f            ; secondary address 15 (only low nybble used)
.cbec	20 96 ff	                jsr tksa
.cbef	20 a5 ff	rdstat          jsr acptr           ; read byte from serial bus
.cbf2	20 d2 ff	                jsr chrout          ; print it
.cbf5	c9 0d		                cmp #$0d            ; if the byte is cr, exit loop
.cbf7	f0 06		                beq dexit
.cbf9	a5 90		                lda satus           ; check status
.cbfb	29 bf		                and #$bf            ; ignore eoi bit
.cbfd	f0 f0		                beq rdstat          ; if no errors, read next byte
.cbff	20 ab ff	dexit           jsr untlk           ; command device to stop talking
.cc02	4c 88 c3	                jmp strt            ; back to mainloop
.cc05	4c b7 c3	ioerr           jmp error           ; handle error
.cc08	a5 c1		direct          lda tmp0            ; load device address
.cc0a	20 b1 ff	                jsr listen          ; command device to listen
.cc0d	a9 f0		                lda #$f0            ; secondary address 0 (only low nybble used)
.cc0f	20 93 ff	                jsr second
.cc12	ae 31 02	                ldx chrpnt          ; get index of next character
.cc15	bd 00 02	dir2            lda inbuff,x        ; get next character from buffer
.cc18	f0 06		                beq dir3            ; break if it's null
.cc1a	20 a8 ff	                jsr ciout           ; send character to device
.cc1d	e8		                inx                 ; increment characer index
.cc1e	d0 f5		                bne dir2            ; loop if it hasn't wrapped to zero
.cc20	20 ae ff	dir3            jsr unlsn           ; command device to unlisten
.cc23	20 07 ca	                jsr crlf            ; new line
.cc26	a5 c1		                lda tmp0            ; load device address
.cc28	48		                pha                 ; save on stack
.cc29	20 b4 ff	                jsr talk            ; command device to talk
.cc2c	a9 60		                lda #$60            ; secondary address 0 (only low nybble used)
.cc2e	20 96 ff	                jsr tksa
.cc31	a0 03		                ldy #3              ; read 3 16-bit values from device
.cc33	8c 2f 02	dirlin          sty store           ;   ignore the first 2; 3rd is file size
.cc36	20 a5 ff	dlink           jsr acptr           ; read low byte from device
.cc39	85 c1		                sta tmp0            ; store it
.cc3b	a5 90		                lda satus           ; check status
.cc3d	d0 44		                bne drexit          ; exit if error or eof occurred
.cc3f	20 a5 ff	                jsr acptr           ; read high byte from device
.cc42	85 c2		                sta tmp0+1          ; store it
.cc44	a5 90		                lda satus           ; check status
.cc46	d0 3b		                bne drexit          ; exit if error or eof cocurred
.cc48	ce 2f 02	                dec store           ; decrement byte count
.cc4b	d0 e9		                bne dlink           ; loop if bytes remain
.cc4d	20 38 cb	                jsr cvtdec          ; convert last 16-bit value to decimal
.cc50	a9 00		                lda #0              ; clear digit count
.cc52	a2 06		                ldx #6              ; max 6 digits
.cc54	a0 03		                ldy #3              ; 3 bits per digit
.cc56	20 72 cb	                jsr nmprnt          ; output number
.cc59	a9 20		                lda #" "            ; output space
.cc5b	20 d2 ff	                jsr chrout
.cc5e	20 a5 ff	dname           jsr acptr           ; get a filename character from the device
.cc61	f0 0a		                beq dmore           ; if it's null, break out of loop
.cc63	a6 90		                ldx satus           ; check for errors or eof
.cc65	d0 1c		                bne drexit          ; if found exit early
.cc67	20 d2 ff	                jsr chrout          ; output character
.cc6a	18		                clc
.cc6b	90 f1		                bcc dname           ; unconditional branch to read next char
.cc6d	20 07 ca	dmore           jsr crlf
.cc70	20 e1 ff	                jsr stop            ; check for stop key
.cc73	f0 0e		                beq drexit          ; exit early if pressed
.cc75	20 e4 ff	                jsr getin           ; pause if a key was pressed
.cc78	f0 05		                beq nopaws
.cc7a	20 e4 ff	paws            jsr getin           ; wait until another key is pressed
.cc7d	f0 fb		                beq paws
.cc7f	a0 02		nopaws          ldy #2
.cc81	d0 b0		                bne dirlin          ; unconditional branch to read next file
.cc83	20 ab ff	drexit          jsr untlk           ; command device to untalk
.cc86	68		                pla                 ; restore accumulator
.cc87	20 b1 ff	                jsr listen          ; command device to listen
.cc8a	a9 e0		                lda #$e0            ; secondary address 0 (only low nybble is used)
.cc8c	20 93 ff	                jsr second
.cc8f	20 ae ff	                jsr unlsn           ; command device to unlisten
.cc92	4c 88 c3	                jmp strt            ; back to mainloop
.cc95	20 07 ca	cline           jsr crlf            ; send cr+lf
.cc98	4c 9e cc	                jmp snclr           ; clear line
.cc9b	20 ae cc	sndclr          jsr sndmsg
.cc9e	a0 28		snclr           ldy #$28            ; loop 40 times
.cca0	a9 20		snclp           lda #$20            ; output space character
.cca2	20 d2 ff	                jsr chrout
.cca5	a9 14		                lda #$14            ; output delete character
.cca7	20 d2 ff	                jsr chrout
.ccaa	88		                dey
.ccab	d0 f3		                bne snclp
.ccad	60		                rts
.ccae	b9 09 cd	sndmsg          lda msgbas,y        ; y contains offset in msg table
.ccb1	08		                php
.ccb2	29 7f		                and #$7f            ; strip high bit before output
.ccb4	20 03 ca	                jsr chout
.ccb7	c8		                iny
.ccb8	28		                plp
.ccb9	10 f3		                bpl sndmsg          ; loop until high bit is set
.ccbb	60		                rts
.ccbc	b9 3e cd	sndtxt          lda txtptr,y         ; y contains offset in msg table
.ccbf	08		                php
.ccc0	29 7f		                and #$7f            ; strip high bit before output
.ccc2	20 03 ca	                jsr chout
.ccc5	c8		                iny
.ccc6	28		                plp
.ccc7	10 f3		                bpl sndtxt          ; loop until high bit is set
.ccc9	60		                rts
.ccca	48		greetsmall      pha
.cccb	98		                tya
.cccc	48		                pha
.cccd	a0 01		                ldy     #txt0-txtptr+1
.cccf	20 bc cc	                jsr     sndtxt
.ccd2	4c dd cc	                jmp     greet
.ccd5	48		greeting        pha
.ccd6	98		                tya
.ccd7	48		                pha
.ccd8	a0 00		                ldy     #txt0-txtptr
.ccda	20 bc cc	                jsr     sndtxt
.ccdd	a0 52		greet           ldy     #txt1-txtptr
.ccdf	20 bc cc	                jsr     sndtxt
.cce2	a0 00		                ldy     #txt0-txtptr
.cce4	20 bc cc	                jsr     sndtxt
.cce7	a0 7b		                ldy     #txt2-txtptr
.cce9	20 bc cc	                jsr     sndtxt
.ccec	a0 29		                ldy     #txt01-txtptr
.ccee	20 bc cc	                jsr     sndtxt
.ccf1	a0 a3		                ldy     #txt3-txtptr
.ccf3	20 bc cc	                jsr     sndtxt
.ccf6	a0 29		                ldy     #txt01-txtptr
.ccf8	20 bc cc	                jsr     sndtxt
.ccfb	a0 ca		                ldy     #txt4-txtptr
.ccfd	20 bc cc	                jsr     sndtxt
.cd00	a0 29		                ldy     #txt01-txtptr
.cd02	20 bc cc	                jsr     sndtxt
.cd05	68		                pla
.cd06	a8		                tay
.cd07	68		                pla
.cd08	60		                rts
=52489			msgbas  =*
>cd09	0d		msg2            .byte $0d               ; header for registers
>cd0a	20 20 20 50	                .text "   pc  sr ac xr yr sp   v1.2"
>cd0e	43 20 20 53 52 20 41 43 20 58 52 20 59 52 20 53
>cd1e	50 20 20 20 56 31 2e 32
>cd26	8d		                .byte $0d+$80
>cd27	1d bf		msg3            .byte $1d,$3f+$80       ; syntax error: move right, display "?"
>cd29	2e 2e 2e 20	msg4            .text "... sys"         ; sys call to enter monitor
>cd2d	53 59 53
>cd30	a0		                .byte $20+$80
>cd31	3a 92		msg5            .byte $3a,$12+$80       ; ":" then rvs on for memory ascii dump
>cd33	20 45 52 52	msg6            .text " erro"           ; i/o error: display " error"
>cd37	4f
>cd38	d2		                .byte "r"+$80
>cd39	41 a0		msg7            .byte $41,$20+$80       ; assemble next instruction: "a " + addr
>cd3b	20 20		msg8            .text "  "              ; pad non-existent byte: skip 3 spaces
>cd3d	a0		                .byte $20+$80
=52542			txtptr  =*
>cd3e	0d		txt0            .byte $0d
>cd3f	20 3d 3d 3d	                .text        " ======================================"
>cd43	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d
>cd53	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d
>cd63	3d 3d 3d
>cd66	80		                .byte $80
>cd67	0d		txt01           .byte $0d
>cd68	20 2d 2d 2d	                .text        " --------------------------------------"
>cd6c	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d
>cd7c	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d
>cd8c	2d 2d 2d
>cd8f	80		                .byte $80
>cd90	0d		txt1            .byte $0d
>cd91	20 20 20 20	                .text        "      < < < < < supermon > > > > >     "
>cd95	20 20 3c 20 3c 20 3c 20 3c 20 3c 20 53 55 50 45
>cda5	52 4d 4f 4e 20 3e 20 3e 20 3e 20 3e 20 3e 20 20
>cdb5	20 20 20
>cdb8	80		                .byte $80
>cdb9	0d		txt2            .byte $0d
>cdba	20 20 42 59	                .text        "  by jim butterfield (r.i.p.1936-2007)"
>cdbe	20 4a 49 4d 20 42 55 54 54 45 52 46 49 45 4c 44
>cdce	20 28 52 2e 49 2e 50 2e 31 39 33 36 2d 32 30 30
>cdde	37 29
>cde0	80		                .byte $80
>cde1	0d		txt3            .byte $0d
>cde2	20 20 20 54	                .text format("   type [sys%05d] to launch. ($%04x)",org, org)           ; sys call to enter monitor
>cde6	59 50 45 20 5b 53 59 53 34 39 39 32 30 5d 20 54
>cdf6	4f 20 4c 41 55 4e 43 48 2e 20 28 24 43 33 30 30
>ce06	29
>ce07	80		                .byte $80
>ce08	0d		txt4            .byte $0d
>ce09	20 20 20 20	                .text format("    (range $c000-$%04x is available) ",org-1)
>ce0d	28 52 41 4e 47 45 20 24 43 30 30 30 2d 24 43 32
>ce1d	46 46 20 49 53 20 41 56 41 49 4c 41 42 4c 45 29
>ce2d	20
>ce2e	80		                .byte $80
>ce2f	40 02 45 03	mode            .byte $40,$02,$45,$03   ; even opcodes
>ce33	d0 08 40 09	                .byte $d0,$08,$40,$09
>ce37	30 22 45 33	                .byte $30,$22,$45,$33
>ce3b	d0 08 40 09	                .byte $d0,$08,$40,$09
>ce3f	40 02 45 33	                .byte $40,$02,$45,$33
>ce43	d0 08 40 09	                .byte $d0,$08,$40,$09
>ce47	40 02 45 b3	                .byte $40,$02,$45,$b3
>ce4b	d0 08 40 09	                .byte $d0,$08,$40,$09
>ce4f	00 22 44 33	                .byte $00,$22,$44,$33
>ce53	d0 8c 44 00	                .byte $d0,$8c,$44,$00
>ce57	11 22 44 33	                .byte $11,$22,$44,$33
>ce5b	d0 8c 44 9a	                .byte $d0,$8c,$44,$9a
>ce5f	10 22 44 33	                .byte $10,$22,$44,$33
>ce63	d0 08 40 09	                .byte $d0,$08,$40,$09
>ce67	10 22 44 33	                .byte $10,$22,$44,$33
>ce6b	d0 08 40 09	                .byte $d0,$08,$40,$09
>ce6f	62 13 78 a9	                .byte $62,$13,$78,$a9   ; opcodes ending in 01
>ce73	00		mode2           .byte $00   ; 000 000    00                  0   error
>ce74	21		                .byte $21   ; 001 000    01      #$00        1   immediate
>ce75	81		                .byte $81   ; 100 000    01      $00         2   zero-page
>ce76	82		                .byte $82   ; 100 000    10      $0000       3   absolute
>ce77	00		                .byte $00   ; 000 000    00                  4   implied
>ce78	00		                .byte $00   ; 000 000    00                  5   accumulator
>ce79	59		                .byte $59   ; 010 110    01      ($00,x)     6   indirect,x
>ce7a	4d		                .byte $4d   ; 010 011    01      ($00),y     7   indirect,y
>ce7b	91		                .byte $91   ; 100 100    01      $00,x       8   zero-page,x
>ce7c	92		                .byte $92   ; 100 100    10      $0000,x     9   absolute,x
>ce7d	86		                .byte $86   ; 100 001    10      $0000,y     a   absolute,y
>ce7e	4a		                .byte $4a   ; 010 010    10      ($0000)     b   indirect
>ce7f	85		                .byte $85   ; 100 001    01      $00,y       c   zero-page,y
>ce80	9d		                .byte $9d   ; 100 111    01      $0000*      d   relative
>ce81	2c 29 2c	char1           .byte $2c,$29,$2c       ; ","  ")"  ","
>ce84	23 28 24	                .byte $23,$28,$24       ; "#"  "("  "$"
>ce87	59 00 58	char2           .byte $59,$00,$58       ; "y"   0   "x"
>ce8a	24 24 00	                .byte $24,$24,$00       ; "$"  "$"   0
>ce8d	1c 8a 1c 23	mneml           .byte $1c,$8a,$1c,$23   ; brk php bpl clc
>ce91	5d 8b 1b a1	                .byte $5d,$8b,$1b,$a1   ; jsr plp bmi sec
>ce95	9d 8a 1d 23	                .byte $9d,$8a,$1d,$23   ; rti pha bvc cli
>ce99	9d 8b 1d a1	                .byte $9d,$8b,$1d,$a1   ; rts pla bvs sei
>ce9d	00 29 19 ae	                .byte $00,$29,$19,$ae   ; ??? dey bcc tya
>cea1	69 a8 19 23	                .byte $69,$a8,$19,$23   ; ldy tay bcs clv
>cea5	24 53 1b 23	                .byte $24,$53,$1b,$23   ; cpy iny bne cld
>cea9	24 53 19 a1	                .byte $24,$53,$19,$a1   ; cpx inx beq sed
>cead	00 1a 5b 5b	                .byte $00,$1a,$5b,$5b   ; ??? bit jmp jmp
>ceb1	a5 69 24 24	                .byte $a5,$69,$24,$24   ; sty ldy cpy cpx
>ceb5	ae ae a8 ad	                .byte $ae,$ae,$a8,$ad   ; txa txs tax tsx
>ceb9	29 00 7c 00	                .byte $29,$00,$7c,$00   ; dex ??? nop ???
>cebd	15 9c 6d 9c	                .byte $15,$9c,$6d,$9c   ; asl rol lsr ror
>cec1	a5 69 29 53	                .byte $a5,$69,$29,$53   ; stx ldx dec inc
>cec5	84 13 34 11	                .byte $84,$13,$34,$11   ; ora and eor adc
>cec9	a5 69 23 a0	                .byte $a5,$69,$23,$a0   ; sta lda cmp sbc
>cecd	d8 62 5a 48	mnemr           .byte $d8,$62,$5a,$48   ; brk php bpl clc
>ced1	26 62 94 88	                .byte $26,$62,$94,$88   ; jsr plp bmi sec
>ced5	54 44 c8 54	                .byte $54,$44,$c8,$54   ; rti pha bvc cli
>ced9	68 44 e8 94	                .byte $68,$44,$e8,$94   ; rts pla bvs sei
>cedd	00 b4 08 84	                .byte $00,$b4,$08,$84   ; ??? dey bcc tya
>cee1	74 b4 28 6e	                .byte $74,$b4,$28,$6e   ; ldy tay bcs clv
>cee5	74 f4 cc 4a	                .byte $74,$f4,$cc,$4a   ; cpy iny bne cld
>cee9	72 f2 a4 8a	                .byte $72,$f2,$a4,$8a   ; cpx inx beq sed
>ceed	00 aa a2 a2	                .byte $00,$aa,$a2,$a2   ; ??? bit jmp jmp
>cef1	74 74 74 72	                .byte $74,$74,$74,$72   ; sty ldy cpy cpx
>cef5	44 68 b2 32	                .byte $44,$68,$b2,$32   ; txa txs tax tsx
>cef9	b2 00 22 00	                .byte $b2,$00,$22,$00   ; dex ??? nop ???
>cefd	1a 1a 26 26	                .byte $1a,$1a,$26,$26   ; asl rol lsr ror
>cf01	72 72 88 c8	                .byte $72,$72,$88,$c8   ; stx ldx dec inc
>cf05	c4 ca 26 48	                .byte $c4,$ca,$26,$48   ; ora and eor adc
>cf09	44 44 a2 c8	                .byte $44,$44,$a2,$c8   ; sta lda cmp sbc
>cf0d	0d 20 20 20	                .byte $0d,$20,$20,$20
>cf11	41 43 44 46	keyw            .text "acdfghjmrtx@.>;"
>cf15	47 48 4a 4d 52 54 58 40 2e 3e 3b
>cf20	24 2b 26 25	hikey           .text "$+&%lsv"
>cf24	4c 53 56
=53031			keytop  =*
>cf27	6d c6 c5 c4	kaddr           .word assem-1,compar-1,disass-1,fill-1
>cf2b	fa c7 48 c6
>cf2f	50 c4 49 c5	                .word goto-1,hunt-1,jsub-1,dsplym-1
>cf33	6e c4 e3 c3
>cf37	65 c3 c8 c4	                .word dsplyr-1,trans-1,exit-1,dstat-1
>cf3b	dd c3 a1 cb
>cf3f	6d c6 30 c4	                .word assem-1,altm-1,altr-1
>cf43	19 c4
>cf45	10 0a 08 02	modtab          .byte $10,$0a,$08,02    ; modulo number systems
>cf49	04 03 03 01	lentab          .byte $04,$03,$03,$01   ; bits per digit
>cf4d	57 c3		linkad          .word break             ; address of brk handler
>cf4f	00 c3		supad           .word super             ; address of entry point

;******  End of listing
