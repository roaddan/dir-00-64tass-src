
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L v20start.txt -o v20start.prg v20start.asm
; Fri Jan 23 15:25:08 2026

;Offset	;Hex		;Source

;******  Processing input file: v20start.asm

="20260123-101151"	Version = "20260123-101151"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	34 36 32 31	         .text "4621";adresse du debut
>120a	00		         .byte $00   ;fin de cmd basic.
>120b	00 00		bcmd2    .word $00   ;adresse de la pro-
.120d	20 13 12	        jsr bhscrini
.1210	4c 3f 12	basnold jmp main
.1213			bhscrini
.1213	08		        php
.1214	48		        pha
.1215	a9 84		        lda #(128+4)
.1217	8d 00 90	        sta vic0
.121a	ad 0f 90	bord    lda $900f    ;place la couleur
.121d	29 08		        and #%0001000
.121f	09 65		        ora #$65
.1221	8d 0f 90	        sta $900f
.1224	a9 01		text    lda #$01    ;place la couleur
.1226	8d 86 02	        sta $0286   ; du texte.
.1229	a9 93		        lda #$93    ;efface l'ecran par
.122b	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.122e	68		        pla
.122f	28		        plp
.1230	60		        rts
.1231			bhprint
.1231	a0 00		        ldy #$00
.1233	b1 fb		nextc   lda ($fb),y
.1235	f0 07		        beq end
.1237	c8		        iny
.1238	20 d2 ff	        jsr $ffd2
.123b	4c 33 12	        jmp nextc
.123e	60		end     rts

;******  Return to file: v20start.asm

.123f			main
.123f	08		            php
.1240	48		            pha
.1241	a9 0e		            lda #locase
.1243	20 7a f2	            jsr chrout
.1246	68		            pla
.1247	28		            plp
.1248	08		            php
.1249	48		            pha
.124a	a9 6e		            lda #(vbleu*16+(vbleu|8))
.124c	8d 0f 90	            sta  vic15
.124f	a9 01		            lda #vblanc
.1251	8d 86 02	            sta kcol
.1254	a9 93		            lda #147
.1256	20 d2 ff	            jsr $ffd2
.1259	68		            pla
.125a	28		            plp
.125b	20 f8 13	            jsr  pushregs
.125e	a2 2b		            ldx  #<string3
.1260	a0 13		            ldy  #>string3
.1262	20 76 14	            jsr  putsxy
.1265	20 25 14	            jsr  popregs
.1268	08		            php
.1269	48		            pha
.126a	a9 02		            lda  #vrouge
.126c	8d 86 02	            sta  kcol
.126f	68		            pla
.1270	28		            plp
.1271	20 f8 13	            jsr  pushregs
.1274	a2 06		            ldx  #<string1
.1276	a0 13		            ldy  #>string1
.1278	20 76 14	            jsr  putsxy
.127b	20 25 14	            jsr  popregs
.127e	08		            php
.127f	48		            pha
.1280	a9 05		            lda  #vvert
.1282	8d 86 02	            sta  kcol
.1285	68		            pla
.1286	28		            plp
.1287	20 f8 13	            jsr  pushregs
.128a	a2 1a		            ldx  #<string2
.128c	a0 13		            ldy  #>string2
.128e	20 76 14	            jsr  putsxy
.1291	20 25 14	            jsr  popregs
.1294	08		            php
.1295	48		            pha
.1296	a9 05		            lda  #vvert
.1298	8d 86 02	            sta  kcol
.129b	68		            pla
.129c	28		            plp
.129d	20 f8 13	            jsr  pushregs
.12a0	a2 4a		            ldx  #<string5
.12a2	a0 13		            ldy  #>string5
.12a4	20 76 14	            jsr  putsxy
.12a7	20 25 14	            jsr  popregs
.12aa	08		            php
.12ab	48		            pha
.12ac	a9 05		            lda  #vvert
.12ae	8d 86 02	            sta  kcol
.12b1	68		            pla
.12b2	28		            plp
.12b3	20 f8 13	            jsr  pushregs
.12b6	a2 55		            ldx  #<string6
.12b8	a0 13		            ldy  #>string6
.12ba	20 76 14	            jsr  putsxy
.12bd	20 25 14	            jsr  popregs
.12c0	08		            php
.12c1	48		            pha
.12c2	a9 04		            lda  #vmauve
.12c4	8d 86 02	            sta  kcol
.12c7	68		            pla
.12c8	28		            plp
.12c9	20 f8 13	            jsr  pushregs
.12cc	a2 42		            ldx  #<string4
.12ce	a0 13		            ldy  #>string4
.12d0	20 76 14	            jsr  putsxy
.12d3	20 25 14	            jsr  popregs
.12d6	08		            php
.12d7	48		            pha
.12d8	a9 07		            lda  #vjaune
.12da	8d 86 02	            sta  kcol
.12dd	68		            pla
.12de	28		            plp
.12df	20 f8 13	            jsr  pushregs
.12e2	a2 60		            ldx  #<string7
.12e4	a0 13		            ldy  #>string7
.12e6	20 76 14	            jsr  putsxy
.12e9	20 25 14	            jsr  popregs
.12ec	08		            php
.12ed	48		            pha
.12ee	a9 07		            lda  #vjaune
.12f0	8d 86 02	            sta  kcol
.12f3	68		            pla
.12f4	28		            plp
.12f5	20 f8 13	            jsr  pushregs
.12f8	a2 6f		            ldx  #<string8
.12fa	a0 13		            ldy  #>string8
.12fc	20 76 14	            jsr  putsxy
.12ff	20 25 14	            jsr  popregs
.1302	20 47 18	          jsr getkey
.1305	60		          rts
=0			TITLELINE=0
=6			BINLINE=6
=6			BINCOLM=6
=$10			XVAL=$10
=$40			XCPX=$40
=$03			DIFF=$03
>1306	02 00		string1   .byte     BINCOLM-4,TITLELINE
>1308	d4 45 53 54	          .null     "Test drapeaux cpu"
>130c	20 44 52 41 50 45 41 55 58 20 43 50 55 00
>131a	01 03		string2   .byte     BINCOLM-5,BINLINE-3
>131c	46 4c 41 47	          .null     "flags:nv-bdizc"
>1320	53 3a 4e 56 2d 42 44 49 5a 43 00
>132b	01 16		string3   .byte     1,22
>132d	50 41 52 3a	          .null     "par: Daniel Lafrance"
>1331	20 c4 41 4e 49 45 4c 20 cc 41 46 52 41 4e 43 45
>1341	00
>1342	0f 07		string4   .byte     BINCOLM+9,BINLINE+1
>1344	28 20 20 20	          .null     "(   )"
>1348	29 00
>134a	07 04		string5   .byte     BINCOLM+1,BINLINE-2
>134c	5e 5e 5e 5e	          .byte     94,94,94,94,94,94,94,94,0
>1350	5e 5e 5e 5e 00
>1355	07 05		string6   .byte     BINCOLM+1,BINLINE-1
>1357	7d 7d 7d 7d	          .byte     125,125,125,125,125,125,125,125,0
>135b	7d 7d 7d 7d 00
>1360	06 09		string7   .byte     BINCOLM,BINLINE+3
>1362	58 3d 24 20	          .null     "x=$   cpx #$"
>1366	20 20 43 50 58 20 23 24 00
>136f	06 0b		string8   .byte     BINCOLM,BINLINE+5
>1371	24 20 20 20	          .null     "$   - $   = $"
>1375	2d 20 24 20 20 20 3d 20 24 00
>137f	10		count     .byte     XVAL
>1380	40		tstval    .byte     XCPX
>1381	00		result    .byte     0
>1382	00		row       .byte     0
>1383	00		lin       .byte     0
>1384	34 12		adresse   .word     $1234

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.1386			pushall
.1386	08		         php     ;s;rp,pcl,pch
.1387	8d b9 24	         sta ra  ;sauve a
.138a	68		         pla     ;s:pcl,pch
.138b	8d ba 24	         sta rp  ;sauve rp
.138e	68		         pla     ;s:pch
.138f	8d b4 24	         sta pc  ;sauve pcl
.1392	68		         pla     ;s:
.1393	8d b5 24	         sta pc+1;sauve pch
.1396	a5 fb		         lda $fb ;sauve fb
.1398	48		         pha     ;s:fb
.1399	a5 fc		         lda $fc ;sauve fc
.139b	48		         pha     ;s:fc,fb
.139c	a5 fd		         lda $fd ;sauve fd
.139e	48		         pha     ;s:fd,fc,fb
.139f	a5 fe		         lda $fe ;sauve fe
.13a1	48		         pha     ;s:fe,fd,fc,fb
.13a2	ad ba 24	         lda rp  ;sauve rp
.13a5	48		         pha     ;s:rp,fe,fd,fc,fb
.13a6	ad b9 24	         lda ra  ;sauve ra
.13a9	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.13aa	8a		         txa     ;sauve rx
.13ab	48		         pha     ;s:rx,ra,rp,fe-fb
.13ac	98		         tya     ;sauve y
.13ad	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.13ae	ad b5 24	         lda pc+1;replace l'adresse
.13b1	48		         pha     ;s:pch,ry,rx,ra,...
.13b2	ad b4 24	         lda pc  ; de retour.
.13b5	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.13b6	ad ba 24	         lda rp  ;place les flags
.13b9	48		         pha     ; sur le stack.
.13ba	ad b9 24	         lda ra  ;recupere ra
.13bd	28		         plp     ;recupere les flags.
.13be	60		         rts
.13bf			popall
.13bf	08		         php     ;s:rp,pcl,pch,ry,rx,...
.13c0	8d b9 24	         sta ra
.13c3	68		         pla     ;s:pcl,pch,ry,rx,...
.13c4	8d ba 24	         sta rp  ;s:pch,ry,rx,ra,rp,...
.13c7	68		         pla
.13c8	8d b4 24	         sta pc  ;sauve pcl
.13cb	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.13cc	8d b5 24	         sta pc+1;sauve pch
.13cf	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.13d0	a8		         tay     ;recupere ry
.13d1	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.13d2	aa		         tax     ;recupere rx
.13d3	68		         pla     ;s:rp,fe,fd,fc,fb
.13d4	8d b9 24	         sta ra  ;recupere ra
.13d7	68		         pla     ;s:fe,fd,fc,fb
.13d8	8d ba 24	         sta rp  ;recupere les flags.
.13db	68		         pla     ;s:fd,fc,fb
.13dc	85 fe		         sta $fe ;reccupere fe
.13de	68		         pla     ;s:fc,fb
.13df	85 fd		         sta $fd ;recupere fd
.13e1	68		         pla     ;s:fb
.13e2	85 fc		         sta $fc ;recupere fc
.13e4	68		         pla     ;s:
.13e5	85 fb		         sta $fb ;recupere fb
.13e7	ad b5 24	         lda pc+1;replaace l'adresse de
.13ea	48		         pha     ;s:pch
.13eb	ad b4 24	         lda pc  ;retour sur la pile
.13ee	48		         pha     ;s:pcl,pch
.13ef	ad ba 24	         lda rp  ;recupere les flags
.13f2	48		         pha     ;s:rp,pcl,pch
.13f3	ad b9 24	         lda ra  ;recupere ra
.13f6	28		         plp     ;s:pcl,pch
.13f7	60		         rts
.13f8			pushregs
.13f8	08		         php     ;s;rp,pcl,pch
.13f9	8d b9 24	         sta ra  ; -- sauve a
.13fc	68		         pla     ;s:pcl,pch
.13fd	8d ba 24	         sta rp  ; -- sauve rp
.1400	68		         pla     ;s:pch
.1401	8d b4 24	         sta pc  ; -- sauve pcl
.1404	68		         pla     ;s:
.1405	8d b5 24	         sta pc+1; -- sauve pch
.1408	ad ba 24	         lda rp  ; -- sauve rp
.140b	48		         pha     ;s:rp
.140c	ad b9 24	         lda ra  ; -- sauve ra
.140f	48		         pha     ;s:ra,rp
.1410	8a		         txa     ; -- tfr rx
.1411	48		         pha     ;s:rx,ra,rp
.1412	98		         tya     ; -- tfr ry
.1413	48		         pha     ;s:ry,rx,ra,rp
.1414	ad b5 24	         lda pc+1; -- replace l'adresse
.1417	48		         pha     ;s:pch,ry,rx,ra,rp
.1418	ad b4 24	         lda pc  ; -- de retour.
.141b	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.141c	ad ba 24	         lda rp  ; -- place les flags
.141f	48		         pha     ;    sur le stack.
.1420	ad b9 24	         lda ra  ; -- recupere ra
.1423	28		         plp     ; -- recupere flags.
.1424	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1425			popregs
.1425	08		         php
.1426	8d b9 24	         sta ra
.1429	68		         pla
.142a	8d ba 24	         sta rp
.142d	68		         pla     ;s:pch,ry,rx,ra,rp
.142e	8d b4 24	         sta pc  ; -- sauve pcl
.1431	68		         pla     ;s:ry,rx,ra,rp
.1432	8d b5 24	         sta pc+1; -- sauve pch
.1435	68		         pla     ;s:rx,ra,rp
.1436	a8		         tay     ;recupere ry
.1437	68		         pla     ;s:ra,rp
.1438	aa		         tax     ;recupere rx
.1439	68		         pla     ;s:rp
.143a	8d b9 24	         sta ra  ;recupere ra
.143d	68		         pla     ;s:
.143e	8d ba 24	         sta rp  ;recupere les flags.
.1441	ad b5 24	         lda pc+1;replace l'adresse de
.1444	48		         pha     ;s:pch
.1445	ad b4 24	         lda pc  ;retour sur la pile
.1448	48		         pha     ;s:pcl,pch
.1449	ad ba 24	         lda rp  ;recupere les flags
.144c	48		         pha     ;s:rp,pcl,pch
.144d	ad b9 24	         lda ra  ;recupere ra
.1450	28		         plp     ;s:pcl,pch
.1451	60		         rts

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.1452			puts
.1452	20 86 13	        jsr pushall
.1455	a0 00		        ldy #$00   ; y = offset
.1457	b1 fb		nextc   lda ($fb),y;lit un caractere
.1459	f0 09		        beq out    ;si 0 on sort
.145b	20 7a f2	        jsr chrout ;on l'affiche
.145e	20 8c 15	        jsr inczp1 ;pointe le prochain
.1461	4c 57 14	        jmp nextc  ; et l'affiche
.1464	20 bf 13	out     jsr popall
.1467	60		        rts
.1468			putsyx
.1468	20 86 13	        jsr pushall;sauve reg + zps
.146b	86 fb		        stx $fb    ;$yyxx dans
.146d	84 fc		        sty $fb+1  ; zp1
.146f	20 52 14	        jsr puts
.1472	20 bf 13	        jsr popall ;recup reg + zps
.1475	60		        rts
.1476			putsxy
.1476	20 86 13	        jsr pushall;sauve reg + zps
.1479	86 fb		        stx $fb    ;$yyxx dans
.147b	84 fc		        sty $fb+1  ; zp1
.147d	a0 00		        ldy #$00
.147f	b1 fb		        lda ($fb),y
.1481	aa		        tax
.1482	20 8c 15	        jsr inczp1
.1485	b1 fb		        lda ($fb),y
.1487	20 8c 15	        jsr inczp1
.148a	a8		        tay
.148b	20 e0 14	        jsr gotoxy
.148e	20 52 14	        jsr puts
.1491	20 bf 13	        jsr popall ;recup reg + zps
.1494	60		        rts
.1495			putsc
.1495	08		        php        ;flag sur stack
.1496	48		        pha        ;acc sur stack
.1497	48		        pha        ;sauvegarde acc
.1498	ad 86 02	        lda kcol   ;recup coul. carac.
.149b	8d b3 24	        sta curcol ; et la sauvegarde
.149e	68		        pla        ;recup. acc
.149f	8d 86 02	        sta kcol   ;place coul. voulue
.14a2	20 52 14	        jsr puts   ;affiche la chaine
.14a5	ad b3 24	        lda curcol ;recup coul. carac.
.14a8	8d 86 02	        sta kcol   ; et la replace
.14ab	68		        pla        ;recup acc
.14ac	28		        plp        ;recup flag
.14ad	60		        rts
.14ae			putscyx
.14ae	08		        php       ;sauve registres
.14af	48		        pha       ; ...
.14b0	48		        pha       ;sauve acc
.14b1	ad 86 02	        lda kcol  ;recup couleur carac.
.14b4	8d b3 24	        sta curcol; et sauvegarde
.14b7	68		        pla       ;recup acc
.14b8	8d 86 02	        sta kcol  ;place couleur carac.
.14bb	20 68 14	        jsr putsyx;affiche la chaine
.14be	ad b3 24	        lda curcol
.14c1	8d 86 02	        sta kcol
.14c4	68		        pla
.14c5	28		        plp
.14c6	60		        rts
.14c7			putscxy
.14c7	08		        php       ;sauve registres
.14c8	48		        pha       ; ...
.14c9	48		        pha       ;sauve acc
.14ca	ad 86 02	        lda kcol  ;recup couleur carac.
.14cd	8d b3 24	        sta curcol; et sauvegarde
.14d0	68		        pla       ;recup acc
.14d1	8d 86 02	        sta kcol   ;place couleur carac.
.14d4	20 68 14	        jsr putsyx ;affiche la chaine
.14d7	ad b3 24	        lda curcol
.14da	8d 86 02	        sta kcol
.14dd	68		        pla
.14de	28		        plp
.14df	60		        rts
.14e0			gotoxy
.14e0	20 f8 13	        jsr pushregs
.14e3	8a		        txa ; interchange x et y
.14e4	48		        pha ; ...
.14e5	98		        tya ; ...
.14e6	aa		        tax ; ...
.14e7	68		        pla ; ...
.14e8	a8		        tay ; ...
.14e9	c0 00		txlow   cpy #0
.14eb	10 02		        bpl txhigh
.14ed	a2 00		        ldx #0
.14ef	e0 19		txhigh  cpx #25
.14f1	30 02		        bmi tylow
.14f3	a2 18		        ldx #24
.14f5	c0 00		tylow   cpy #0
.14f7	10 02		        bpl tyhigh
.14f9	a0 00		        ldy #0
.14fb	c0 28		tyhigh  cpy #40
.14fd	30 02		        bmi allok
.14ff	a0 27		        ldy #39
.1501	18		allok   clc
.1502	20 0a e5	        jsr plot
.1505	20 25 14	        jsr popregs
.1508	60		        rts
.1509			putnch
.1509	20 f8 13	        jsr pushregs
.150c	20 7a f2	again   jsr chrout
.150f	ca		        dex
.1510	d0 fa		        bne again
.1512	20 25 14	        jsr popregs
.1515	60		        rts
.1516			strlen
.1516	20 86 13	        jsr pushall
.1519	84 fc		        sty zp1+1
.151b	86 fb		        stx zp1
.151d	a0 00		        ldy #$00
.151f	8c 45 24	        sty len
.1522	b1 fb		next    lda (zp1),y
.1524	f0 07		        beq out
.1526	ee 45 24	        inc len
.1529	c8		        iny
.152a	4c 22 15	        jmp next
.152d	20 bf 13	out     jsr popall
.1530	ad 45 24	        lda len
.1533	60		        rts
.1534			cursor
.1534	20 f8 13	        jsr  pushregs
.1537	90 12		        bcc  get    ;C=0 récupération.
.1539	20 0a e5	        jsr  plot  ;récupère position
.153c	8c 44 24	        sty  cx     ;curseur et sauve
.153f	8e 43 24	        stx  cy     ;dans vars locales.
.1542	ad 86 02	        lda  kcol   ;Sauve couleur
.1545	8d 42 24	        sta  bcol   ; BASIC du texte.
.1548	4c 5a 15	        jmp  out    ;Fini on sort.
.154b	ae 43 24	get     ldx  cy     ;C=1, charge x
.154e	ac 44 24	        ldy  cx     ; ligne, y col.
.1551	20 0a e5	        jsr  plot  ;Position curseur.
.1554	ad 42 24	        lda  bcol   ;replace couleur
.1557	8d 86 02	        sta  kcol ; basic sauvegardé.
.155a	20 25 14	out     jsr  popregs
.155d	60		        rts
.155e			cursave
.155e	08		        php
.155f	38		        sec
.1560	20 34 15	        jsr  cursor
.1563	28		        plp
.1564	60		        rts
.1565			curput
.1565	08		        php
.1566	18		        clc
.1567	20 34 15	        jsr  cursor
.156a	28		        plp
.156b	60		        rts

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.156c			blkfill
.156c	20 86 13	bf0     jsr pushall
.156f	84 fc		        sty zp1+1
.1571	a0 00		        ldy #$00
.1573	84 fb		        sty zp1
.1575	91 fb		bf1     sta (zp1),y
.1577	c8		        iny
.1578	d0 fb		        bne bf1
.157a	20 bf 13	        jsr popall
.157d	60		        rts
.157e			memfill
.157e	20 f8 13	        jsr pushregs
.1581	20 6c 15	mf1     jsr blkfill
.1584	c8		        iny
.1585	ca		        dex
.1586	d0 f9		        bne mf1
.1588	20 25 14	        jsr popregs
.158b	60		        rts
.158c			inczp1
.158c	08		         php
.158d	e6 fb		         inc zp1
.158f	d0 02		         bne repzp1
.1591	e6 fc		         inc zp1+1
.1593	28		repzp1   plp
.1594	60		         rts
.1595			inczp2
.1595	08		         php
.1596	e6 fc		         inc zp2
.1598	d0 02		         bne repzp2
.159a	e6 fd		         inc zp2+1
.159c	28		repzp2   plp
.159d	60		         rts
.159e			deczp1
.159e	08		         php
.159f	48		         pha
.15a0	a5 fb		         lda zp1
.15a2	d0 02		         bne noemp
.15a4	c6 fc		         dec zp1+1
.15a6	c6 fb		noemp    dec zp1
.15a8	68		         pla
.15a9	28		         plp
.15aa	60		         rts
.15ab			deczp2
.15ab	08		         php
.15ac	48		         pha
.15ad	a5 fc		         lda zp2
.15af	d0 02		         bne noemp
.15b1	c6 fd		         dec zp2+1
.15b3	c6 fc		noemp    dec zp2
.15b5	68		         pla
.15b6	28		         plp
.15b7	60		         rts
.15b8			rolzp1
.15b8	08		        php
.15b9	48		        pha
.15ba	18		        clc
.15bb	a5 fb		        lda zp1
.15bd	2a		        rol
.15be	85 fb		        sta zp1
.15c0	a5 fc		        lda zp1+1
.15c2	2a		        rol
.15c3	85 fc		        sta zp1+1
.15c5	68		        pla
.15c6	28		        plp
.15c7			rorzp1
.15c7	08		        php
.15c8	48		        pha
.15c9	18		        clc
.15ca	a5 fc		        lda zp1+1
.15cc	6a		        ror
.15cd	85 fc		        sta zp1+1
.15cf	a5 fb		        lda zp1
.15d1	6a		        ror
.15d2	85 fb		        sta zp1
.15d4	68		        pla
.15d5	28		        plp
.15d6			rolzp2
.15d6	08		        php
.15d7	48		        pha
.15d8	18		        clc
.15d9	a5 fc		        lda zp2
.15db	2a		        rol
.15dc	85 fc		        sta zp2
.15de	a5 fd		        lda zp2+1
.15e0	2a		        rol
.15e1	85 fd		        sta zp2+1
.15e3	68		        pla
.15e4	28		        plp
.15e5			rorzp2
.15e5	08		        php
.15e6	48		        pha
.15e7	18		        clc
.15e8	a5 fd		        lda zp2+1
.15ea	6a		        ror
.15eb	85 fd		        sta zp2+1
.15ed	a5 fc		        lda zp2
.15ef	6a		        ror
.15f0	85 fc		        sta zp2
.15f2	68		        pla
.15f3	28		        plp
.15f4			yxtoptr
.15f4	8c b3 24	        sty memptr+1
.15f7	8e b2 24	        stx memptr
.15fa	60		        rts
.15fb			ptrtoyx
.15fb	08		        php
.15fc	ac b3 24	        ldy memptr+1
.15ff	ae b2 24	        ldx memptr
.1602	28		        plp
.1603	60		        rts
.1604			incptr
.1604	08		        php
.1605	ee b2 24	        inc memptr
.1608	d0 03		        bne norep
.160a	ee b3 24	        inc memptr+1
.160d	28		norep   plp
.160e	60		        rts
.160f			decptr
.160f	08		        php
.1610	48		        pha
.1611	ad b2 24	        lda memptr
.1614	d0 03		        bne noemp
.1616	ee b3 24	        inc memptr+1
.1619	ee b2 24	noemp   inc memptr
.161c	68		        pla
.161d	28		        plp
.161e	60		        rts
.161f			incptr8
.161f	08		        php
.1620	48		        pha
.1621	98		        tya
.1622	48		        pha
.1623	a0 08		        ldy #8
.1625	20 04 16	again   jsr incptr
.1628	88		        dey
.1629	d0 fa		        bne again
.162b	68		        pla
.162c	a8		        tay
.162d	68		        pla
.162e	28		        plp
.162f	60		        rts
.1630			loop
.1630	ce ac 24	               dec  loopcount
.1633	d0 03		               bne  norep
.1635	ce ad 24	               dec  loopcount+1
.1638	ad ac 24	norep          lda  loopcount
.163b	c9 00		               cmp  #$00
.163d	d0 05		               bne  out
.163f	4d ad 24	               eor  loopcount+1
.1642	c9 ff		               cmp  #$ff
.1644	60		out            rts

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.1645			addtoword
.1645			addatoyx
.1645	08		        php
.1646	48		        pha
.1647	8c 53 24	        sty reponse+1
.164a	8e 52 24	        stx reponse
.164d	18		        clc
.164e	6d 52 24	        adc reponse
.1651	90 03		        bcc norep
.1653	ee 53 24	        inc reponse+1
.1656	8d 52 24	norep   sta reponse
.1659	ac 53 24	        ldy reponse+1
.165c	ae 52 24	        ldx reponse
.165f	68		        pla
.1660	28		        plp
.1661	60		        rts
.1662			subtoword
.1662			subatoyx
.1662	08		        php
.1663	48		        pha
.1664	8c 53 24	        sty reponse+1
.1667	8e 52 24	        stx reponse
.166a	38		        sec
.166b	ed 52 24	        sbc reponse
.166e	b0 03		        bcs noemp
.1670	ce 53 24	        dec reponse+1
.1673	8d 52 24	noemp   sta reponse
.1676	ac 53 24	        ldy reponse+1
.1679	ae 52 24	        ldx reponse
.167c	68		        pla
.167d	28		        plp
.167e	60		        rts

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.167f			putyxhex
.167f	20 86 13	        jsr pushall
.1682	98		        tya
.1683	48		        pha
.1684	20 f1 16	        jsr lsr4bits
.1687	20 f8 16	        jsr nibtohex
.168a	8d a7 24	        sta hexstr+0
.168d	68		        pla
.168e	20 f8 16	        jsr nibtohex
.1691	8d a8 24	        sta hexstr+1
.1694	8a		        txa
.1695	20 b4 16	        jsr atohex
.1698	a2 a7		        ldx #<hexstr+0
.169a	a0 24		        ldy #>hexstr+0
.169c	20 68 14	        jsr putsyx
.169f	20 bf 13	        jsr popall
.16a2	60		        rts
.16a3			putahex
.16a3	20 f8 13	        jsr pushregs
.16a6	20 b4 16	        jsr atohex
.16a9	a2 a9		        ldx #<hexstr+2
.16ab	a0 24		        ldy #>hexstr+2
.16ad	20 68 14	        jsr putsyx
.16b0	20 25 14	        jsr popregs
.16b3	60		        rts
.16b4			atohex
.16b4	08		        php
.16b5	48		        pha
.16b6	48		        pha
.16b7	20 f1 16	        jsr lsr4bits
.16ba	20 f8 16	        jsr nibtohex
.16bd	8d a7 24	        sta hexstr
.16c0	68		        pla
.16c1	20 f8 16	        jsr nibtohex
.16c4	8d a8 24	        sta hexstr+1
.16c7	a9 00		        lda #$00
.16c9	8d a9 24	        sta hexstr+2
.16cc	68		        pla
.16cd	28		        plp
.16ce	60		        rts
.16cf			atobin
.16cf	20 f8 13	               jsr  pushregs
.16d2	a2 08		               ldx  #8
.16d4	a0 00		               ldy  #0
.16d6	18		               clc
.16d7	2a		nextbit        rol
.16d8	48		               pha
.16d9	69 00		               adc  #$00
.16db	29 01		               and  #$01
.16dd	20 f8 16	               jsr  nibtohex
.16e0	99 9a 24	               sta  binstr,y
.16e3	68		               pla
.16e4	c8		               iny
.16e5	ca		               dex
.16e6	d0 ef		               bne  nextbit
.16e8	a9 00		               lda  #0
.16ea	99 9a 24	               sta  binstr,y
.16ed	20 25 14	               jsr  popregs
.16f0	60		               rts
.16f1			lsr4bits
.16f1	08		        php
.16f2	4a		        lsr a
.16f3	4a		        lsr a
.16f4	4a		        lsr a
.16f5	4a		        lsr a
.16f6	28		        plp
.16f7	60		        rts
.16f8			nibtohex
.16f8	08		        php
.16f9	29 0f		        and    #$0f
.16fb	f8		        sed
.16fc	18		        clc
.16fd	69 90		        adc #$90
.16ff	69 40		        adc #$40
.1701	28		        plp
.1702	60		        rts
.1703			bytestohex
.1703	20 86 13	        jsr pushall
.1706	84 fc		        sty zp1+1
.1708	86 fb		        stx zp1
.170a	08		            php
.170b	48		            pha
.170c	a9 20		            lda #32
.170e	20 7a f2	            jsr chrout
.1711	68		            pla
.1712	28		            plp
.1713	08		            php
.1714	48		            pha
.1715	a9 05		            lda #5
.1717	20 7a f2	            jsr chrout
.171a	68		            pla
.171b	28		            plp
.171c	08		            php
.171d	48		            pha
.171e	a9 24		            lda #36
.1720	20 7a f2	            jsr chrout
.1723	68		            pla
.1724	28		            plp
.1725	20 7f 16	        jsr putyxhex   ; prn adreponsese
.1728	08		            php
.1729	48		            pha
.172a	a9 20		            lda #$20
.172c	20 7a f2	            jsr chrout
.172f	68		            pla
.1730	28		            plp
.1731	08		            php
.1732	48		            pha
.1733	a9 9f		            lda #159
.1735	20 7a f2	            jsr chrout
.1738	68		            pla
.1739	28		            plp
.173a	a0 00		        ldy #$00
.173c	aa		        tax
.173d	8c 8b 24	another sty offset
.1740	b1 fb		        lda (zp1),y
.1742	20 a3 16	        jsr putahex
.1745	48		        pha
.1746	20 65 17	        jsr petsciiaddr
.1749	68		        pla
.174a	8d 00 04	petscii sta $0400
.174d	48		        pha
.174e	a9 0d		        lda #$0d
.1750	8d 00 d8	petcol  sta $d800
.1753	68		        pla
.1754	08		            php
.1755	48		            pha
.1756	a9 20		            lda #$20
.1758	20 7a f2	            jsr chrout
.175b	68		            pla
.175c	28		            plp
.175d	c8		        iny
.175e	ca		        dex
.175f	d0 dc		        bne another
.1761	20 bf 13	        jsr popall
.1764	60		        rts
.1765			petsciiaddr
.1765	20 f8 13	        jsr pushregs
.1768	a9 1f		        lda #31
.176a	18		        clc
.176b	6d 8b 24	        adc offset
.176e	20 45 16	        jsr addatoyx
.1771	8c 4c 17	        sty petscii+2
.1774	8e 4b 17	        stx petscii+1
.1777	8e 51 17	        stx petcol+1
.177a	98		        tya
.177b	29 fb		        and #%11111011 ;#%00000100
.177d	09 d8		        ora #$d8
.177f	8d 52 17	        sta petcol+2
.1782	a8		        tay
.1783	20 25 14	        jsr popregs
.1786	60		        rts
.1787			strhexval
.1787	20 86 13	        jsr pushall ; sauve registre
.178a	84 fc		        sty zp1+1   ; ptr dans zp1
.178c	86 fb		        stx zp1
.178e	20 16 15	        jsr strlen  ;len de $(yyxx)->a
.1791	f0 3d		        beq oute    ; si 0 erreur C=1
.1793	a0 00		        ldy #$00    ; offset a 0
.1795	8c 53 24	        sty reponse+1; reponse a zero
.1798	8c 52 24	        sty reponse ;    ...
.179b	b1 fb		nextc   lda (zp1),y ;charge un caractere
.179d	f0 26		        beq out     ;On  a fini
.179f	c0 00		        cpy #$00    ;si c'est le premier
.17a1	f0 07		        beq norol   ; pas de rol
.17a3	48		        pha         ;
.17a4	a9 04		        lda #$04    ;rol de 4 pos
.17a6	20 00 18	        jsr rolword ;
.17a9	68		        pla         ;
.17aa	09 20		norol   ora #%00100000
.17ac	38		        sec
.17ad	e9 30		        sbc #$30
.17af	c9 0a		        cmp #$0a
.17b1	90 07		        bcc lt10
.17b3	38		        sec
.17b4	e9 27		        sbc #$27
.17b6	c9 10		        cmp #$10
.17b8	b0 16		        bcs oute
.17ba	0d 52 24	lt10    ora reponse
.17bd	8d 52 24	        sta reponse
.17c0	c8		        iny
.17c1	c0 04		        cpy #$04
.17c3	d0 d6		        bne nextc
.17c5	20 bf 13	out     jsr popall
.17c8	18		        clc          ;Carry 0 = good
.17c9	ac 53 24	        ldy reponse+1
.17cc	ae 52 24	        ldx reponse
.17cf	60		        rts
.17d0	20 bf 13	oute    jsr popall
.17d3	38		        sec
.17d4	60		        rts
.17d5			putahexdec
.17d5	20 f8 13	        jsr pushregs
.17d8	08		            php
.17d9	48		            pha
.17da	a9 9e		            lda #sjaune
.17dc	20 7a f2	            jsr chrout
.17df	68		            pla
.17e0	28		            plp
.17e1	20 a3 16	        jsr putahex
.17e4	08		            php
.17e5	48		            pha
.17e6	a9 20		            lda #$20
.17e8	20 7a f2	            jsr chrout
.17eb	68		            pla
.17ec	28		            plp
.17ed	08		            php
.17ee	48		            pha
.17ef	a9 9f		            lda #socean
.17f1	20 7a f2	            jsr chrout
.17f4	68		            pla
.17f5	28		            plp
.17f6	aa		        tax
.17f7	a9 00		        lda #$00
.17f9	20 cd dd	        jsr fiaxtf1
.17fc	20 25 14	        jsr popregs
.17ff	60		        rts
.1800			rolword
.1800	20 f8 13	        jsr pushregs
.1803	a8		        tay
.1804	18		again   clc
.1805	2e 52 24	        rol reponse
.1808	2e 53 24	        rol reponse+1
.180b	88		        dey
.180c	d0 f6		        bne again
.180e	20 25 14	        jsr popregs
.1811	60		        rts

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.1812			clrkbbuf
.1812	08		            php
.1813	48		            pha
.1814	a9 00		            lda #0
.1816	85 c6		            sta 198
.1818	68		            pla
.1819	28		            plp
.181a	60		            rts
.181b			waitstop
.181b	08		          php    ;\ sauve les flags
.181c	48		          pha    ;/  et l'acc.
.181d	20 12 18	          jsr clrkbbuf
.1820	20 70 f7	wait      jsr stop ; Veri [run/stop]
.1823	d0 fb		          bne wait ;loop pas pesee.
.1825	68		          pla    ;\ recup. acc et
.1826	28		          plp    ;/  les flags.
.1827	60		          rts
.1828			anykey
.1828	08		        php
.1829	48		        pha
.182a	20 12 18	        jsr clrkbbuf
.182d	a5 cb		wait    lda 203    ;lit la matrice de
.182f	c9 40		        cmp #64    ; 64 = aucune clef
.1831	f0 fa		        beq wait   ; on en attend une.
.1833	20 3c 18	        jsr kbfree ; Clavier relache.
.1836	20 12 18	        jsr clrkbbuf
.1839	68		        pla
.183a	28		        plp
.183b	60		        rts
.183c			kbfree
.183c	08		        php
.183d	48		        pha
.183e	a5 cb		wait    lda 203    ; lit la matrice
.1840	c9 40		        cmp #64    ; 64 = aucune clef
.1842	d0 fa		        bne wait   ; attend la relache
.1844	68		        pla
.1845	28		        plp
.1846	60		        rts
.1847			getkey
.1847	08		        php
.1848	20 f5 f1	try     jsr getin  ;tente de lire
.184b	c9 00		        cmp #0     ; 0 si aucune.
.184d	f0 f9		        beq try    ; on reessaye
.184f	28		        plp
.1850	60		        rts
.1851			waitkey
.1851	08		        php
.1852	48		        pha
.1853	8d 46 24	        sta clef   ;Sauve clef voulue
.1856	20 12 18	        jsr clrkbbuf
.1859	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.185c	cd 46 24	        cmp clef   ;Compare avec clef
.185f	d0 f8		        bne wait   ;Pas la bonne.
.1861	68		        pla
.1862	28		        plp
.1863	60		        rts
.1864			waitspace
.1864	a9 20		            lda #$20
.1866	20 51 18	            jsr waitkey
.1869	20 12 18	            jsr clrkbbuf
.186c	60		            rts
.186d			showkey
.186d	20 f8 13	        jsr pushregs
.1870	38		        sec
.1871	20 0a e5	        jsr plot
.1874	8e 48 24	        stx curx
.1877	8c 47 24	        sty cury
.187a	20 f8 13	        jsr pushregs
.187d	a0 1c		        ldy #39-11
.187f	a2 18		        ldx #24
.1881	18		        clc
.1882	20 0a e5	        jsr plot
.1885	20 25 14	        jsr popregs
.1888	20 7a f2	        jsr chrout
.188b	08		            php
.188c	48		            pha
.188d	a9 20		            lda #32
.188f	20 7a f2	            jsr chrout
.1892	68		            pla
.1893	28		            plp
.1894	08		            php
.1895	48		            pha
.1896	a9 24		            lda #36
.1898	20 7a f2	            jsr chrout
.189b	68		            pla
.189c	28		            plp
.189d	20 d5 17	        jsr putahexdec
.18a0	18		        clc
.18a1	ac 47 24	        ldy cury
.18a4	ae 48 24	        ldx curx
.18a7	20 0a e5	        jsr plot
.18aa	20 25 14	        jsr popregs
.18ad	60		        rts

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=9403			libre    = *+3085
=9402			rp       = libre-$01;1 byte $cfff
=9401			ra       = rp-1     ;1 byte $cffe
=9400			rx       = ra-1     ;1 byte $cffd
=9399			ry       = rx-1     ;1 byte $cffc
=9398			rs       = ry-1     ;1 byte $cffb
=9396			pc       = rs-2     ;2 byte $cff9-$cffa
=9395			curcol   = pc-1     ;1 byte $cff6
=9394			memptr   = curcol-1;1 word $cff7-$cff8
=9392			src      = memptr-2
=9390			dst      = memptr-4
=9388			loopcount = memptr-6
=9388			hexv     = loopcount
.18ae			a2hexstr
=9383			hexstr   = hexv-$05 ;5 byte
=9382			a2hexpfx = hexv-$06 ;1 byte
=9381			a2hexpy  = hexv-$07 ;1 byte
=9380			a2hexpx  = hexv-$08 ;1 byte
=9380			a2hexpos = hexv-$08 ;0 byte
=9379			a2hexcol = hexv-$09 ;1 byte
=9379			binv     = a2hexcol
=9370			binstr   = binv-$09 ;9 byte
=9369			a2binpfx = binv-$0a ;1 byte
=9368			a2binpy  = binv-$0b ;1 byte
=9367			a2binpx  = binv-$0c ;1 byte
=9367			a2binpos = binv-$0c ;0 byte
=9366			a2bincol = binv-$0d ;1 byte
=9366			decv     = a2bincol
=9360			decstr   = decv-$06 ;6 byte
=9359			a2decpfx = decv-$07 ;1 byte
=9358			a2decpy  = decv-$08 ;1 byte
=9357			a2decpx  = decv-$09 ;1 byte
=9357			a2decpos = decv-$09 ;0 byte
=9356			a2deccol = decv-$0a ;1 byte
=9355			offset   = decv-$0b ;1 byte
=9355			fltv     = offset
=9349			fvar1    = fltv-6  ; 6 byte
=9343			fvar2    = fltv-12 ; 6 byte
=9323			float1   = fltv-32 ;20 byte
=9303			float2   = fltv-52 ;20 byte
=9302			tval1    = fltv-53 ; 1 byte
=9300			tval2    = fltv-55 ; 2 byte
=9298			reponse  = tval2-2 ; 2 byte
=9298			edbox    = reponse
=9297			cleft    = edbox-1 ;1 byte
=9296			cright   = edbox-2 ;1 byte
=9295			cmid     = edbox-3 ;1 byte
=9294			dbtop    = edbox-4 ;1 byte
=9293			dbleft   = edbox-5 ;1 byte
=9292			dbwdth   = edbox-6 ;1 byte
=9291			dbhght   = edbox-7 ;1 byte
=9290			dbcoul   = edbox-8 ;1 byte
=9289			dbclin   = edbox-9 ;1 byte
=9289			ekeyb    = dbclin
=9288			curx     = ekeyb-1 ;1 byte
=9287			cury     = ekeyb-2 ;1 byte
=9286			clef     = ekeyb-3 ;1 byte
=9285			len      = clef-1  ;1 byte
=9284			cx       = clef-2  ;1 byte
=9283			cy       = clef-3  ;1 byte
=9282			bcol     = clef-4  ;1 byte
=9282			escr     = bcol          ;   2051 bytes
=9281			loops    = escr-1       ; 1 byte
=9279			loop16   = loops-2      ; 2 byte
=8255			scrncar  = loop16-1024  ;1k byte
=7231			scrncol  = scrncar-1024 ;1k byte
=7231			diskvar = scrncol
=7229			ddatas  = diskvar-2 ;2 byte Data start
=7227			ddatae  = diskvar-4 ;2 byte Data end
=7226			ddev    = diskvar-5 ;1 byte Dev number
=7225			dlfsno  = diskvar-6 ;1 byte Lfs
=7223			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=7222			dfnlen  = diskvar-9 ;1 byte lenfilename
=7221			genbyte1 = dfnlen-1 ; 1 byte
=7219			genword1 = dfnlen-3 ; 2 byte
=7218			endofvars = genword1-1

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm


;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			fFAC1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			fFAC1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; ff1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; ff1=atn(f1).

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: v20start.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$fb			zp1       =    $fb
=$fc			zp2       =    $fc
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.18ae	4c 3f 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: v20start.asm


;******  End of listing
