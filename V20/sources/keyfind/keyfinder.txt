
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L keyfinder.txt -o keyfinder.prg keyfinder.asm
; Sat Jan 31 19:22:25 2026

;Offset	;Hex		;Source

;******  Processing input file: keyfinder.asm

="20260131-192144"	version  = "20260131-192144"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

=$1000			scrtxt    = $1000
=$9400			scrcol    = $9400
=$0200			scrlen    = $0200
>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	20 34 36 32	         .text format("%5d", bhstart)
>120a	32
>120b	00		         .byte $00   ;fin de cmd basic.
>120c	00 00		bcmd2    .word $00   ;adresse de la pro-
.120e	20 1a 12	bhstart   jsr bhscrini
.1211	ea		          nop
.1212	ea		          nop
.1213	ea		          nop
.1214	ea		          nop
.1215	ea		          nop
.1216	20 b2 12	basnold   jsr main
.1219	60		          rts
.121a			bhscrini
.121a	08		        php
.121b	48		        pha
.121c	a9 84		        lda #(128+4)
.121e	8d 00 90	        sta vic0
.1221	ad 0f 90	bord    lda $900f    ;place la couleur
.1224	29 08		        and #%00001000
.1226	09 e3		        ora #%11100011
.1228	8d 0f 90	        sta $900f
.122b	a9 00		text    lda #$00    ;place la couleur
.122d	8d 86 02	        sta $0286   ; du texte.
.1230	a9 93		        lda #$93    ;efface l'ecran par
.1232	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.1235	68		        pla
.1236	28		        plp
.1237	60		        rts
.1238			bhprint
.1238	a0 00		        ldy #$00
.123a	b1 fb		nextc   lda ($fb),y
.123c	f0 07		        beq end
.123e	c8		        iny
.123f	20 d2 ff	        jsr $ffd2
.1242	4c 3a 12	        jmp nextc
.1245	60		end     rts

;******  Return to file: keyfinder.asm


;******  Processing file: string-fr.asm

>1246	20 00		spaces         .null " "
>1248	0d 0d 20 20	bonjour        .byte $0d,$0d,32,32,revson
>124c	12
>124d	20 42 4f 4e	               .text " bonjour & merci! "
>1251	4a 4f 55 52 20 26 20 4d 45 52 43 49 21 20
>125f	92 0d 00	               .byte revsoff,$0d,0
>1262	20 90 12	texte0         .byte 32,snoir,revson        ;0-2
>1265	43 48 45 52	               .text "chercheur code clef" ;3-23
>1269	43 48 45 55 52 20 43 4f 44 45 20 43 4c 45 46
>1278	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>127c	00		               .byte 0
>127d	20 1f 92	texte1         .byte 32,sbleu,revsoff
>1280	20 5b 45 53	               .text " [esc] pour sortir "
>1284	43 5d 20 50 4f 55 52 20 53 4f 52 54 49 52 20
>1293	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1297	00		               .byte 0
>1298	20 90 92	ligne          .byte 32,snoir,revsoff        ;0-2
>129b	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;3-8   ;1
>129f	c0
>12a0	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;9-13
>12a4	c0
>12a5	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;14-18
>12a9	c0
>12aa	c0 c0 c0 c0	               .byte 192,192,192,192         ;19-23
>12ae	90 92 20	               .byte snoir,revsoff,32    ;24-27
>12b1	00		               .byte 0

;******  Return to file: keyfinder.asm

.12b2			main
.12b2	08		            php
.12b3	48		            pha
.12b4	a9 1b		            lda #(vblanc*16+(vocean|8))
.12b6	8d 0f 90	            sta  vic15
.12b9	a9 06		            lda #vbleu
.12bb	8d 86 02	            sta kcol
.12be	a9 93		            lda #147
.12c0	20 d2 ff	            jsr $ffd2
.12c3	68		            pla
.12c4	28		            plp
.12c5	20 94 19	          jsr scrnsave
.12c8	08		            php
.12c9	48		            pha
.12ca	a9 8e		            lda #upcase
.12cc	20 7a f2	            jsr chrout
.12cf	68		            pla
.12d0	28		            plp
.12d1			help
.12d1	08		            php
.12d2	48		            pha
.12d3	a9 90		            lda #snoir
.12d5	20 7a f2	            jsr chrout
.12d8	68		            pla
.12d9	28		            plp
.12da	08		            php
.12db	48		            pha
.12dc	a9 13		            lda #19
.12de	20 7a f2	            jsr chrout
.12e1	68		            pla
.12e2	28		            plp
.12e3	20 15 14	          jsr  pushregs
.12e6	a9 b0		          lda #176
.12e8	8d 62 12	          sta texte0+0
.12eb	a9 ae		          lda #174
.12ed	8d 7a 12	          sta texte0+24
.12f0	a2 62		          ldx  #<texte0
.12f2	a0 12		          ldy  #>texte0
.12f4	20 85 14	          jsr  putsyx
.12f7	20 42 14	          jsr  popregs
.12fa	20 15 14	          jsr  pushregs
.12fd	a9 dd		          lda #221
.12ff	8d 7d 12	          sta texte1+0
.1302	a9 dd		          lda #221
.1304	8d 95 12	          sta texte1+24
.1307	a2 7d		          ldx  #<texte1
.1309	a0 12		          ldy  #>texte1
.130b	20 85 14	          jsr  putsyx
.130e	20 42 14	          jsr  popregs
.1311	20 15 14	          jsr  pushregs
.1314	a9 ad		          lda #173
.1316	8d 98 12	          sta ligne+0
.1319	a9 bd		          lda #189
.131b	8d b0 12	          sta ligne+24
.131e	a2 98		          ldx  #<ligne
.1320	a0 12		          ldy  #>ligne
.1322	20 85 14	          jsr  putsyx
.1325	20 42 14	          jsr  popregs
.1328	20 a3 13	            jsr  pushall
.132b	a2 8c		            ldx  #<revision
.132d	86 fb		            stx  $fb
.132f	a0 13		            ldy  #>revision
.1331	84 fc		            sty  $fc
.1333	20 6f 14	            jsr  puts
.1336	20 dc 13	            jsr  popall
.1339	08		            php
.133a	48		            pha
.133b	a9 0d		            lda #13
.133d	20 7a f2	            jsr chrout
.1340	68		            pla
.1341	28		            plp
.1342	20 3c 19	morekey   jsr getkey
.1345	08		            php
.1346	48		            pha
.1347	a9 1d		            lda #29
.1349	20 7a f2	            jsr chrout
.134c	68		            pla
.134d	28		            plp
.134e	08		            php
.134f	48		            pha
.1350	a9 1d		            lda #29
.1352	20 7a f2	            jsr chrout
.1355	68		            pla
.1356	28		            plp
.1357	20 37 18	          jsr showra
.135a	08		            php
.135b	48		            pha
.135c	a9 0d		            lda #13
.135e	20 7a f2	            jsr chrout
.1361	68		            pla
.1362	28		            plp
.1363	c9 11		          cmp #17   ;[CTRL]-[Q]
.1365	f0 0a		          beq out
.1367	c9 08		          cmp #8    ;[CTRL]-[H]
.1369	d0 03		          bne chkmore
.136b	4c d1 12	          jmp help
.136e	4c 42 13	chkmore   jmp morekey
.1371			out
.1371	08		            php
.1372	48		            pha
.1373	a9 1f		            lda #sbleu
.1375	20 7a f2	            jsr chrout
.1378	68		            pla
.1379	28		            plp
.137a	20 a3 13	            jsr  pushall
.137d	a2 48		            ldx  #<bonjour
.137f	86 fb		            stx  $fb
.1381	a0 12		            ldy  #>bonjour
.1383	84 fc		            sty  $fc
.1385	20 6f 14	            jsr  puts
.1388	20 dc 13	            jsr  popall
.138b	60		          rts
>138c	0d		revision  .byte $0d
>138d	20 56 45 52	          .null format(" ver:%15s ",version)
>1391	3a 32 30 32 36 30 31 33 31 2d 31 39 32 31 34 34
>13a1	20 00

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.13a3			pushall
.13a3	08		         php     ;s;rp,pcl,pch
.13a4	8d fe 7f	         sta ra  ;sauve a
.13a7	68		         pla     ;s:pcl,pch
.13a8	8d ff 7f	         sta rp  ;sauve rp
.13ab	68		         pla     ;s:pch
.13ac	8d f9 7f	         sta pc  ;sauve pcl
.13af	68		         pla     ;s:
.13b0	8d fa 7f	         sta pc+1;sauve pch
.13b3	a5 fb		         lda $fb ;sauve fb
.13b5	48		         pha     ;s:fb
.13b6	a5 fc		         lda $fc ;sauve fc
.13b8	48		         pha     ;s:fc,fb
.13b9	a5 fd		         lda $fd ;sauve fd
.13bb	48		         pha     ;s:fd,fc,fb
.13bc	a5 fe		         lda $fe ;sauve fe
.13be	48		         pha     ;s:fe,fd,fc,fb
.13bf	ad ff 7f	         lda rp  ;sauve rp
.13c2	48		         pha     ;s:rp,fe,fd,fc,fb
.13c3	ad fe 7f	         lda ra  ;sauve ra
.13c6	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.13c7	8a		         txa     ;sauve rx
.13c8	48		         pha     ;s:rx,ra,rp,fe-fb
.13c9	98		         tya     ;sauve y
.13ca	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.13cb	ad fa 7f	         lda pc+1;replace l'adresse
.13ce	48		         pha     ;s:pch,ry,rx,ra,...
.13cf	ad f9 7f	         lda pc  ; de retour.
.13d2	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.13d3	ad ff 7f	         lda rp  ;place les flags
.13d6	48		         pha     ; sur le stack.
.13d7	ad fe 7f	         lda ra  ;recupere ra
.13da	28		         plp     ;recupere les flags.
.13db	60		         rts
.13dc			popall
.13dc	08		         php     ;s:rp,pcl,pch,ry,rx,...
.13dd	8d fe 7f	         sta ra
.13e0	68		         pla     ;s:pcl,pch,ry,rx,...
.13e1	8d ff 7f	         sta rp  ;s:pch,ry,rx,ra,rp,...
.13e4	68		         pla
.13e5	8d f9 7f	         sta pc  ;sauve pcl
.13e8	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.13e9	8d fa 7f	         sta pc+1;sauve pch
.13ec	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.13ed	a8		         tay     ;recupere ry
.13ee	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.13ef	aa		         tax     ;recupere rx
.13f0	68		         pla     ;s:rp,fe,fd,fc,fb
.13f1	8d fe 7f	         sta ra  ;recupere ra
.13f4	68		         pla     ;s:fe,fd,fc,fb
.13f5	8d ff 7f	         sta rp  ;recupere les flags.
.13f8	68		         pla     ;s:fd,fc,fb
.13f9	85 fe		         sta $fe ;reccupere fe
.13fb	68		         pla     ;s:fc,fb
.13fc	85 fd		         sta $fd ;recupere fd
.13fe	68		         pla     ;s:fb
.13ff	85 fc		         sta $fc ;recupere fc
.1401	68		         pla     ;s:
.1402	85 fb		         sta $fb ;recupere fb
.1404	ad fa 7f	         lda pc+1;replaace l'adresse de
.1407	48		         pha     ;s:pch
.1408	ad f9 7f	         lda pc  ;retour sur la pile
.140b	48		         pha     ;s:pcl,pch
.140c	ad ff 7f	         lda rp  ;recupere les flags
.140f	48		         pha     ;s:rp,pcl,pch
.1410	ad fe 7f	         lda ra  ;recupere ra
.1413	28		         plp     ;s:pcl,pch
.1414	60		         rts
.1415			pushregs
.1415	08		         php     ;s;rp,pcl,pch
.1416	8d fe 7f	         sta ra  ; -- sauve a
.1419	68		         pla     ;s:pcl,pch
.141a	8d ff 7f	         sta rp  ; -- sauve rp
.141d	68		         pla     ;s:pch
.141e	8d f9 7f	         sta pc  ; -- sauve pcl
.1421	68		         pla     ;s:
.1422	8d fa 7f	         sta pc+1; -- sauve pch
.1425	ad ff 7f	         lda rp  ; -- sauve rp
.1428	48		         pha     ;s:rp
.1429	ad fe 7f	         lda ra  ; -- sauve ra
.142c	48		         pha     ;s:ra,rp
.142d	8a		         txa     ; -- tfr rx
.142e	48		         pha     ;s:rx,ra,rp
.142f	98		         tya     ; -- tfr ry
.1430	48		         pha     ;s:ry,rx,ra,rp
.1431	ad fa 7f	         lda pc+1; -- replace l'adresse
.1434	48		         pha     ;s:pch,ry,rx,ra,rp
.1435	ad f9 7f	         lda pc  ; -- de retour.
.1438	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.1439	ad ff 7f	         lda rp  ; -- place les flags
.143c	48		         pha     ;    sur le stack.
.143d	ad fe 7f	         lda ra  ; -- recupere ra
.1440	28		         plp     ; -- recupere flags.
.1441	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1442			popregs
.1442	08		         php
.1443	8d fe 7f	         sta ra
.1446	68		         pla
.1447	8d ff 7f	         sta rp
.144a	68		         pla     ;s:pch,ry,rx,ra,rp
.144b	8d f9 7f	         sta pc  ; -- sauve pcl
.144e	68		         pla     ;s:ry,rx,ra,rp
.144f	8d fa 7f	         sta pc+1; -- sauve pch
.1452	68		         pla     ;s:rx,ra,rp
.1453	a8		         tay     ;recupere ry
.1454	68		         pla     ;s:ra,rp
.1455	aa		         tax     ;recupere rx
.1456	68		         pla     ;s:rp
.1457	8d fe 7f	         sta ra  ;recupere ra
.145a	68		         pla     ;s:
.145b	8d ff 7f	         sta rp  ;recupere les flags.
.145e	ad fa 7f	         lda pc+1;replace l'adresse de
.1461	48		         pha     ;s:pch
.1462	ad f9 7f	         lda pc  ;retour sur la pile
.1465	48		         pha     ;s:pcl,pch
.1466	ad ff 7f	         lda rp  ;recupere les flags
.1469	48		         pha     ;s:rp,pcl,pch
.146a	ad fe 7f	         lda ra  ;recupere ra
.146d	28		         plp     ;s:pcl,pch
.146e	60		         rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.146f			puts
.146f	20 a3 13	          jsr pushall
.1472	a0 00		          ldy #$00   ; y = offset
.1474	b1 fb		nextc     lda ($fb),y;lit un caractere
.1476	f0 09		          beq out    ;si 0 on sort
.1478	20 7a f2	          jsr chrout ;on l'affiche
.147b	20 bc 15	          jsr inczp1 ;pointe le prochain
.147e	4c 74 14	          jmp nextc  ; et l'affiche
.1481	20 dc 13	out       jsr popall
.1484	60		          rts
.1485			putsyx
.1485	20 a3 13	          jsr pushall;sauve reg + zps
.1488	86 fb		          stx $fb    ;$yyxx dans
.148a	84 fc		          sty $fb+1  ; zp1
.148c	20 6f 14	          jsr puts
.148f	20 dc 13	          jsr popall ;recup reg + zps
.1492	60		          rts
.1493			putsxy
.1493	20 a3 13	        jsr pushall;sauve reg + zps
.1496	86 fb		        stx $fb    ;$yyxx dans
.1498	84 fc		        sty $fb+1  ; zp1
.149a	a0 00		        ldy #$00
.149c	b1 fb		        lda ($fb),y
.149e	aa		        tax
.149f	20 bc 15	        jsr inczp1
.14a2	b1 fb		        lda ($fb),y
.14a4	20 bc 15	        jsr inczp1
.14a7	a8		        tay
.14a8	20 fd 14	        jsr gotoxy
.14ab	20 6f 14	        jsr puts
.14ae	20 dc 13	        jsr popall ;recup reg + zps
.14b1	60		        rts
.14b2			putsc
.14b2	08		          php       ;flag sur stack
.14b3	48		          pha       ;acc sur stack
.14b4	48		          pha       ;sauvegarde acc
.14b5	ad 86 02	          lda kcol  ;recup coul. carac.
.14b8	8d f8 7f	          sta curcol; et la sauvegarde
.14bb	68		          pla       ;recup. acc
.14bc	8d 86 02	          sta kcol  ;place coul. voulue
.14bf	20 6f 14	          jsr puts  ;affiche la chaine
.14c2	ad f8 7f	          lda curcol;recup coul. carac.
.14c5	8d 86 02	          sta kcol  ; et la replace
.14c8	68		          pla       ;recup acc
.14c9	28		          plp       ;recup flag
.14ca	60		          rts
.14cb			putscyx
.14cb	08		          php       ;sauve registres
.14cc	48		          pha       ; ...
.14cd	48		          pha       ;sauve acc
.14ce	ad 86 02	          lda kcol  ;recup couleur carac.
.14d1	8d f8 7f	          sta curcol; et sauvegarde
.14d4	68		          pla       ;recup acc
.14d5	8d 86 02	          sta kcol  ;place couleur carac.
.14d8	20 85 14	          jsr putsyx;affiche la chaine
.14db	ad f8 7f	          lda curcol
.14de	8d 86 02	          sta kcol
.14e1	68		          pla
.14e2	28		          plp
.14e3	60		          rts
.14e4			putscxy
.14e4	08		          php       ;sauve registres
.14e5	48		          pha       ; ...
.14e6	48		          pha       ;sauve acc
.14e7	ad 86 02	          lda kcol  ;recup couleur carac.
.14ea	8d f8 7f	          sta curcol; et sauvegarde
.14ed	68		          pla       ;recup acc
.14ee	8d 86 02	          sta kcol   ;place couleur carac.
.14f1	20 85 14	          jsr putsyx ;affiche la chaine
.14f4	ad f8 7f	          lda curcol
.14f7	8d 86 02	          sta kcol
.14fa	68		          pla
.14fb	28		          plp
.14fc	60		          rts
.14fd			gotoxy
.14fd	20 15 14	          jsr pushregs
.1500	8a		          txa ; interchange x et y
.1501	48		          pha ; ...
.1502	98		          tya ; ...
.1503	aa		          tax ; ...
.1504	68		          pla ; ...
.1505	a8		          tay ; ...
.1506	c0 00		txlow     cpy #0
.1508	10 02		          bpl txhigh
.150a	a2 00		          ldx #0
.150c	e0 19		txhigh    cpx #25
.150e	30 02		          bmi tylow
.1510	a2 18		          ldx #24
.1512	c0 00		tylow     cpy #0
.1514	10 02		          bpl tyhigh
.1516	a0 00		          ldy #0
.1518	c0 28		tyhigh    cpy #40
.151a	30 02		          bmi allok
.151c	a0 27		          ldy #39
.151e	18		allok     clc
.151f	20 0a e5	          jsr plot
.1522	20 42 14	          jsr popregs
.1525	60		          rts
.1526			putnch
.1526	20 15 14	        jsr pushregs
.1529	20 7a f2	again   jsr chrout
.152c	ca		        dex
.152d	d0 fa		        bne again
.152f	20 42 14	        jsr popregs
.1532	60		        rts
.1533			strlen
.1533	20 a3 13	        jsr pushall
.1536	84 fc		        sty zp1+1
.1538	86 fb		        stx zp1
.153a	a0 00		        ldy #$00
.153c	8c 8a 7f	        sty len
.153f	b1 fb		next    lda (zp1),y
.1541	f0 07		        beq out
.1543	ee 8a 7f	        inc len
.1546	c8		        iny
.1547	4c 3f 15	        jmp next
.154a	20 dc 13	out     jsr popall
.154d	ad 8a 7f	        lda len
.1550	60		        rts
.1551			cursor
.1551	20 15 14	          jsr  pushregs
.1554	90 12		          bcc  get    ;C=0 récupération.
.1556	20 0a e5	          jsr  plot  ;récupère position
.1559	8c 89 7f	          sty  cx     ;curseur et sauve
.155c	8e 88 7f	          stx  cy     ;dans vars locales.
.155f	ad 86 02	          lda  kcol   ;Sauve couleur
.1562	8d 87 7f	          sta  bcol   ; BASIC du texte.
.1565	4c 77 15	          jmp  out    ;Fini on sort.
.1568	ae 88 7f	get       ldx  cy     ;C=1, charge x
.156b	ac 89 7f	          ldy  cx     ; ligne, y col.
.156e	20 0a e5	          jsr  plot  ;Position curseur.
.1571	ad 87 7f	          lda  bcol   ;replace couleur
.1574	8d 86 02	          sta  kcol ; basic sauvegardé.
.1577	20 42 14	out       jsr  popregs
.157a	60		          rts
.157b			curget
.157b			cursave
.157b	08		          php
.157c	38		          sec
.157d	20 51 15	          jsr  cursor
.1580	28		          plp
.1581	60		          rts
.1582			curput
.1582			currest
.1582	08		          php
.1583	18		          clc
.1584	20 51 15	          jsr  cursor
.1587	28		          plp
.1588	60		          rts
.1589			isprnable
.1589	08		          php
.158a	c9 a0		          cmp  #160
.158c	b0 0b		          bcs  yes
.158e	c5 85		          cmp  133
.1590	b0 04		          bcs  no
.1592	c9 21		          cmp  #33
.1594	b0 03		          bcs  yes
.1596	28		no        plp
.1597	18		          clc
.1598	60		          rts
.1599	28		yes       plp
.159a	38		          sec
.159b	60		          rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.159c			blkfill
.159c	20 a3 13	bf0     jsr pushall
.159f	84 fc		        sty zp1+1
.15a1	a0 00		        ldy #$00
.15a3	84 fb		        sty zp1
.15a5	91 fb		bf1     sta (zp1),y
.15a7	c8		        iny
.15a8	d0 fb		        bne bf1
.15aa	20 dc 13	        jsr popall
.15ad	60		        rts
.15ae			memfill
.15ae	20 15 14	        jsr pushregs
.15b1	20 9c 15	mf1     jsr blkfill
.15b4	c8		        iny
.15b5	ca		        dex
.15b6	d0 f9		        bne mf1
.15b8	20 42 14	        jsr popregs
.15bb	60		        rts
.15bc			inczp1
.15bc	08		         php
.15bd	e6 fb		         inc zp1
.15bf	d0 02		         bne repzp1
.15c1	e6 fc		         inc zp1+1
.15c3	28		repzp1   plp
.15c4	60		         rts
.15c5			inczp2
.15c5	08		         php
.15c6	e6 fd		         inc zp2
.15c8	d0 02		         bne repzp2
.15ca	e6 fe		         inc zp2+1
.15cc	28		repzp2   plp
.15cd	60		         rts
.15ce			deczp1
.15ce	08		         php
.15cf	48		         pha
.15d0	a5 fb		         lda zp1
.15d2	d0 02		         bne noemp
.15d4	c6 fc		         dec zp1+1
.15d6	c6 fb		noemp    dec zp1
.15d8	68		         pla
.15d9	28		         plp
.15da	60		         rts
.15db			deczp2
.15db	08		         php
.15dc	48		         pha
.15dd	a5 fd		         lda zp2
.15df	d0 02		         bne noemp
.15e1	c6 fe		         dec zp2+1
.15e3	c6 fd		noemp    dec zp2
.15e5	68		         pla
.15e6	28		         plp
.15e7	60		         rts
.15e8			rolzp1
.15e8	08		        php
.15e9	48		        pha
.15ea	18		        clc
.15eb	a5 fb		        lda zp1
.15ed	2a		        rol
.15ee	85 fb		        sta zp1
.15f0	a5 fc		        lda zp1+1
.15f2	2a		        rol
.15f3	85 fc		        sta zp1+1
.15f5	68		        pla
.15f6	28		        plp
.15f7			rorzp1
.15f7	08		        php
.15f8	48		        pha
.15f9	18		        clc
.15fa	a5 fc		        lda zp1+1
.15fc	6a		        ror
.15fd	85 fc		        sta zp1+1
.15ff	a5 fb		        lda zp1
.1601	6a		        ror
.1602	85 fb		        sta zp1
.1604	68		        pla
.1605	28		        plp
.1606			rolzp2
.1606	08		        php
.1607	48		        pha
.1608	18		        clc
.1609	a5 fd		        lda zp2
.160b	2a		        rol
.160c	85 fd		        sta zp2
.160e	a5 fe		        lda zp2+1
.1610	2a		        rol
.1611	85 fe		        sta zp2+1
.1613	68		        pla
.1614	28		        plp
.1615			rorzp2
.1615	08		        php
.1616	48		        pha
.1617	18		        clc
.1618	a5 fe		        lda zp2+1
.161a	6a		        ror
.161b	85 fe		        sta zp2+1
.161d	a5 fd		        lda zp2
.161f	6a		        ror
.1620	85 fd		        sta zp2
.1622	68		        pla
.1623	28		        plp
.1624			yxtoptr
.1624	8c f8 7f	        sty memptr+1
.1627	8e f7 7f	        stx memptr
.162a	60		        rts
.162b			ptrtoyx
.162b	08		        php
.162c	ac f8 7f	        ldy memptr+1
.162f	ae f7 7f	        ldx memptr
.1632	28		        plp
.1633	60		        rts
.1634			incptr
.1634	08		        php
.1635	ee f7 7f	        inc memptr
.1638	d0 03		        bne norep
.163a	ee f8 7f	        inc memptr+1
.163d	28		norep   plp
.163e	60		        rts
.163f			decptr
.163f	08		        php
.1640	48		        pha
.1641	ad f7 7f	        lda memptr
.1644	d0 03		        bne noemp
.1646	ee f8 7f	        inc memptr+1
.1649	ee f7 7f	noemp   inc memptr
.164c	68		        pla
.164d	28		        plp
.164e	60		        rts
.164f			incptr8
.164f	08		        php
.1650	48		        pha
.1651	98		        tya
.1652	48		        pha
.1653	a0 08		        ldy #8
.1655	20 34 16	again   jsr incptr
.1658	88		        dey
.1659	d0 fa		        bne again
.165b	68		        pla
.165c	a8		        tay
.165d	68		        pla
.165e	28		        plp
.165f	60		        rts
.1660			loop
.1660	ce f1 7f	               dec  loopcount
.1663	d0 03		               bne  norep
.1665	ce f2 7f	               dec  loopcount+1
.1668	ad f1 7f	norep          lda  loopcount
.166b	c9 00		               cmp  #$00
.166d	d0 05		               bne  out
.166f	4d f2 7f	               eor  loopcount+1
.1672	c9 ff		               cmp  #$ff
.1674	60		out            rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.1675			addtoword
.1675			addatoyx
.1675	08		        php
.1676	48		        pha
.1677	8c 98 7f	        sty reponse+1
.167a	8e 97 7f	        stx reponse
.167d	18		        clc
.167e	6d 97 7f	        adc reponse
.1681	90 03		        bcc norep
.1683	ee 98 7f	        inc reponse+1
.1686	8d 97 7f	norep   sta reponse
.1689	ac 98 7f	        ldy reponse+1
.168c	ae 97 7f	        ldx reponse
.168f	68		        pla
.1690	28		        plp
.1691	60		        rts
.1692			subtoword
.1692			subatoyx
.1692	08		        php
.1693	48		        pha
.1694	8c 98 7f	        sty reponse+1
.1697	8e 97 7f	        stx reponse
.169a	38		        sec
.169b	ed 97 7f	        sbc reponse
.169e	b0 03		        bcs noemp
.16a0	ce 98 7f	        dec reponse+1
.16a3	8d 97 7f	noemp   sta reponse
.16a6	ac 98 7f	        ldy reponse+1
.16a9	ae 97 7f	        ldx reponse
.16ac	68		        pla
.16ad	28		        plp
.16ae	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.16af			putyxhex
.16af	20 a3 13	        jsr pushall
.16b2	98		        tya
.16b3	48		        pha
.16b4	20 32 17	        jsr lsr4bits
.16b7	20 45 17	        jsr nibtohex
.16ba	8d ec 7f	        sta hexstr+0
.16bd	68		        pla
.16be	20 45 17	        jsr nibtohex
.16c1	8d ed 7f	        sta hexstr+1
.16c4	8a		        txa
.16c5	20 e4 16	        jsr atohex
.16c8	a2 ec		        ldx #<hexstr+0
.16ca	a0 7f		        ldy #>hexstr+0
.16cc	20 85 14	        jsr putsyx
.16cf	20 dc 13	        jsr popall
.16d2	60		        rts
.16d3			putahex
.16d3	20 15 14	        jsr pushregs
.16d6	20 e4 16	        jsr atohex
.16d9	a2 ee		        ldx #<hexstr+2
.16db	a0 7f		        ldy #>hexstr+2
.16dd	20 85 14	        jsr putsyx
.16e0	20 42 14	        jsr popregs
.16e3	60		        rts
.16e4			atohex
.16e4	08		        php
.16e5	48		        pha
.16e6	48		        pha
.16e7	20 32 17	        jsr lsr4bits
.16ea	20 45 17	        jsr nibtohex
.16ed	8d ee 7f	        sta hexstr+2
.16f0	68		        pla
.16f1	20 45 17	        jsr nibtohex
.16f4	8d ef 7f	        sta hexstr+3
.16f7	a9 00		        lda #$00
.16f9	8d f0 7f	        sta hexstr+4
.16fc	68		        pla
.16fd	28		        plp
.16fe	60		        rts
.16ff			putabin
.16ff	20 15 14	          jsr     pushregs
.1702	20 10 17	          jsr     atobin
.1705	a2 df		          ldx     #<binstr
.1707	a0 7f		          ldy     #>binstr
.1709	20 85 14	          jsr     putsyx
.170c	20 42 14	          jsr     popregs
.170f	60		          rts
.1710			atobin
.1710	20 15 14	          jsr  pushregs
.1713	a2 08		          ldx  #8
.1715	a0 00		          ldy  #0
.1717	18		          clc
.1718	2a		nextbit   rol
.1719	48		          pha
.171a	69 00		          adc  #$00
.171c	29 01		          and  #$01
.171e	20 45 17	          jsr  nibtohex
.1721	99 df 7f	          sta  binstr,y
.1724	68		          pla
.1725	c8		          iny
.1726	ca		          dex
.1727	d0 ef		          bne  nextbit
.1729	a9 00		          lda  #0
.172b	99 df 7f	          sta  binstr,y
.172e	20 42 14	          jsr  popregs
.1731	60		          rts
.1732			lsr4bits
.1732	08		          php
.1733	4a		          lsr a
.1734	4a		          lsr a
.1735	4a		          lsr a
.1736	4a		          lsr a
.1737	28		          plp
.1738	60		          rts
.1739			nibtohexb
.1739	08		        php
.173a	29 0f		        and #$0f
.173c	f8		        sed
.173d	18		        clc
.173e	69 90		        adc #$90
.1740	69 40		        adc #$40
.1742	d8		        cld
.1743	28		        plp
.1744	60		        rts
.1745			nibtohex
.1745	08		        php
.1746	8c 64 17	        sty myy
.1749	29 0f		        and #$0f
.174b	a8		        tay
.174c	b9 54 17	        lda hextbl,y
.174f	ac 64 17	        ldy myy
.1752	28		        plp
.1753	60		        rts
>1754	30 31 32 33	hextbl  .byte $30,$31,$32,$33,$34
>1758	34
>1759	35 36 37 38	        .byte $35,$36,$37,$38,$39
>175d	39
>175e	41 42 43 44	        .byte $41,$42,$43,$44,$45
>1762	45
>1763	46		        .byte $46
>1764	00		myy     .byte $00
.1765			bytestohex
.1765	20 a3 13	        jsr pushall
.1768	84 fc		        sty zp1+1
.176a	86 fb		        stx zp1
.176c	08		            php
.176d	48		            pha
.176e	a9 20		            lda #32
.1770	20 7a f2	            jsr chrout
.1773	68		            pla
.1774	28		            plp
.1775	08		            php
.1776	48		            pha
.1777	a9 05		            lda #5
.1779	20 7a f2	            jsr chrout
.177c	68		            pla
.177d	28		            plp
.177e	08		            php
.177f	48		            pha
.1780	a9 24		            lda #36
.1782	20 7a f2	            jsr chrout
.1785	68		            pla
.1786	28		            plp
.1787	20 af 16	        jsr putyxhex   ; prn adreponsese
.178a	08		            php
.178b	48		            pha
.178c	a9 20		            lda #$20
.178e	20 7a f2	            jsr chrout
.1791	68		            pla
.1792	28		            plp
.1793	08		            php
.1794	48		            pha
.1795	a9 9f		            lda #159
.1797	20 7a f2	            jsr chrout
.179a	68		            pla
.179b	28		            plp
.179c	a0 00		        ldy #$00
.179e	aa		        tax
.179f	8c d0 7f	another sty offset
.17a2	b1 fb		        lda (zp1),y
.17a4	20 d3 16	        jsr putahex
.17a7	48		        pha
.17a8	20 c7 17	        jsr petsciiaddr
.17ab	68		        pla
.17ac	8d 00 04	petscii sta $0400
.17af	48		        pha
.17b0	a9 0d		        lda #$0d
.17b2	8d 00 d8	petcol  sta $d800
.17b5	68		        pla
.17b6	08		            php
.17b7	48		            pha
.17b8	a9 20		            lda #$20
.17ba	20 7a f2	            jsr chrout
.17bd	68		            pla
.17be	28		            plp
.17bf	c8		        iny
.17c0	ca		        dex
.17c1	d0 dc		        bne another
.17c3	20 dc 13	        jsr popall
.17c6	60		        rts
.17c7			petsciiaddr
.17c7	20 15 14	        jsr pushregs
.17ca	a9 1f		        lda #31
.17cc	18		        clc
.17cd	6d d0 7f	        adc offset
.17d0	20 75 16	        jsr addatoyx
.17d3	8c ae 17	        sty petscii+2
.17d6	8e ad 17	        stx petscii+1
.17d9	8e b3 17	        stx petcol+1
.17dc	98		        tya
.17dd	29 fb		        and #%11111011 ;#%00000100
.17df	09 d8		        ora #$d8
.17e1	8d b4 17	        sta petcol+2
.17e4	a8		        tay
.17e5	20 42 14	        jsr popregs
.17e8	60		        rts
.17e9			strhexval
.17e9	20 a3 13	        jsr pushall ; sauve registre
.17ec	84 fc		        sty zp1+1   ; ptr dans zp1
.17ee	86 fb		        stx zp1
.17f0	20 33 15	        jsr strlen  ;len de $(yyxx)->a
.17f3	f0 3d		        beq oute    ; si 0 erreur C=1
.17f5	a0 00		        ldy #$00    ; offset a 0
.17f7	8c 98 7f	        sty reponse+1; reponse a zero
.17fa	8c 97 7f	        sty reponse ;    ...
.17fd	b1 fb		nextc   lda (zp1),y ;charge un caractere
.17ff	f0 26		        beq out     ;On  a fini
.1801	c0 00		        cpy #$00    ;si c'est le premier
.1803	f0 07		        beq norol   ; pas de rol
.1805	48		        pha         ;
.1806	a9 04		        lda #$04    ;rol de 4 pos
.1808	20 f2 18	        jsr rolword ;
.180b	68		        pla         ;
.180c	09 20		norol   ora #%00100000
.180e	38		        sec
.180f	e9 30		        sbc #$30
.1811	c9 0a		        cmp #$0a
.1813	90 07		        bcc lt10
.1815	38		        sec
.1816	e9 27		        sbc #$27
.1818	c9 10		        cmp #$10
.181a	b0 16		        bcs oute
.181c	0d 97 7f	lt10    ora reponse
.181f	8d 97 7f	        sta reponse
.1822	c8		        iny
.1823	c0 04		        cpy #$04
.1825	d0 d6		        bne nextc
.1827	20 dc 13	out     jsr popall
.182a	18		        clc          ;Carry 0 = good
.182b	ac 98 7f	        ldy reponse+1
.182e	ae 97 7f	        ldx reponse
.1831	60		        rts
.1832	20 dc 13	oute    jsr popall
.1835	38		        sec
.1836	60		        rts
.1837			showra
.1837	20 15 14	          jsr  pushregs
.183a	ac 86 02	          ldy  kcol
.183d	08		            php
.183e	48		            pha
.183f	a9 90		            lda #snoir
.1841	20 7a f2	            jsr chrout
.1844	68		            pla
.1845	28		            plp
.1846	20 89 15	          jsr  isprnable
.1849	b0 13		          bcs  okprn
.184b	48		          pha
.184c	08		            php
.184d	48		            pha
.184e	a9 1c		            lda #srouge
.1850	20 7a f2	            jsr chrout
.1853	68		            pla
.1854	28		            plp
.1855	a9 2e		          lda  #'.'
.1857	20 7a f2	          jsr  chrout
.185a	68		          pla
.185b	4c 61 18	          jmp  noprn
.185e	20 7a f2	okprn     jsr  chrout
.1861			noprn
.1861	08		            php
.1862	48		            pha
.1863	a9 20		            lda #32
.1865	20 7a f2	            jsr chrout
.1868	68		            pla
.1869	28		            plp
.186a	08		            php
.186b	48		            pha
.186c	a9 1f		            lda #sbleu
.186e	20 7a f2	            jsr chrout
.1871	68		            pla
.1872	28		            plp
.1873	08		            php
.1874	48		            pha
.1875	a9 24		            lda #36
.1877	20 7a f2	            jsr chrout
.187a	68		            pla
.187b	28		            plp
.187c	20 d3 16	          jsr putahex
.187f	08		            php
.1880	48		            pha
.1881	a9 20		            lda #32
.1883	20 7a f2	            jsr chrout
.1886	68		            pla
.1887	28		            plp
.1888	08		            php
.1889	48		            pha
.188a	a9 1c		            lda #srouge
.188c	20 7a f2	            jsr chrout
.188f	68		            pla
.1890	28		            plp
.1891	08		            php
.1892	48		            pha
.1893	a9 25		            lda #37
.1895	20 7a f2	            jsr chrout
.1898	68		            pla
.1899	28		            plp
.189a	20 ff 16	          jsr putabin
.189d	08		            php
.189e	48		            pha
.189f	a9 20		            lda #32
.18a1	20 7a f2	            jsr chrout
.18a4	68		            pla
.18a5	28		            plp
.18a6	08		            php
.18a7	48		            pha
.18a8	a9 9c		            lda #smauve
.18aa	20 7a f2	            jsr chrout
.18ad	68		            pla
.18ae	28		            plp
.18af	48		          pha
.18b0	aa		          tax
.18b1	a9 00		          lda #$00
.18b3	20 cd dd	          jsr fiaxtf1
.18b6	68		          pla
.18b7	8c 86 02	          sty kcol
.18ba	20 42 14	          jsr popregs
.18bd	60		          rts
.18be			putahexdec
.18be	20 15 14	          jsr pushregs
.18c1	20 7b 15	          jsr  curget    ; Sauvegarde la position du curseur.
.18c4	20 15 14	        jsr pushregs
.18c7	a0 01		        ldy #1
.18c9	a2 16		        ldx #22
.18cb	18		        clc
.18cc	20 0a e5	        jsr plot
.18cf	20 42 14	        jsr popregs
.18d2	08		            php
.18d3	48		            pha
.18d4	a9 20		            lda #32
.18d6	20 7a f2	            jsr chrout
.18d9	68		            pla
.18da	28		            plp
.18db	20 37 18	          jsr  showra    ; Affiche .a en ascii, hexa, bin et dec.
.18de	c9 63		          cmp  #99       ; Estce que le code ascii est > 99 dec.
.18e0	10 09		          bpl  nospc     ; Non, on saute.
.18e2	08		            php
.18e3	48		            pha
.18e4	a9 20		            lda #32
.18e6	20 7a f2	            jsr chrout
.18e9	68		            pla
.18ea	28		            plp
.18eb	20 82 15	nospc     jsr  curput    ; Replkace le curseur à sa position initiale.
.18ee	20 42 14	          jsr popregs
.18f1	60		          rts
.18f2			rolword
.18f2	20 15 14	        jsr pushregs
.18f5	a8		        tay
.18f6	18		again   clc
.18f7	2e 97 7f	        rol reponse
.18fa	2e 98 7f	        rol reponse+1
.18fd	88		        dey
.18fe	d0 f6		        bne again
.1900	20 42 14	        jsr popregs
.1903	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.1904			clrkbbuf
.1904	08		          php
.1905	48		          pha
.1906	a9 00		          lda #0
.1908	85 c6		          sta 198
.190a	20 e1 ff	          jsr $ffe1
.190d	68		          pla
.190e	28		          plp
.190f	60		          rts
.1910			waitstop
.1910	08		          php    ;\ sauve les flags
.1911	48		          pha    ;/  et l'acc.
.1912	20 04 19	          jsr clrkbbuf
.1915	20 70 f7	wait      jsr stop ; Veri [run/stop]
.1918	d0 fb		          bne wait ;loop pas pesee.
.191a	68		          pla    ;\ recup. acc et
.191b	28		          plp    ;/  les flags.
.191c	60		          rts
.191d			anykey
.191d	08		          php
.191e	48		          pha
.191f	20 04 19	          jsr clrkbbuf
.1922	a5 cb		wait      lda 203    ;lit la matrice de
.1924	c9 40		          cmp #64    ; 64 = aucune clef
.1926	f0 fa		          beq wait   ; on en attend une.
.1928	20 31 19	          jsr kbfree ; Clavier relache.
.192b	20 04 19	          jsr clrkbbuf
.192e	68		          pla
.192f	28		          plp
.1930	60		          rts
.1931			kbfree
.1931	08		        php
.1932	48		        pha
.1933	a5 cb		wait    lda 203    ; lit la matrice
.1935	c9 40		        cmp #64    ; 64 = aucune clef
.1937	d0 fa		        bne wait   ; attend la relache
.1939	68		        pla
.193a	28		        plp
.193b	60		        rts
.193c			getkey
.193c	08		        php
.193d	20 e1 ff	        jsr $ffe1
.1940	20 f5 f1	try     jsr getin  ;tente de lire
.1943	c9 00		        cmp #0     ; 0 si aucune.
.1945	f0 f9		        beq try    ; on reessaye
.1947	28		        plp
.1948	60		        rts
.1949			waitkey
.1949	08		        php
.194a	48		        pha
.194b	8d 8b 7f	        sta clef   ;Sauve clef voulue
.194e	20 04 19	        jsr clrkbbuf
.1951	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.1954	cd 8b 7f	        cmp clef   ;Compare avec clef
.1957	d0 f8		        bne wait   ;Pas la bonne.
.1959	68		        pla
.195a	28		        plp
.195b	60		        rts
.195c			waitspace
.195c	a9 20		          lda #$20
.195e	20 49 19	          jsr waitkey
.1961	20 04 19	          jsr clrkbbuf
.1964	60		          rts
.1965			showkey
.1965	20 15 14	        jsr pushregs
.1968	38		        sec
.1969	20 0a e5	        jsr plot
.196c	8e 8d 7f	        stx curx
.196f	8c 8c 7f	        sty cury
.1972	20 15 14	        jsr pushregs
.1975	a0 00		        ldy #0
.1977	a2 16		        ldx #22
.1979	18		        clc
.197a	20 0a e5	        jsr plot
.197d	20 42 14	        jsr popregs
.1980	20 7a f2	        jsr chrout
.1983	20 37 18	        jsr showra
.1986	18		        clc
.1987	ac 8c 7f	        ldy cury
.198a	ae 8d 7f	        ldx curx
.198d	20 0a e5	        jsr plot
.1990	20 42 14	        jsr popregs
.1993	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-screen.asm

.1994			scrnsave
.1994	20 a3 13	        jsr pushall
.1997	20 ec 19	        jsr setcarptr
.199a	20 ba 19	        jsr zp1tozp2
.199d	20 03 1a	        jsr setcolptr
.19a0	20 ba 19	        jsr zp1tozp2
.19a3	20 dc 13	        jsr popall
.19a6	60		        rts
.19a7			scrnrest
.19a7	20 a3 13	        jsr pushall
.19aa	20 ec 19	        jsr setcarptr
.19ad	20 d3 19	        jsr zp2tozp1
.19b0	20 03 1a	        jsr setcolptr
.19b3	20 d3 19	        jsr zp2tozp1
.19b6	20 dc 13	        jsr popall
.19b9	60		        rts
.19ba			zp1tozp2
.19ba	20 a3 13	        jsr pushall
.19bd	a2 02		        ldx #>scrlen
.19bf	a0 00		        ldy #<scrlen
.19c1	b1 fb		nextcar lda (zp1),y
.19c3	91 fd		        sta (zp2),y
.19c5	c8		        iny
.19c6	d0 f9		        bne nextcar
.19c8	e6 fc		        inc zp1+1
.19ca	e6 fe		        inc zp2+1
.19cc	ca		        dex
.19cd	d0 f2		        bne nextcar
.19cf	20 dc 13	        jsr popall
.19d2	60		        rts
.19d3			zp2tozp1
.19d3	20 a3 13	        jsr pushall
.19d6	a2 02		        ldx #>scrlen
.19d8	a0 00		        ldy #<scrlen
.19da	b1 fd		nextcar lda (zp2),y
.19dc	91 fb		        sta (zp1),y
.19de	c8		        iny
.19df	d0 f9		        bne nextcar
.19e1	e6 fc		        inc zp1+1
.19e3	e6 fe		        inc zp2+1
.19e5	ca		        dex
.19e6	d0 f2		        bne nextcar
.19e8	20 dc 13	        jsr popall
.19eb	60		        rts
.19ec			setcarptr
.19ec	20 15 14	        jsr pushregs
.19ef	a9 00		        lda #<scrtxt
.19f1	85 fb		        sta zp1
.19f3	a9 10		        lda #>scrtxt
.19f5	85 fc		        sta zp1+1
.19f7	a9 84		        lda #<scrncar
.19f9	85 fd		        sta zp2
.19fb	a9 7d		        lda #>scrncar
.19fd	85 fe		        sta zp2+1
.19ff	20 42 14	        jsr popregs
.1a02	60		        rts
.1a03			setcolptr
.1a03	20 15 14	        jsr pushregs
.1a06	a9 00		        lda #<scrcol
.1a08	85 fb		        sta zp1
.1a0a	a9 94		        lda #>scrcol
.1a0c	85 fc		        sta zp1+1
.1a0e	a9 84		        lda #<scrncol
.1a10	85 fd		        sta zp2
.1a12	a9 7b		        lda #>scrncol
.1a14	85 fe		        sta zp2+1
.1a16	20 42 14	        jsr popregs
.1a19	60		        rts
.1a1a			fillscreen
.1a1a	20 a3 13	          jsr pushall
.1a1d	a2 03		          ldx #$03
.1a1f	a0 00		          ldy #$00
.1a21	a9 66		          lda #102
.1a23	99 00 10	again     sta scrtxt,y
.1a26	99 00 11	          sta scrtxt+256,y
.1a29	48		          pha
.1a2a	8a		          txa
.1a2b	99 00 94	          sta scrcol,y
.1a2e	99 00 95	          sta scrcol+256,y
.1a31	68		          pla
.1a32	c8		          iny
.1a33	d0 ee		          bne again
.1a35	20 dc 13	          jsr popall
.1a38	60		          rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=$8000			libre    = $8000   ; *+3085
=32767			rp       = libre-$01;1 byte $cfff
=32766			ra       = rp-1     ;1 byte $cffe
=32765			rx       = ra-1     ;1 byte $cffd
=32764			ry       = rx-1     ;1 byte $cffc
=32763			rs       = ry-1     ;1 byte $cffb
=32761			pc       = rs-2     ;2 byte $cff9-$cffa
=32760			curcol   = pc-1     ;1 byte $cff6
=32759			memptr   = curcol-1;1 word $cff7-$cff8
=32757			src      = memptr-2
=32755			dst      = memptr-4
=32753			loopcount = memptr-6
=32753			hexv     = loopcount
.1a39			a2hexstr
=32748			hexstr   = hexv-$05 ;5 byte
=32747			a2hexpfx = hexv-$06 ;1 byte
=32746			a2hexpy  = hexv-$07 ;1 byte
=32745			a2hexpx  = hexv-$08 ;1 byte
=32745			a2hexpos = hexv-$08 ;0 byte
=32744			a2hexcol = hexv-$09 ;1 byte
=32744			binv     = a2hexcol
=32735			binstr   = binv-$09 ;9 byte
=32734			a2binpfx = binv-$0a ;1 byte
=32733			a2binpy  = binv-$0b ;1 byte
=32732			a2binpx  = binv-$0c ;1 byte
=32732			a2binpos = binv-$0c ;0 byte
=32731			a2bincol = binv-$0d ;1 byte
=32731			decv     = a2bincol
=32725			decstr   = decv-$06 ;6 byte
=32724			a2decpfx = decv-$07 ;1 byte
=32723			a2decpy  = decv-$08 ;1 byte
=32722			a2decpx  = decv-$09 ;1 byte
=32722			a2decpos = decv-$09 ;0 byte
=32721			a2deccol = decv-$0a ;1 byte
=32720			offset   = decv-$0b ;1 byte
=32720			fltv     = offset
=32714			fvar1    = fltv-6  ; 6 byte
=32708			fvar2    = fltv-12 ; 6 byte
=32688			float1   = fltv-32 ;20 byte
=32668			float2   = fltv-52 ;20 byte
=32667			tval1    = fltv-53 ; 1 byte
=32665			tval2    = fltv-55 ; 2 byte
=32663			reponse  = tval2-2 ; 2 byte
=32663			edbox    = reponse
=32662			cleft    = edbox-1 ;1 byte
=32661			cright   = edbox-2 ;1 byte
=32660			cmid     = edbox-3 ;1 byte
=32659			dbtop    = edbox-4 ;1 byte
=32658			dbleft   = edbox-5 ;1 byte
=32657			dbwdth   = edbox-6 ;1 byte
=32656			dbhght   = edbox-7 ;1 byte
=32655			dbcoul   = edbox-8 ;1 byte
=32654			dbclin   = edbox-9 ;1 byte
=32654			ekeyb    = dbclin
=32653			curx     = ekeyb-1 ;1 byte
=32652			cury     = ekeyb-2 ;1 byte
=32651			clef     = ekeyb-3 ;1 byte
=32650			len      = clef-1  ;1 byte
=32649			cx       = clef-2  ;1 byte
=32648			cy       = clef-3  ;1 byte
=32647			bcol     = clef-4  ;1 byte
=32647			escr     = bcol         ;2051 bytes
=32646			loops    = escr-1       ;   1 byte
=32644			loop16   = loops-2      ;   2 byte
=32132			scrncar  = loop16-$200  ;  1k byte
=31620			scrncol  = scrncar-$200 ;  1k byte
=31620			diskvar = scrncol
=31618			ddatas  = diskvar-2 ;2 byte Data start
=31616			ddatae  = diskvar-4 ;2 byte Data end
=31615			ddev    = diskvar-5 ;1 byte Dev number
=31614			dlfsno  = diskvar-6 ;1 byte Lfs
=31612			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=31611			dfnlen  = diskvar-9 ;1 byte lenfilename
=31610			genbyte1 = dfnlen-1 ; 1 byte
=31608			genword1 = dfnlen-3 ; 2 byte
=31607			endofvars = genword1-1

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm

.1a39			R

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			ffac1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			ffac1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; f1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; f1=atn(f1).

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.1a39	4c b2 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: keyfinder.asm


;******  End of listing
