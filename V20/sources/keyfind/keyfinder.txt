
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L keyfinder.txt -o keyfinder.prg keyfinder.asm
; Tue Jan 27 17:32:57 2026

;Offset	;Hex		;Source

;******  Processing input file: keyfinder.asm

="20260127-161114"	version  = "20260127-161114"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

=$1000			scrtxt    = $1000
=$9400			scrcol    = $9400
=$0200			scrlen    = $0200
>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	34 36 32 31	         .text "4621";adresse du debut
>120a	00		         .byte $00   ;fin de cmd basic.
>120b	00 00		bcmd2    .word $00   ;adresse de la pro-
.120d	20 13 12	        jsr bhscrini
.1210	4c af 12	basnold jmp main
.1213			bhscrini
.1213	08		        php
.1214	48		        pha
.1215	a9 84		        lda #(128+4)
.1217	8d 00 90	        sta vic0
.121a	ad 0f 90	bord    lda $900f    ;place la couleur
.121d	29 08		        and #%00001000
.121f	09 e3		        ora #%11100011
.1221	8d 0f 90	        sta $900f
.1224	a9 00		text    lda #$00    ;place la couleur
.1226	8d 86 02	        sta $0286   ; du texte.
.1229	a9 93		        lda #$93    ;efface l'ecran par
.122b	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.122e	68		        pla
.122f	28		        plp
.1230	60		        rts
.1231			bhprint
.1231	a0 00		        ldy #$00
.1233	b1 fb		nextc   lda ($fb),y
.1235	f0 07		        beq end
.1237	c8		        iny
.1238	20 d2 ff	        jsr $ffd2
.123b	4c 33 12	        jmp nextc
.123e	60		end     rts

;******  Return to file: keyfinder.asm


;******  Processing file: string-fr.asm

>123f	20 20 20 20	spaces         .null "     "
>1243	20 00
>1245	0d 0d 20 20	bonjour        .byte $0d,$0d,32,32,revson
>1249	12
>124a	20 42 4f 4e	               .text " bonjour & merci! "
>124e	4a 4f 55 52 20 26 20 4d 45 52 43 49 21 20
>125c	92 0d 00	               .byte revsoff,$0d,0
>125f	20 90 12	texte0         .byte 32,snoir,revson        ;0-2
>1262	43 48 45 52	               .text "chercheur code clef" ;3-23
>1266	43 48 45 55 52 20 43 4f 44 45 20 43 4c 45 46
>1275	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1279	00		               .byte 0
>127a	20 1f 92	texte1         .byte 32,sbleu,revsoff
>127d	20 5b 45 53	               .text " [esc] pour sortir "
>1281	43 5d 20 50 4f 55 52 20 53 4f 52 54 49 52 20
>1290	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1294	00		               .byte 0
>1295	20 90 92	ligne          .byte 32,snoir,revsoff        ;0-2
>1298	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;3-8   ;1
>129c	c0
>129d	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;9-13
>12a1	c0
>12a2	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;14-18
>12a6	c0
>12a7	c0 c0 c0 c0	               .byte 192,192,192,192         ;19-23
>12ab	90 92 20	               .byte snoir,revsoff,32    ;24-27
>12ae	00		               .byte 0

;******  Return to file: keyfinder.asm

.12af			main
.12af	08		            php
.12b0	48		            pha
.12b1	a9 1b		            lda #(vblanc*16+(vocean|8))
.12b3	8d 0f 90	            sta  vic15
.12b6	a9 06		            lda #vbleu
.12b8	8d 86 02	            sta kcol
.12bb	a9 93		            lda #147
.12bd	20 d2 ff	            jsr $ffd2
.12c0	68		            pla
.12c1	28		            plp
.12c2	20 0f 19	               jsr scrnsave
.12c5	08		            php
.12c6	48		            pha
.12c7	a9 8e		            lda #upcase
.12c9	20 7a f2	            jsr chrout
.12cc	68		            pla
.12cd	28		            plp
.12ce	08		            php
.12cf	48		            pha
.12d0	a9 90		            lda #snoir
.12d2	20 7a f2	            jsr chrout
.12d5	68		            pla
.12d6	28		            plp
.12d7	20 38 14	          jsr  pushregs
.12da	a9 b0		          lda #176
.12dc	8d 5f 12	          sta texte0+0
.12df	a9 ae		          lda #174
.12e1	8d 77 12	          sta texte0+24
.12e4	a2 5f		          ldx  #<texte0
.12e6	a0 12		          ldy  #>texte0
.12e8	20 a8 14	          jsr  putsyx
.12eb	20 65 14	          jsr  popregs
.12ee	20 38 14	          jsr  pushregs
.12f1	a9 dd		          lda #221
.12f3	8d 7a 12	          sta texte1+0
.12f6	a9 dd		          lda #221
.12f8	8d 92 12	          sta texte1+24
.12fb	a2 7a		          ldx  #<texte1
.12fd	a0 12		          ldy  #>texte1
.12ff	20 a8 14	          jsr  putsyx
.1302	20 65 14	          jsr  popregs
.1305	20 38 14	          jsr  pushregs
.1308	a9 ad		          lda #173
.130a	8d 95 12	          sta ligne+0
.130d	a9 bd		          lda #189
.130f	8d ad 12	          sta ligne+24
.1312	a2 95		          ldx  #<ligne
.1314	a0 12		          ldy  #>ligne
.1316	20 a8 14	          jsr  putsyx
.1319	20 65 14	          jsr  popregs
.131c	20 c6 13	            jsr  pushall
.131f	a2 b0		            ldx  #<revision
.1321	86 fb		            stx  $fb
.1323	a0 13		            ldy  #>revision
.1325	84 fc		            sty  $fc
.1327	20 92 14	            jsr  puts
.132a	20 ff 13	            jsr  popall
.132d			morekey
.132d	08		            php
.132e	48		            pha
.132f	a9 1f		            lda #sbleu
.1331	20 7a f2	            jsr chrout
.1334	68		            pla
.1335	28		            plp
.1336	20 a8 18	               jsr getkey
.1339	08		            php
.133a	48		            pha
.133b	a9 0d		            lda #13
.133d	20 7a f2	            jsr chrout
.1340	68		            pla
.1341	28		            plp
.1342	20 c6 13	            jsr  pushall
.1345	a2 3f		            ldx  #<spaces
.1347	86 fb		            stx  $fb
.1349	a0 12		            ldy  #>spaces
.134b	84 fc		            sty  $fc
.134d	20 92 14	            jsr  puts
.1350	20 ff 13	            jsr  popall
.1353	08		            php
.1354	48		            pha
.1355	a9 5b		            lda #91
.1357	20 7a f2	            jsr chrout
.135a	68		            pla
.135b	28		            plp
.135c	20 7a f2	               jsr chrout
.135f	08		            php
.1360	48		            pha
.1361	a9 5d		            lda #93
.1363	20 7a f2	            jsr chrout
.1366	68		            pla
.1367	28		            plp
.1368	08		            php
.1369	48		            pha
.136a	a9 20		            lda #32
.136c	20 7a f2	            jsr chrout
.136f	68		            pla
.1370	28		            plp
.1371	08		            php
.1372	48		            pha
.1373	a9 24		            lda #36
.1375	20 7a f2	            jsr chrout
.1378	68		            pla
.1379	28		            plp
.137a	20 e3 16	               jsr putahex
.137d	08		            php
.137e	48		            pha
.137f	a9 20		            lda #32
.1381	20 7a f2	            jsr chrout
.1384	68		            pla
.1385	28		            plp
.1386	48		               pha
.1387	aa		               tax
.1388	a9 00		               lda #$00
.138a	20 cd dd	               jsr fiaxtf1
.138d	68		               pla
.138e	c9 5f		               cmp #95
.1390	f0 03		               beq out
.1392	4c 2d 13	               jmp morekey
.1395			out
.1395	08		            php
.1396	48		            pha
.1397	a9 1f		            lda #sbleu
.1399	20 7a f2	            jsr chrout
.139c	68		            pla
.139d	28		            plp
.139e	20 c6 13	            jsr  pushall
.13a1	a2 45		            ldx  #<bonjour
.13a3	86 fb		            stx  $fb
.13a5	a0 12		            ldy  #>bonjour
.13a7	84 fc		            sty  $fc
.13a9	20 92 14	            jsr  puts
.13ac	20 ff 13	            jsr  popall
.13af	60		               rts
>13b0	0d		revision       .byte $0d
>13b1	20 56 45 52	               .null format(" ver:%15s",version)
>13b5	3a 32 30 32 36 30 31 32 37 2d 31 36 31 31 31 34
>13c5	00

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.13c6			pushall
.13c6	08		         php     ;s;rp,pcl,pch
.13c7	8d b1 25	         sta ra  ;sauve a
.13ca	68		         pla     ;s:pcl,pch
.13cb	8d b2 25	         sta rp  ;sauve rp
.13ce	68		         pla     ;s:pch
.13cf	8d ac 25	         sta pc  ;sauve pcl
.13d2	68		         pla     ;s:
.13d3	8d ad 25	         sta pc+1;sauve pch
.13d6	a5 fb		         lda $fb ;sauve fb
.13d8	48		         pha     ;s:fb
.13d9	a5 fc		         lda $fc ;sauve fc
.13db	48		         pha     ;s:fc,fb
.13dc	a5 fd		         lda $fd ;sauve fd
.13de	48		         pha     ;s:fd,fc,fb
.13df	a5 fe		         lda $fe ;sauve fe
.13e1	48		         pha     ;s:fe,fd,fc,fb
.13e2	ad b2 25	         lda rp  ;sauve rp
.13e5	48		         pha     ;s:rp,fe,fd,fc,fb
.13e6	ad b1 25	         lda ra  ;sauve ra
.13e9	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.13ea	8a		         txa     ;sauve rx
.13eb	48		         pha     ;s:rx,ra,rp,fe-fb
.13ec	98		         tya     ;sauve y
.13ed	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.13ee	ad ad 25	         lda pc+1;replace l'adresse
.13f1	48		         pha     ;s:pch,ry,rx,ra,...
.13f2	ad ac 25	         lda pc  ; de retour.
.13f5	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.13f6	ad b2 25	         lda rp  ;place les flags
.13f9	48		         pha     ; sur le stack.
.13fa	ad b1 25	         lda ra  ;recupere ra
.13fd	28		         plp     ;recupere les flags.
.13fe	60		         rts
.13ff			popall
.13ff	08		         php     ;s:rp,pcl,pch,ry,rx,...
.1400	8d b1 25	         sta ra
.1403	68		         pla     ;s:pcl,pch,ry,rx,...
.1404	8d b2 25	         sta rp  ;s:pch,ry,rx,ra,rp,...
.1407	68		         pla
.1408	8d ac 25	         sta pc  ;sauve pcl
.140b	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.140c	8d ad 25	         sta pc+1;sauve pch
.140f	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.1410	a8		         tay     ;recupere ry
.1411	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.1412	aa		         tax     ;recupere rx
.1413	68		         pla     ;s:rp,fe,fd,fc,fb
.1414	8d b1 25	         sta ra  ;recupere ra
.1417	68		         pla     ;s:fe,fd,fc,fb
.1418	8d b2 25	         sta rp  ;recupere les flags.
.141b	68		         pla     ;s:fd,fc,fb
.141c	85 fe		         sta $fe ;reccupere fe
.141e	68		         pla     ;s:fc,fb
.141f	85 fd		         sta $fd ;recupere fd
.1421	68		         pla     ;s:fb
.1422	85 fc		         sta $fc ;recupere fc
.1424	68		         pla     ;s:
.1425	85 fb		         sta $fb ;recupere fb
.1427	ad ad 25	         lda pc+1;replaace l'adresse de
.142a	48		         pha     ;s:pch
.142b	ad ac 25	         lda pc  ;retour sur la pile
.142e	48		         pha     ;s:pcl,pch
.142f	ad b2 25	         lda rp  ;recupere les flags
.1432	48		         pha     ;s:rp,pcl,pch
.1433	ad b1 25	         lda ra  ;recupere ra
.1436	28		         plp     ;s:pcl,pch
.1437	60		         rts
.1438			pushregs
.1438	08		         php     ;s;rp,pcl,pch
.1439	8d b1 25	         sta ra  ; -- sauve a
.143c	68		         pla     ;s:pcl,pch
.143d	8d b2 25	         sta rp  ; -- sauve rp
.1440	68		         pla     ;s:pch
.1441	8d ac 25	         sta pc  ; -- sauve pcl
.1444	68		         pla     ;s:
.1445	8d ad 25	         sta pc+1; -- sauve pch
.1448	ad b2 25	         lda rp  ; -- sauve rp
.144b	48		         pha     ;s:rp
.144c	ad b1 25	         lda ra  ; -- sauve ra
.144f	48		         pha     ;s:ra,rp
.1450	8a		         txa     ; -- tfr rx
.1451	48		         pha     ;s:rx,ra,rp
.1452	98		         tya     ; -- tfr ry
.1453	48		         pha     ;s:ry,rx,ra,rp
.1454	ad ad 25	         lda pc+1; -- replace l'adresse
.1457	48		         pha     ;s:pch,ry,rx,ra,rp
.1458	ad ac 25	         lda pc  ; -- de retour.
.145b	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.145c	ad b2 25	         lda rp  ; -- place les flags
.145f	48		         pha     ;    sur le stack.
.1460	ad b1 25	         lda ra  ; -- recupere ra
.1463	28		         plp     ; -- recupere flags.
.1464	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1465			popregs
.1465	08		         php
.1466	8d b1 25	         sta ra
.1469	68		         pla
.146a	8d b2 25	         sta rp
.146d	68		         pla     ;s:pch,ry,rx,ra,rp
.146e	8d ac 25	         sta pc  ; -- sauve pcl
.1471	68		         pla     ;s:ry,rx,ra,rp
.1472	8d ad 25	         sta pc+1; -- sauve pch
.1475	68		         pla     ;s:rx,ra,rp
.1476	a8		         tay     ;recupere ry
.1477	68		         pla     ;s:ra,rp
.1478	aa		         tax     ;recupere rx
.1479	68		         pla     ;s:rp
.147a	8d b1 25	         sta ra  ;recupere ra
.147d	68		         pla     ;s:
.147e	8d b2 25	         sta rp  ;recupere les flags.
.1481	ad ad 25	         lda pc+1;replace l'adresse de
.1484	48		         pha     ;s:pch
.1485	ad ac 25	         lda pc  ;retour sur la pile
.1488	48		         pha     ;s:pcl,pch
.1489	ad b2 25	         lda rp  ;recupere les flags
.148c	48		         pha     ;s:rp,pcl,pch
.148d	ad b1 25	         lda ra  ;recupere ra
.1490	28		         plp     ;s:pcl,pch
.1491	60		         rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.1492			puts
.1492	20 c6 13	        jsr pushall
.1495	a0 00		        ldy #$00   ; y = offset
.1497	b1 fb		nextc   lda ($fb),y;lit un caractere
.1499	f0 09		        beq out    ;si 0 on sort
.149b	20 7a f2	        jsr chrout ;on l'affiche
.149e	20 cc 15	        jsr inczp1 ;pointe le prochain
.14a1	4c 97 14	        jmp nextc  ; et l'affiche
.14a4	20 ff 13	out     jsr popall
.14a7	60		        rts
.14a8			putsyx
.14a8	20 c6 13	        jsr pushall;sauve reg + zps
.14ab	86 fb		        stx $fb    ;$yyxx dans
.14ad	84 fc		        sty $fb+1  ; zp1
.14af	20 92 14	        jsr puts
.14b2	20 ff 13	        jsr popall ;recup reg + zps
.14b5	60		        rts
.14b6			putsxy
.14b6	20 c6 13	        jsr pushall;sauve reg + zps
.14b9	86 fb		        stx $fb    ;$yyxx dans
.14bb	84 fc		        sty $fb+1  ; zp1
.14bd	a0 00		        ldy #$00
.14bf	b1 fb		        lda ($fb),y
.14c1	aa		        tax
.14c2	20 cc 15	        jsr inczp1
.14c5	b1 fb		        lda ($fb),y
.14c7	20 cc 15	        jsr inczp1
.14ca	a8		        tay
.14cb	20 20 15	        jsr gotoxy
.14ce	20 92 14	        jsr puts
.14d1	20 ff 13	        jsr popall ;recup reg + zps
.14d4	60		        rts
.14d5			putsc
.14d5	08		        php        ;flag sur stack
.14d6	48		        pha        ;acc sur stack
.14d7	48		        pha        ;sauvegarde acc
.14d8	ad 86 02	        lda kcol   ;recup coul. carac.
.14db	8d ab 25	        sta curcol ; et la sauvegarde
.14de	68		        pla        ;recup. acc
.14df	8d 86 02	        sta kcol   ;place coul. voulue
.14e2	20 92 14	        jsr puts   ;affiche la chaine
.14e5	ad ab 25	        lda curcol ;recup coul. carac.
.14e8	8d 86 02	        sta kcol   ; et la replace
.14eb	68		        pla        ;recup acc
.14ec	28		        plp        ;recup flag
.14ed	60		        rts
.14ee			putscyx
.14ee	08		        php       ;sauve registres
.14ef	48		        pha       ; ...
.14f0	48		        pha       ;sauve acc
.14f1	ad 86 02	        lda kcol  ;recup couleur carac.
.14f4	8d ab 25	        sta curcol; et sauvegarde
.14f7	68		        pla       ;recup acc
.14f8	8d 86 02	        sta kcol  ;place couleur carac.
.14fb	20 a8 14	        jsr putsyx;affiche la chaine
.14fe	ad ab 25	        lda curcol
.1501	8d 86 02	        sta kcol
.1504	68		        pla
.1505	28		        plp
.1506	60		        rts
.1507			putscxy
.1507	08		        php       ;sauve registres
.1508	48		        pha       ; ...
.1509	48		        pha       ;sauve acc
.150a	ad 86 02	        lda kcol  ;recup couleur carac.
.150d	8d ab 25	        sta curcol; et sauvegarde
.1510	68		        pla       ;recup acc
.1511	8d 86 02	        sta kcol   ;place couleur carac.
.1514	20 a8 14	        jsr putsyx ;affiche la chaine
.1517	ad ab 25	        lda curcol
.151a	8d 86 02	        sta kcol
.151d	68		        pla
.151e	28		        plp
.151f	60		        rts
.1520			gotoxy
.1520	20 38 14	        jsr pushregs
.1523	8a		        txa ; interchange x et y
.1524	48		        pha ; ...
.1525	98		        tya ; ...
.1526	aa		        tax ; ...
.1527	68		        pla ; ...
.1528	a8		        tay ; ...
.1529	c0 00		txlow   cpy #0
.152b	10 02		        bpl txhigh
.152d	a2 00		        ldx #0
.152f	e0 19		txhigh  cpx #25
.1531	30 02		        bmi tylow
.1533	a2 18		        ldx #24
.1535	c0 00		tylow   cpy #0
.1537	10 02		        bpl tyhigh
.1539	a0 00		        ldy #0
.153b	c0 28		tyhigh  cpy #40
.153d	30 02		        bmi allok
.153f	a0 27		        ldy #39
.1541	18		allok   clc
.1542	20 0a e5	        jsr plot
.1545	20 65 14	        jsr popregs
.1548	60		        rts
.1549			putnch
.1549	20 38 14	        jsr pushregs
.154c	20 7a f2	again   jsr chrout
.154f	ca		        dex
.1550	d0 fa		        bne again
.1552	20 65 14	        jsr popregs
.1555	60		        rts
.1556			strlen
.1556	20 c6 13	        jsr pushall
.1559	84 fc		        sty zp1+1
.155b	86 fb		        stx zp1
.155d	a0 00		        ldy #$00
.155f	8c 3d 25	        sty len
.1562	b1 fb		next    lda (zp1),y
.1564	f0 07		        beq out
.1566	ee 3d 25	        inc len
.1569	c8		        iny
.156a	4c 62 15	        jmp next
.156d	20 ff 13	out     jsr popall
.1570	ad 3d 25	        lda len
.1573	60		        rts
.1574			cursor
.1574	20 38 14	        jsr  pushregs
.1577	90 12		        bcc  get    ;C=0 récupération.
.1579	20 0a e5	        jsr  plot  ;récupère position
.157c	8c 3c 25	        sty  cx     ;curseur et sauve
.157f	8e 3b 25	        stx  cy     ;dans vars locales.
.1582	ad 86 02	        lda  kcol   ;Sauve couleur
.1585	8d 3a 25	        sta  bcol   ; BASIC du texte.
.1588	4c 9a 15	        jmp  out    ;Fini on sort.
.158b	ae 3b 25	get     ldx  cy     ;C=1, charge x
.158e	ac 3c 25	        ldy  cx     ; ligne, y col.
.1591	20 0a e5	        jsr  plot  ;Position curseur.
.1594	ad 3a 25	        lda  bcol   ;replace couleur
.1597	8d 86 02	        sta  kcol ; basic sauvegardé.
.159a	20 65 14	out     jsr  popregs
.159d	60		        rts
.159e			cursave
.159e	08		        php
.159f	38		        sec
.15a0	20 74 15	        jsr  cursor
.15a3	28		        plp
.15a4	60		        rts
.15a5			curput
.15a5	08		        php
.15a6	18		        clc
.15a7	20 74 15	        jsr  cursor
.15aa	28		        plp
.15ab	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.15ac			blkfill
.15ac	20 c6 13	bf0     jsr pushall
.15af	84 fc		        sty zp1+1
.15b1	a0 00		        ldy #$00
.15b3	84 fb		        sty zp1
.15b5	91 fb		bf1     sta (zp1),y
.15b7	c8		        iny
.15b8	d0 fb		        bne bf1
.15ba	20 ff 13	        jsr popall
.15bd	60		        rts
.15be			memfill
.15be	20 38 14	        jsr pushregs
.15c1	20 ac 15	mf1     jsr blkfill
.15c4	c8		        iny
.15c5	ca		        dex
.15c6	d0 f9		        bne mf1
.15c8	20 65 14	        jsr popregs
.15cb	60		        rts
.15cc			inczp1
.15cc	08		         php
.15cd	e6 fb		         inc zp1
.15cf	d0 02		         bne repzp1
.15d1	e6 fc		         inc zp1+1
.15d3	28		repzp1   plp
.15d4	60		         rts
.15d5			inczp2
.15d5	08		         php
.15d6	e6 fd		         inc zp2
.15d8	d0 02		         bne repzp2
.15da	e6 fe		         inc zp2+1
.15dc	28		repzp2   plp
.15dd	60		         rts
.15de			deczp1
.15de	08		         php
.15df	48		         pha
.15e0	a5 fb		         lda zp1
.15e2	d0 02		         bne noemp
.15e4	c6 fc		         dec zp1+1
.15e6	c6 fb		noemp    dec zp1
.15e8	68		         pla
.15e9	28		         plp
.15ea	60		         rts
.15eb			deczp2
.15eb	08		         php
.15ec	48		         pha
.15ed	a5 fd		         lda zp2
.15ef	d0 02		         bne noemp
.15f1	c6 fe		         dec zp2+1
.15f3	c6 fd		noemp    dec zp2
.15f5	68		         pla
.15f6	28		         plp
.15f7	60		         rts
.15f8			rolzp1
.15f8	08		        php
.15f9	48		        pha
.15fa	18		        clc
.15fb	a5 fb		        lda zp1
.15fd	2a		        rol
.15fe	85 fb		        sta zp1
.1600	a5 fc		        lda zp1+1
.1602	2a		        rol
.1603	85 fc		        sta zp1+1
.1605	68		        pla
.1606	28		        plp
.1607			rorzp1
.1607	08		        php
.1608	48		        pha
.1609	18		        clc
.160a	a5 fc		        lda zp1+1
.160c	6a		        ror
.160d	85 fc		        sta zp1+1
.160f	a5 fb		        lda zp1
.1611	6a		        ror
.1612	85 fb		        sta zp1
.1614	68		        pla
.1615	28		        plp
.1616			rolzp2
.1616	08		        php
.1617	48		        pha
.1618	18		        clc
.1619	a5 fd		        lda zp2
.161b	2a		        rol
.161c	85 fd		        sta zp2
.161e	a5 fe		        lda zp2+1
.1620	2a		        rol
.1621	85 fe		        sta zp2+1
.1623	68		        pla
.1624	28		        plp
.1625			rorzp2
.1625	08		        php
.1626	48		        pha
.1627	18		        clc
.1628	a5 fe		        lda zp2+1
.162a	6a		        ror
.162b	85 fe		        sta zp2+1
.162d	a5 fd		        lda zp2
.162f	6a		        ror
.1630	85 fd		        sta zp2
.1632	68		        pla
.1633	28		        plp
.1634			yxtoptr
.1634	8c ab 25	        sty memptr+1
.1637	8e aa 25	        stx memptr
.163a	60		        rts
.163b			ptrtoyx
.163b	08		        php
.163c	ac ab 25	        ldy memptr+1
.163f	ae aa 25	        ldx memptr
.1642	28		        plp
.1643	60		        rts
.1644			incptr
.1644	08		        php
.1645	ee aa 25	        inc memptr
.1648	d0 03		        bne norep
.164a	ee ab 25	        inc memptr+1
.164d	28		norep   plp
.164e	60		        rts
.164f			decptr
.164f	08		        php
.1650	48		        pha
.1651	ad aa 25	        lda memptr
.1654	d0 03		        bne noemp
.1656	ee ab 25	        inc memptr+1
.1659	ee aa 25	noemp   inc memptr
.165c	68		        pla
.165d	28		        plp
.165e	60		        rts
.165f			incptr8
.165f	08		        php
.1660	48		        pha
.1661	98		        tya
.1662	48		        pha
.1663	a0 08		        ldy #8
.1665	20 44 16	again   jsr incptr
.1668	88		        dey
.1669	d0 fa		        bne again
.166b	68		        pla
.166c	a8		        tay
.166d	68		        pla
.166e	28		        plp
.166f	60		        rts
.1670			loop
.1670	ce a4 25	               dec  loopcount
.1673	d0 03		               bne  norep
.1675	ce a5 25	               dec  loopcount+1
.1678	ad a4 25	norep          lda  loopcount
.167b	c9 00		               cmp  #$00
.167d	d0 05		               bne  out
.167f	4d a5 25	               eor  loopcount+1
.1682	c9 ff		               cmp  #$ff
.1684	60		out            rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.1685			addtoword
.1685			addatoyx
.1685	08		        php
.1686	48		        pha
.1687	8c 4b 25	        sty reponse+1
.168a	8e 4a 25	        stx reponse
.168d	18		        clc
.168e	6d 4a 25	        adc reponse
.1691	90 03		        bcc norep
.1693	ee 4b 25	        inc reponse+1
.1696	8d 4a 25	norep   sta reponse
.1699	ac 4b 25	        ldy reponse+1
.169c	ae 4a 25	        ldx reponse
.169f	68		        pla
.16a0	28		        plp
.16a1	60		        rts
.16a2			subtoword
.16a2			subatoyx
.16a2	08		        php
.16a3	48		        pha
.16a4	8c 4b 25	        sty reponse+1
.16a7	8e 4a 25	        stx reponse
.16aa	38		        sec
.16ab	ed 4a 25	        sbc reponse
.16ae	b0 03		        bcs noemp
.16b0	ce 4b 25	        dec reponse+1
.16b3	8d 4a 25	noemp   sta reponse
.16b6	ac 4b 25	        ldy reponse+1
.16b9	ae 4a 25	        ldx reponse
.16bc	68		        pla
.16bd	28		        plp
.16be	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.16bf			putyxhex
.16bf	20 c6 13	        jsr pushall
.16c2	98		        tya
.16c3	48		        pha
.16c4	20 31 17	        jsr lsr4bits
.16c7	20 44 17	        jsr nibtohex
.16ca	8d 9f 25	        sta hexstr+0
.16cd	68		        pla
.16ce	20 44 17	        jsr nibtohex
.16d1	8d a0 25	        sta hexstr+1
.16d4	8a		        txa
.16d5	20 f4 16	        jsr atohex
.16d8	a2 9f		        ldx #<hexstr+0
.16da	a0 25		        ldy #>hexstr+0
.16dc	20 a8 14	        jsr putsyx
.16df	20 ff 13	        jsr popall
.16e2	60		        rts
.16e3			putahex
.16e3	20 38 14	        jsr pushregs
.16e6	20 f4 16	        jsr atohex
.16e9	a2 9f		        ldx #<hexstr; +2
.16eb	a0 25		        ldy #>hexstr; +2
.16ed	20 a8 14	        jsr putsyx
.16f0	20 65 14	        jsr popregs
.16f3	60		        rts
.16f4			atohex
.16f4	08		        php
.16f5	48		        pha
.16f6	48		        pha
.16f7	20 31 17	        jsr lsr4bits
.16fa	20 44 17	        jsr nibtohex
.16fd	8d 9f 25	        sta hexstr
.1700	68		        pla
.1701	20 44 17	        jsr nibtohex
.1704	8d a0 25	        sta hexstr+1
.1707	a9 00		        lda #$00
.1709	8d a1 25	        sta hexstr+2
.170c	68		        pla
.170d	28		        plp
.170e	60		        rts
.170f			atobin
.170f	20 38 14	        jsr  pushregs
.1712	a2 08		        ldx  #8
.1714	a0 00		        ldy  #0
.1716	18		        clc
.1717	2a		nextbit rol
.1718	48		        pha
.1719	69 00		        adc  #$00
.171b	29 01		        and  #$01
.171d	20 44 17	        jsr  nibtohex
.1720	99 92 25	        sta  binstr,y
.1723	68		        pla
.1724	c8		        iny
.1725	ca		        dex
.1726	d0 ef		        bne  nextbit
.1728	a9 00		        lda  #0
.172a	99 92 25	        sta  binstr,y
.172d	20 65 14	        jsr  popregs
.1730	60		        rts
.1731			lsr4bits
.1731	08		        php
.1732	4a		        lsr a
.1733	4a		        lsr a
.1734	4a		        lsr a
.1735	4a		        lsr a
.1736	28		        plp
.1737	60		        rts
.1738			nibtohexb
.1738	08		        php
.1739	29 0f		        and #$0f
.173b	f8		        sed
.173c	18		        clc
.173d	69 90		        adc #$90
.173f	69 40		        adc #$40
.1741	d8		        cld
.1742	28		        plp
.1743	60		        rts
.1744			nibtohex
.1744	08		        php
.1745	8c 63 17	        sty myy
.1748	29 0f		        and #$0f
.174a	a8		        tay
.174b	b9 53 17	        lda hextbl,y
.174e	ac 63 17	        ldy myy
.1751	28		        plp
.1752	60		        rts
>1753	30 31 32 33	hextbl  .byte $30,$31,$32,$33,$34
>1757	34
>1758	35 36 37 38	        .byte $35,$36,$37,$38,$39
>175c	39
>175d	41 42 43 44	        .byte $41,$42,$43,$44,$45
>1761	45
>1762	46		        .byte $46
>1763	00		myy     .byte $00
.1764			bytestohex
.1764	20 c6 13	        jsr pushall
.1767	84 fc		        sty zp1+1
.1769	86 fb		        stx zp1
.176b	08		            php
.176c	48		            pha
.176d	a9 20		            lda #32
.176f	20 7a f2	            jsr chrout
.1772	68		            pla
.1773	28		            plp
.1774	08		            php
.1775	48		            pha
.1776	a9 05		            lda #5
.1778	20 7a f2	            jsr chrout
.177b	68		            pla
.177c	28		            plp
.177d	08		            php
.177e	48		            pha
.177f	a9 24		            lda #36
.1781	20 7a f2	            jsr chrout
.1784	68		            pla
.1785	28		            plp
.1786	20 bf 16	        jsr putyxhex   ; prn adreponsese
.1789	08		            php
.178a	48		            pha
.178b	a9 20		            lda #$20
.178d	20 7a f2	            jsr chrout
.1790	68		            pla
.1791	28		            plp
.1792	08		            php
.1793	48		            pha
.1794	a9 9f		            lda #159
.1796	20 7a f2	            jsr chrout
.1799	68		            pla
.179a	28		            plp
.179b	a0 00		        ldy #$00
.179d	aa		        tax
.179e	8c 83 25	another sty offset
.17a1	b1 fb		        lda (zp1),y
.17a3	20 e3 16	        jsr putahex
.17a6	48		        pha
.17a7	20 c6 17	        jsr petsciiaddr
.17aa	68		        pla
.17ab	8d 00 04	petscii sta $0400
.17ae	48		        pha
.17af	a9 0d		        lda #$0d
.17b1	8d 00 d8	petcol  sta $d800
.17b4	68		        pla
.17b5	08		            php
.17b6	48		            pha
.17b7	a9 20		            lda #$20
.17b9	20 7a f2	            jsr chrout
.17bc	68		            pla
.17bd	28		            plp
.17be	c8		        iny
.17bf	ca		        dex
.17c0	d0 dc		        bne another
.17c2	20 ff 13	        jsr popall
.17c5	60		        rts
.17c6			petsciiaddr
.17c6	20 38 14	        jsr pushregs
.17c9	a9 1f		        lda #31
.17cb	18		        clc
.17cc	6d 83 25	        adc offset
.17cf	20 85 16	        jsr addatoyx
.17d2	8c ad 17	        sty petscii+2
.17d5	8e ac 17	        stx petscii+1
.17d8	8e b2 17	        stx petcol+1
.17db	98		        tya
.17dc	29 fb		        and #%11111011 ;#%00000100
.17de	09 d8		        ora #$d8
.17e0	8d b3 17	        sta petcol+2
.17e3	a8		        tay
.17e4	20 65 14	        jsr popregs
.17e7	60		        rts
.17e8			strhexval
.17e8	20 c6 13	        jsr pushall ; sauve registre
.17eb	84 fc		        sty zp1+1   ; ptr dans zp1
.17ed	86 fb		        stx zp1
.17ef	20 56 15	        jsr strlen  ;len de $(yyxx)->a
.17f2	f0 3d		        beq oute    ; si 0 erreur C=1
.17f4	a0 00		        ldy #$00    ; offset a 0
.17f6	8c 4b 25	        sty reponse+1; reponse a zero
.17f9	8c 4a 25	        sty reponse ;    ...
.17fc	b1 fb		nextc   lda (zp1),y ;charge un caractere
.17fe	f0 26		        beq out     ;On  a fini
.1800	c0 00		        cpy #$00    ;si c'est le premier
.1802	f0 07		        beq norol   ; pas de rol
.1804	48		        pha         ;
.1805	a9 04		        lda #$04    ;rol de 4 pos
.1807	20 61 18	        jsr rolword ;
.180a	68		        pla         ;
.180b	09 20		norol   ora #%00100000
.180d	38		        sec
.180e	e9 30		        sbc #$30
.1810	c9 0a		        cmp #$0a
.1812	90 07		        bcc lt10
.1814	38		        sec
.1815	e9 27		        sbc #$27
.1817	c9 10		        cmp #$10
.1819	b0 16		        bcs oute
.181b	0d 4a 25	lt10    ora reponse
.181e	8d 4a 25	        sta reponse
.1821	c8		        iny
.1822	c0 04		        cpy #$04
.1824	d0 d6		        bne nextc
.1826	20 ff 13	out     jsr popall
.1829	18		        clc          ;Carry 0 = good
.182a	ac 4b 25	        ldy reponse+1
.182d	ae 4a 25	        ldx reponse
.1830	60		        rts
.1831	20 ff 13	oute    jsr popall
.1834	38		        sec
.1835	60		        rts
.1836			putahexdec
.1836	20 38 14	        jsr pushregs
.1839	08		            php
.183a	48		            pha
.183b	a9 9e		            lda #sjaune
.183d	20 7a f2	            jsr chrout
.1840	68		            pla
.1841	28		            plp
.1842	20 e3 16	        jsr putahex
.1845	08		            php
.1846	48		            pha
.1847	a9 20		            lda #$20
.1849	20 7a f2	            jsr chrout
.184c	68		            pla
.184d	28		            plp
.184e	08		            php
.184f	48		            pha
.1850	a9 9f		            lda #socean
.1852	20 7a f2	            jsr chrout
.1855	68		            pla
.1856	28		            plp
.1857	aa		        tax
.1858	a9 00		        lda #$00
.185a	20 cd dd	        jsr fiaxtf1
.185d	20 65 14	        jsr popregs
.1860	60		        rts
.1861			rolword
.1861	20 38 14	        jsr pushregs
.1864	a8		        tay
.1865	18		again   clc
.1866	2e 4a 25	        rol reponse
.1869	2e 4b 25	        rol reponse+1
.186c	88		        dey
.186d	d0 f6		        bne again
.186f	20 65 14	        jsr popregs
.1872	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.1873			clrkbbuf
.1873	08		            php
.1874	48		            pha
.1875	a9 00		            lda #0
.1877	85 c6		            sta 198
.1879	68		            pla
.187a	28		            plp
.187b	60		            rts
.187c			waitstop
.187c	08		          php    ;\ sauve les flags
.187d	48		          pha    ;/  et l'acc.
.187e	20 73 18	          jsr clrkbbuf
.1881	20 70 f7	wait      jsr stop ; Veri [run/stop]
.1884	d0 fb		          bne wait ;loop pas pesee.
.1886	68		          pla    ;\ recup. acc et
.1887	28		          plp    ;/  les flags.
.1888	60		          rts
.1889			anykey
.1889	08		        php
.188a	48		        pha
.188b	20 73 18	        jsr clrkbbuf
.188e	a5 cb		wait    lda 203    ;lit la matrice de
.1890	c9 40		        cmp #64    ; 64 = aucune clef
.1892	f0 fa		        beq wait   ; on en attend une.
.1894	20 9d 18	        jsr kbfree ; Clavier relache.
.1897	20 73 18	        jsr clrkbbuf
.189a	68		        pla
.189b	28		        plp
.189c	60		        rts
.189d			kbfree
.189d	08		        php
.189e	48		        pha
.189f	a5 cb		wait    lda 203    ; lit la matrice
.18a1	c9 40		        cmp #64    ; 64 = aucune clef
.18a3	d0 fa		        bne wait   ; attend la relache
.18a5	68		        pla
.18a6	28		        plp
.18a7	60		        rts
.18a8			getkey
.18a8	08		        php
.18a9	20 f5 f1	try     jsr getin  ;tente de lire
.18ac	c9 00		        cmp #0     ; 0 si aucune.
.18ae	f0 f9		        beq try    ; on reessaye
.18b0	28		        plp
.18b1	60		        rts
.18b2			waitkey
.18b2	08		        php
.18b3	48		        pha
.18b4	8d 3e 25	        sta clef   ;Sauve clef voulue
.18b7	20 73 18	        jsr clrkbbuf
.18ba	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.18bd	cd 3e 25	        cmp clef   ;Compare avec clef
.18c0	d0 f8		        bne wait   ;Pas la bonne.
.18c2	68		        pla
.18c3	28		        plp
.18c4	60		        rts
.18c5			waitspace
.18c5	a9 20		            lda #$20
.18c7	20 b2 18	            jsr waitkey
.18ca	20 73 18	            jsr clrkbbuf
.18cd	60		            rts
.18ce			showkey
.18ce	20 38 14	        jsr pushregs
.18d1	38		        sec
.18d2	20 0a e5	        jsr plot
.18d5	8e 40 25	        stx curx
.18d8	8c 3f 25	        sty cury
.18db	20 38 14	        jsr pushregs
.18de	a0 1c		        ldy #39-11
.18e0	a2 18		        ldx #24
.18e2	18		        clc
.18e3	20 0a e5	        jsr plot
.18e6	20 65 14	        jsr popregs
.18e9	20 7a f2	        jsr chrout
.18ec	08		            php
.18ed	48		            pha
.18ee	a9 20		            lda #32
.18f0	20 7a f2	            jsr chrout
.18f3	68		            pla
.18f4	28		            plp
.18f5	08		            php
.18f6	48		            pha
.18f7	a9 24		            lda #36
.18f9	20 7a f2	            jsr chrout
.18fc	68		            pla
.18fd	28		            plp
.18fe	20 36 18	        jsr putahexdec
.1901	18		        clc
.1902	ac 3f 25	        ldy cury
.1905	ae 40 25	        ldx curx
.1908	20 0a e5	        jsr plot
.190b	20 65 14	        jsr popregs
.190e	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-screen.asm

.190f			scrnsave
.190f	20 c6 13	        jsr pushall
.1912	20 5b 19	        jsr setcarptr
.1915	20 35 19	        jsr zp1tozp2
.1918	20 6c 19	        jsr setcolptr
.191b	20 35 19	        jsr zp1tozp2
.191e	20 ff 13	        jsr popall
.1921	60		        rts
.1922			scrnrest
.1922	20 c6 13	        jsr pushall
.1925	20 5b 19	        jsr setcarptr
.1928	20 48 19	        jsr zp2tozp1
.192b	20 6c 19	        jsr setcolptr
.192e	20 48 19	        jsr zp2tozp1
.1931	20 ff 13	        jsr popall
.1934	60		        rts
.1935			zp1tozp2
.1935	a2 02		        ldx #>scrlen
.1937	a0 00		        ldy #<scrlen
.1939	b1 fb		nextcar lda (zp1),y
.193b	91 fd		        sta (zp2),y
.193d	c8		        iny
.193e	d0 f9		        bne nextcar
.1940	e6 fc		        inc zp1+1
.1942	e6 fe		        inc zp2+1
.1944	ca		        dex
.1945	d0 f2		        bne nextcar
.1947	60		        rts
.1948			zp2tozp1
.1948	a2 02		        ldx #>scrlen
.194a	a0 00		        ldy #<scrlen
.194c	b1 fd		nextcar lda (zp2),y
.194e	91 fb		        sta (zp1),y
.1950	c8		        iny
.1951	d0 f9		        bne nextcar
.1953	e6 fc		        inc zp1+1
.1955	e6 fe		        inc zp2+1
.1957	ca		        dex
.1958	d0 f2		        bne nextcar
.195a	60		        rts
.195b			setcarptr
.195b	a9 00		        lda #<scrtxt
.195d	85 fb		        sta zp1
.195f	a9 10		        lda #>scrtxt
.1961	85 fc		        sta zp1+1
.1963	a9 37		        lda #<scrncar
.1965	85 fd		        sta zp2
.1967	a9 23		        lda #>scrncar
.1969	85 fe		        sta zp2+1
.196b	60		        rts
.196c			setcolptr
.196c	a9 00		        lda #<scrcol
.196e	85 fb		        sta zp1
.1970	a9 94		        lda #>scrcol
.1972	85 fc		        sta zp1+1
.1974	a9 37		        lda #<scrncol
.1976	85 fd		        sta zp2
.1978	a9 21		        lda #>scrncol
.197a	85 fe		        sta zp2+1
.197c	60		        rts
.197d			fillscreen
.197d	20 c6 13	        jsr pushall
.1980	a2 01		        ldx #$01
.1982	a0 00		        ldy #$00
.1984	99 00 10	again   sta scrtxt,y
.1987	99 00 11	        sta scrtxt+256,y
.198a	48		        pha
.198b	ee a5 19	        inc col
.198e	ad a5 19	        lda col
.1991	29 7f		        and #$7f
.1993	29 07		        and #$07
.1995	09 18		        ora #$18
.1997	99 00 94	        sta scrcol,y
.199a	99 00 95	        sta scrcol+256,y
.199d	68		        pla
.199e	c8		        iny
.199f	d0 e3		        bne again
.19a1	20 ff 13	        jsr popall
.19a4	60		        rts
>19a5	00		col     .byte 0

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=9651			libre    = *+3085
=9650			rp       = libre-$01;1 byte $cfff
=9649			ra       = rp-1     ;1 byte $cffe
=9648			rx       = ra-1     ;1 byte $cffd
=9647			ry       = rx-1     ;1 byte $cffc
=9646			rs       = ry-1     ;1 byte $cffb
=9644			pc       = rs-2     ;2 byte $cff9-$cffa
=9643			curcol   = pc-1     ;1 byte $cff6
=9642			memptr   = curcol-1;1 word $cff7-$cff8
=9640			src      = memptr-2
=9638			dst      = memptr-4
=9636			loopcount = memptr-6
=9636			hexv     = loopcount
.19a6			a2hexstr
=9631			hexstr   = hexv-$05 ;5 byte
=9630			a2hexpfx = hexv-$06 ;1 byte
=9629			a2hexpy  = hexv-$07 ;1 byte
=9628			a2hexpx  = hexv-$08 ;1 byte
=9628			a2hexpos = hexv-$08 ;0 byte
=9627			a2hexcol = hexv-$09 ;1 byte
=9627			binv     = a2hexcol
=9618			binstr   = binv-$09 ;9 byte
=9617			a2binpfx = binv-$0a ;1 byte
=9616			a2binpy  = binv-$0b ;1 byte
=9615			a2binpx  = binv-$0c ;1 byte
=9615			a2binpos = binv-$0c ;0 byte
=9614			a2bincol = binv-$0d ;1 byte
=9614			decv     = a2bincol
=9608			decstr   = decv-$06 ;6 byte
=9607			a2decpfx = decv-$07 ;1 byte
=9606			a2decpy  = decv-$08 ;1 byte
=9605			a2decpx  = decv-$09 ;1 byte
=9605			a2decpos = decv-$09 ;0 byte
=9604			a2deccol = decv-$0a ;1 byte
=9603			offset   = decv-$0b ;1 byte
=9603			fltv     = offset
=9597			fvar1    = fltv-6  ; 6 byte
=9591			fvar2    = fltv-12 ; 6 byte
=9571			float1   = fltv-32 ;20 byte
=9551			float2   = fltv-52 ;20 byte
=9550			tval1    = fltv-53 ; 1 byte
=9548			tval2    = fltv-55 ; 2 byte
=9546			reponse  = tval2-2 ; 2 byte
=9546			edbox    = reponse
=9545			cleft    = edbox-1 ;1 byte
=9544			cright   = edbox-2 ;1 byte
=9543			cmid     = edbox-3 ;1 byte
=9542			dbtop    = edbox-4 ;1 byte
=9541			dbleft   = edbox-5 ;1 byte
=9540			dbwdth   = edbox-6 ;1 byte
=9539			dbhght   = edbox-7 ;1 byte
=9538			dbcoul   = edbox-8 ;1 byte
=9537			dbclin   = edbox-9 ;1 byte
=9537			ekeyb    = dbclin
=9536			curx     = ekeyb-1 ;1 byte
=9535			cury     = ekeyb-2 ;1 byte
=9534			clef     = ekeyb-3 ;1 byte
=9533			len      = clef-1  ;1 byte
=9532			cx       = clef-2  ;1 byte
=9531			cy       = clef-3  ;1 byte
=9530			bcol     = clef-4  ;1 byte
=9530			escr     = bcol         ;2051 bytes
=9529			loops    = escr-1       ;   1 byte
=9527			loop16   = loops-2      ;   2 byte
=9015			scrncar  = loop16-$200  ;  1k byte
=8503			scrncol  = scrncar-$200 ;  1k byte
=8503			diskvar = scrncol
=8501			ddatas  = diskvar-2 ;2 byte Data start
=8499			ddatae  = diskvar-4 ;2 byte Data end
=8498			ddev    = diskvar-5 ;1 byte Dev number
=8497			dlfsno  = diskvar-6 ;1 byte Lfs
=8495			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=8494			dfnlen  = diskvar-9 ;1 byte lenfilename
=8493			genbyte1 = dfnlen-1 ; 1 byte
=8491			genword1 = dfnlen-3 ; 2 byte
=8490			endofvars = genword1-1

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm


;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			fFAC1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			fFAC1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; ff1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; ff1=atn(f1).

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.19a6	4c af 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: keyfinder.asm


;******  End of listing
