
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L keyfinder.txt -o keyfinder.prg keyfinder.asm
; Mon Jan 26 21:47:05 2026

;Offset	;Hex		;Source

;******  Processing input file: keyfinder.asm

="20260123-101151g"	Version = "20260123-101151g"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

=$1000			scrtxt    = $1000
=$9400			scrcol    = $9400
=$0200			scrlen    = $0200
>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	34 36 32 31	         .text "4621";adresse du debut
>120a	00		         .byte $00   ;fin de cmd basic.
>120b	00 00		bcmd2    .word $00   ;adresse de la pro-
.120d	20 13 12	        jsr bhscrini
.1210	4c 42 12	basnold jmp main
.1213			bhscrini
.1213	08		        php
.1214	48		        pha
.1215	a9 84		        lda #(128+4)
.1217	8d 00 90	        sta vic0
.121a	ad 0f 90	bord    lda $900f    ;place la couleur
.121d	29 08		        and #%00001000
.121f	09 e3		        ora #%11100011
.1221	8d 0f 90	        sta $900f
.1224	a9 00		text    lda #$00    ;place la couleur
.1226	8d 86 02	        sta $0286   ; du texte.
.1229	a9 93		        lda #$93    ;efface l'ecran par
.122b	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.122e	68		        pla
.122f	28		        plp
.1230	60		        rts
.1231			bhprint
.1231	a0 00		        ldy #$00
.1233	b1 fb		nextc   lda ($fb),y
.1235	f0 07		        beq end
.1237	c8		        iny
.1238	20 d2 ff	        jsr $ffd2
.123b	4c 33 12	        jmp nextc
.123e	60		end     rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm


;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			fFAC1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			fFAC1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; ff1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; ff1=atn(f1).

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.123f	4c 42 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: keyfinder.asm

.1242			main
.1242	08		            php
.1243	48		            pha
.1244	a9 1b		            lda #(vblanc*16+(vocean|8))
.1246	8d 0f 90	            sta  vic15
.1249	a9 06		            lda #vbleu
.124b	8d 86 02	            sta kcol
.124e	a9 93		            lda #147
.1250	20 d2 ff	            jsr $ffd2
.1253	68		            pla
.1254	28		            plp
.1255	20 f9 18	               jsr fillscreen
.1258	20 8b 18	               jsr scrnsave
.125b	08		            php
.125c	48		            pha
.125d	a9 0e		            lda #locase
.125f	20 7a f2	            jsr chrout
.1262	68		            pla
.1263	28		            plp
.1264	08		            php
.1265	48		            pha
.1266	a9 90		            lda #snoir
.1268	20 7a f2	            jsr chrout
.126b	68		            pla
.126c	28		            plp
.126d	20 d5 13	          jsr  pushregs
.1270	a9 b0		          lda #176
.1272	8d f7 12	          sta texte0+0
.1275	a9 ae		          lda #174
.1277	8d 0f 13	          sta texte0+24
.127a	a2 f7		          ldx  #<texte0
.127c	a0 12		          ldy  #>texte0
.127e	20 45 14	          jsr  putsyx
.1281	20 02 14	          jsr  popregs
.1284	20 d5 13	          jsr  pushregs
.1287	a9 dd		          lda #221
.1289	8d 12 13	          sta texte1+0
.128c	a9 dd		          lda #221
.128e	8d 2a 13	          sta texte1+24
.1291	a2 12		          ldx  #<texte1
.1293	a0 13		          ldy  #>texte1
.1295	20 45 14	          jsr  putsyx
.1298	20 02 14	          jsr  popregs
.129b	20 d5 13	          jsr  pushregs
.129e	a9 dd		          lda #221
.12a0	8d 2d 13	          sta texte2+0
.12a3	a9 dd		          lda #221
.12a5	8d 45 13	          sta texte2+24
.12a8	a2 2d		          ldx  #<texte2
.12aa	a0 13		          ldy  #>texte2
.12ac	20 45 14	          jsr  putsyx
.12af	20 02 14	          jsr  popregs
.12b2	20 d5 13	          jsr  pushregs
.12b5	a9 ad		          lda #173
.12b7	8d 48 13	          sta ligne+0
.12ba	a9 bd		          lda #189
.12bc	8d 60 13	          sta ligne+24
.12bf	a2 48		          ldx  #<ligne
.12c1	a0 13		          ldy  #>ligne
.12c3	20 45 14	          jsr  putsyx
.12c6	20 02 14	          jsr  popregs
.12c9	20 05 18	               jsr anykey
.12cc	20 9e 18	               jsr scrnrest
.12cf	20 05 18	               jsr anykey
.12d2	08		            php
.12d3	48		            pha
.12d4	a9 93		            lda #147
.12d6	20 7a f2	            jsr chrout
.12d9	68		            pla
.12da	28		            plp
.12db	20 05 18	               jsr anykey
.12de	20 9e 18	               jsr scrnrest
.12e1	20 05 18	               jsr anykey
.12e4	08		            php
.12e5	48		            pha
.12e6	a9 93		            lda #147
.12e8	20 7a f2	            jsr chrout
.12eb	68		            pla
.12ec	28		            plp
.12ed	08		            php
.12ee	48		            pha
.12ef	a9 1f		            lda #sbleu
.12f1	20 7a f2	            jsr chrout
.12f4	68		            pla
.12f5	28		            plp
.12f6	60		                              rts
.12f7			regdemo
>12f7	20 90 12	texte0         .byte 32,snoir,revson        ;0-2
>12fa	20 c3 d0 d5	               .text " CPU REGISTERS HEX " ;3-23
>12fe	20 d2 c5 c7 c9 d3 d4 c5 d2 d3 20 c8 c5 d8 20
>130d	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1311	00		               .byte 0
>1312	20 1f 92	texte1         .byte 32,sbleu,revsoff
>1315	20 d0 c3 20	               .text " PC  RA RX RY SR SP"
>1319	20 d2 c1 20 d2 d8 20 d2 d9 20 d3 d2 20 d3 d0
>1328	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>132c	00		               .byte 0
>132d	20 1c 92	texte2         .byte 32,srouge,revsoff        ;0-2 - 0
>1330	30 30 30 30	               .text "0000 00 00 00 00 00" ;3-23
>1334	20 30 30 20 30 30 20 30 30 20 30 30 20 30 30
>1343	90 92 20 0d	               .byte snoir,revsoff,32,$0d    ;24-27
>1347	00		               .byte 0
>1348	20 90 92	ligne          .byte 32,snoir,revsoff        ;0-2
>134b	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;3-8   ;1
>134f	c0
>1350	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;9-13
>1354	c0
>1355	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;14-18
>1359	c0
>135a	c0 c0 c0 c0	               .byte 192,192,192,192         ;19-23
>135e	90 92 20 0d	               .byte snoir,revsoff,32,$0d    ;24-27
>1362	00		               .byte 0

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.1363			pushall
.1363	08		         php     ;s;rp,pcl,pch
.1364	8d 2d 25	         sta ra  ;sauve a
.1367	68		         pla     ;s:pcl,pch
.1368	8d 2e 25	         sta rp  ;sauve rp
.136b	68		         pla     ;s:pch
.136c	8d 28 25	         sta pc  ;sauve pcl
.136f	68		         pla     ;s:
.1370	8d 29 25	         sta pc+1;sauve pch
.1373	a5 fb		         lda $fb ;sauve fb
.1375	48		         pha     ;s:fb
.1376	a5 fc		         lda $fc ;sauve fc
.1378	48		         pha     ;s:fc,fb
.1379	a5 fd		         lda $fd ;sauve fd
.137b	48		         pha     ;s:fd,fc,fb
.137c	a5 fe		         lda $fe ;sauve fe
.137e	48		         pha     ;s:fe,fd,fc,fb
.137f	ad 2e 25	         lda rp  ;sauve rp
.1382	48		         pha     ;s:rp,fe,fd,fc,fb
.1383	ad 2d 25	         lda ra  ;sauve ra
.1386	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.1387	8a		         txa     ;sauve rx
.1388	48		         pha     ;s:rx,ra,rp,fe-fb
.1389	98		         tya     ;sauve y
.138a	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.138b	ad 29 25	         lda pc+1;replace l'adresse
.138e	48		         pha     ;s:pch,ry,rx,ra,...
.138f	ad 28 25	         lda pc  ; de retour.
.1392	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.1393	ad 2e 25	         lda rp  ;place les flags
.1396	48		         pha     ; sur le stack.
.1397	ad 2d 25	         lda ra  ;recupere ra
.139a	28		         plp     ;recupere les flags.
.139b	60		         rts
.139c			popall
.139c	08		         php     ;s:rp,pcl,pch,ry,rx,...
.139d	8d 2d 25	         sta ra
.13a0	68		         pla     ;s:pcl,pch,ry,rx,...
.13a1	8d 2e 25	         sta rp  ;s:pch,ry,rx,ra,rp,...
.13a4	68		         pla
.13a5	8d 28 25	         sta pc  ;sauve pcl
.13a8	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.13a9	8d 29 25	         sta pc+1;sauve pch
.13ac	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.13ad	a8		         tay     ;recupere ry
.13ae	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.13af	aa		         tax     ;recupere rx
.13b0	68		         pla     ;s:rp,fe,fd,fc,fb
.13b1	8d 2d 25	         sta ra  ;recupere ra
.13b4	68		         pla     ;s:fe,fd,fc,fb
.13b5	8d 2e 25	         sta rp  ;recupere les flags.
.13b8	68		         pla     ;s:fd,fc,fb
.13b9	85 fe		         sta $fe ;reccupere fe
.13bb	68		         pla     ;s:fc,fb
.13bc	85 fd		         sta $fd ;recupere fd
.13be	68		         pla     ;s:fb
.13bf	85 fc		         sta $fc ;recupere fc
.13c1	68		         pla     ;s:
.13c2	85 fb		         sta $fb ;recupere fb
.13c4	ad 29 25	         lda pc+1;replaace l'adresse de
.13c7	48		         pha     ;s:pch
.13c8	ad 28 25	         lda pc  ;retour sur la pile
.13cb	48		         pha     ;s:pcl,pch
.13cc	ad 2e 25	         lda rp  ;recupere les flags
.13cf	48		         pha     ;s:rp,pcl,pch
.13d0	ad 2d 25	         lda ra  ;recupere ra
.13d3	28		         plp     ;s:pcl,pch
.13d4	60		         rts
.13d5			pushregs
.13d5	08		         php     ;s;rp,pcl,pch
.13d6	8d 2d 25	         sta ra  ; -- sauve a
.13d9	68		         pla     ;s:pcl,pch
.13da	8d 2e 25	         sta rp  ; -- sauve rp
.13dd	68		         pla     ;s:pch
.13de	8d 28 25	         sta pc  ; -- sauve pcl
.13e1	68		         pla     ;s:
.13e2	8d 29 25	         sta pc+1; -- sauve pch
.13e5	ad 2e 25	         lda rp  ; -- sauve rp
.13e8	48		         pha     ;s:rp
.13e9	ad 2d 25	         lda ra  ; -- sauve ra
.13ec	48		         pha     ;s:ra,rp
.13ed	8a		         txa     ; -- tfr rx
.13ee	48		         pha     ;s:rx,ra,rp
.13ef	98		         tya     ; -- tfr ry
.13f0	48		         pha     ;s:ry,rx,ra,rp
.13f1	ad 29 25	         lda pc+1; -- replace l'adresse
.13f4	48		         pha     ;s:pch,ry,rx,ra,rp
.13f5	ad 28 25	         lda pc  ; -- de retour.
.13f8	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.13f9	ad 2e 25	         lda rp  ; -- place les flags
.13fc	48		         pha     ;    sur le stack.
.13fd	ad 2d 25	         lda ra  ; -- recupere ra
.1400	28		         plp     ; -- recupere flags.
.1401	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1402			popregs
.1402	08		         php
.1403	8d 2d 25	         sta ra
.1406	68		         pla
.1407	8d 2e 25	         sta rp
.140a	68		         pla     ;s:pch,ry,rx,ra,rp
.140b	8d 28 25	         sta pc  ; -- sauve pcl
.140e	68		         pla     ;s:ry,rx,ra,rp
.140f	8d 29 25	         sta pc+1; -- sauve pch
.1412	68		         pla     ;s:rx,ra,rp
.1413	a8		         tay     ;recupere ry
.1414	68		         pla     ;s:ra,rp
.1415	aa		         tax     ;recupere rx
.1416	68		         pla     ;s:rp
.1417	8d 2d 25	         sta ra  ;recupere ra
.141a	68		         pla     ;s:
.141b	8d 2e 25	         sta rp  ;recupere les flags.
.141e	ad 29 25	         lda pc+1;replace l'adresse de
.1421	48		         pha     ;s:pch
.1422	ad 28 25	         lda pc  ;retour sur la pile
.1425	48		         pha     ;s:pcl,pch
.1426	ad 2e 25	         lda rp  ;recupere les flags
.1429	48		         pha     ;s:rp,pcl,pch
.142a	ad 2d 25	         lda ra  ;recupere ra
.142d	28		         plp     ;s:pcl,pch
.142e	60		         rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.142f			puts
.142f	20 63 13	        jsr pushall
.1432	a0 00		        ldy #$00   ; y = offset
.1434	b1 fb		nextc   lda ($fb),y;lit un caractere
.1436	f0 09		        beq out    ;si 0 on sort
.1438	20 7a f2	        jsr chrout ;on l'affiche
.143b	20 69 15	        jsr inczp1 ;pointe le prochain
.143e	4c 34 14	        jmp nextc  ; et l'affiche
.1441	20 9c 13	out     jsr popall
.1444	60		        rts
.1445			putsyx
.1445	20 63 13	        jsr pushall;sauve reg + zps
.1448	86 fb		        stx $fb    ;$yyxx dans
.144a	84 fc		        sty $fb+1  ; zp1
.144c	20 2f 14	        jsr puts
.144f	20 9c 13	        jsr popall ;recup reg + zps
.1452	60		        rts
.1453			putsxy
.1453	20 63 13	        jsr pushall;sauve reg + zps
.1456	86 fb		        stx $fb    ;$yyxx dans
.1458	84 fc		        sty $fb+1  ; zp1
.145a	a0 00		        ldy #$00
.145c	b1 fb		        lda ($fb),y
.145e	aa		        tax
.145f	20 69 15	        jsr inczp1
.1462	b1 fb		        lda ($fb),y
.1464	20 69 15	        jsr inczp1
.1467	a8		        tay
.1468	20 bd 14	        jsr gotoxy
.146b	20 2f 14	        jsr puts
.146e	20 9c 13	        jsr popall ;recup reg + zps
.1471	60		        rts
.1472			putsc
.1472	08		        php        ;flag sur stack
.1473	48		        pha        ;acc sur stack
.1474	48		        pha        ;sauvegarde acc
.1475	ad 86 02	        lda kcol   ;recup coul. carac.
.1478	8d 27 25	        sta curcol ; et la sauvegarde
.147b	68		        pla        ;recup. acc
.147c	8d 86 02	        sta kcol   ;place coul. voulue
.147f	20 2f 14	        jsr puts   ;affiche la chaine
.1482	ad 27 25	        lda curcol ;recup coul. carac.
.1485	8d 86 02	        sta kcol   ; et la replace
.1488	68		        pla        ;recup acc
.1489	28		        plp        ;recup flag
.148a	60		        rts
.148b			putscyx
.148b	08		        php       ;sauve registres
.148c	48		        pha       ; ...
.148d	48		        pha       ;sauve acc
.148e	ad 86 02	        lda kcol  ;recup couleur carac.
.1491	8d 27 25	        sta curcol; et sauvegarde
.1494	68		        pla       ;recup acc
.1495	8d 86 02	        sta kcol  ;place couleur carac.
.1498	20 45 14	        jsr putsyx;affiche la chaine
.149b	ad 27 25	        lda curcol
.149e	8d 86 02	        sta kcol
.14a1	68		        pla
.14a2	28		        plp
.14a3	60		        rts
.14a4			putscxy
.14a4	08		        php       ;sauve registres
.14a5	48		        pha       ; ...
.14a6	48		        pha       ;sauve acc
.14a7	ad 86 02	        lda kcol  ;recup couleur carac.
.14aa	8d 27 25	        sta curcol; et sauvegarde
.14ad	68		        pla       ;recup acc
.14ae	8d 86 02	        sta kcol   ;place couleur carac.
.14b1	20 45 14	        jsr putsyx ;affiche la chaine
.14b4	ad 27 25	        lda curcol
.14b7	8d 86 02	        sta kcol
.14ba	68		        pla
.14bb	28		        plp
.14bc	60		        rts
.14bd			gotoxy
.14bd	20 d5 13	        jsr pushregs
.14c0	8a		        txa ; interchange x et y
.14c1	48		        pha ; ...
.14c2	98		        tya ; ...
.14c3	aa		        tax ; ...
.14c4	68		        pla ; ...
.14c5	a8		        tay ; ...
.14c6	c0 00		txlow   cpy #0
.14c8	10 02		        bpl txhigh
.14ca	a2 00		        ldx #0
.14cc	e0 19		txhigh  cpx #25
.14ce	30 02		        bmi tylow
.14d0	a2 18		        ldx #24
.14d2	c0 00		tylow   cpy #0
.14d4	10 02		        bpl tyhigh
.14d6	a0 00		        ldy #0
.14d8	c0 28		tyhigh  cpy #40
.14da	30 02		        bmi allok
.14dc	a0 27		        ldy #39
.14de	18		allok   clc
.14df	20 0a e5	        jsr plot
.14e2	20 02 14	        jsr popregs
.14e5	60		        rts
.14e6			putnch
.14e6	20 d5 13	        jsr pushregs
.14e9	20 7a f2	again   jsr chrout
.14ec	ca		        dex
.14ed	d0 fa		        bne again
.14ef	20 02 14	        jsr popregs
.14f2	60		        rts
.14f3			strlen
.14f3	20 63 13	        jsr pushall
.14f6	84 fc		        sty zp1+1
.14f8	86 fb		        stx zp1
.14fa	a0 00		        ldy #$00
.14fc	8c b9 24	        sty len
.14ff	b1 fb		next    lda (zp1),y
.1501	f0 07		        beq out
.1503	ee b9 24	        inc len
.1506	c8		        iny
.1507	4c ff 14	        jmp next
.150a	20 9c 13	out     jsr popall
.150d	ad b9 24	        lda len
.1510	60		        rts
.1511			cursor
.1511	20 d5 13	        jsr  pushregs
.1514	90 12		        bcc  get    ;C=0 récupération.
.1516	20 0a e5	        jsr  plot  ;récupère position
.1519	8c b8 24	        sty  cx     ;curseur et sauve
.151c	8e b7 24	        stx  cy     ;dans vars locales.
.151f	ad 86 02	        lda  kcol   ;Sauve couleur
.1522	8d b6 24	        sta  bcol   ; BASIC du texte.
.1525	4c 37 15	        jmp  out    ;Fini on sort.
.1528	ae b7 24	get     ldx  cy     ;C=1, charge x
.152b	ac b8 24	        ldy  cx     ; ligne, y col.
.152e	20 0a e5	        jsr  plot  ;Position curseur.
.1531	ad b6 24	        lda  bcol   ;replace couleur
.1534	8d 86 02	        sta  kcol ; basic sauvegardé.
.1537	20 02 14	out     jsr  popregs
.153a	60		        rts
.153b			cursave
.153b	08		        php
.153c	38		        sec
.153d	20 11 15	        jsr  cursor
.1540	28		        plp
.1541	60		        rts
.1542			curput
.1542	08		        php
.1543	18		        clc
.1544	20 11 15	        jsr  cursor
.1547	28		        plp
.1548	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.1549			blkfill
.1549	20 63 13	bf0     jsr pushall
.154c	84 fc		        sty zp1+1
.154e	a0 00		        ldy #$00
.1550	84 fb		        sty zp1
.1552	91 fb		bf1     sta (zp1),y
.1554	c8		        iny
.1555	d0 fb		        bne bf1
.1557	20 9c 13	        jsr popall
.155a	60		        rts
.155b			memfill
.155b	20 d5 13	        jsr pushregs
.155e	20 49 15	mf1     jsr blkfill
.1561	c8		        iny
.1562	ca		        dex
.1563	d0 f9		        bne mf1
.1565	20 02 14	        jsr popregs
.1568	60		        rts
.1569			inczp1
.1569	08		         php
.156a	e6 fb		         inc zp1
.156c	d0 02		         bne repzp1
.156e	e6 fc		         inc zp1+1
.1570	28		repzp1   plp
.1571	60		         rts
.1572			inczp2
.1572	08		         php
.1573	e6 fd		         inc zp2
.1575	d0 02		         bne repzp2
.1577	e6 fe		         inc zp2+1
.1579	28		repzp2   plp
.157a	60		         rts
.157b			deczp1
.157b	08		         php
.157c	48		         pha
.157d	a5 fb		         lda zp1
.157f	d0 02		         bne noemp
.1581	c6 fc		         dec zp1+1
.1583	c6 fb		noemp    dec zp1
.1585	68		         pla
.1586	28		         plp
.1587	60		         rts
.1588			deczp2
.1588	08		         php
.1589	48		         pha
.158a	a5 fd		         lda zp2
.158c	d0 02		         bne noemp
.158e	c6 fe		         dec zp2+1
.1590	c6 fd		noemp    dec zp2
.1592	68		         pla
.1593	28		         plp
.1594	60		         rts
.1595			rolzp1
.1595	08		        php
.1596	48		        pha
.1597	18		        clc
.1598	a5 fb		        lda zp1
.159a	2a		        rol
.159b	85 fb		        sta zp1
.159d	a5 fc		        lda zp1+1
.159f	2a		        rol
.15a0	85 fc		        sta zp1+1
.15a2	68		        pla
.15a3	28		        plp
.15a4			rorzp1
.15a4	08		        php
.15a5	48		        pha
.15a6	18		        clc
.15a7	a5 fc		        lda zp1+1
.15a9	6a		        ror
.15aa	85 fc		        sta zp1+1
.15ac	a5 fb		        lda zp1
.15ae	6a		        ror
.15af	85 fb		        sta zp1
.15b1	68		        pla
.15b2	28		        plp
.15b3			rolzp2
.15b3	08		        php
.15b4	48		        pha
.15b5	18		        clc
.15b6	a5 fd		        lda zp2
.15b8	2a		        rol
.15b9	85 fd		        sta zp2
.15bb	a5 fe		        lda zp2+1
.15bd	2a		        rol
.15be	85 fe		        sta zp2+1
.15c0	68		        pla
.15c1	28		        plp
.15c2			rorzp2
.15c2	08		        php
.15c3	48		        pha
.15c4	18		        clc
.15c5	a5 fe		        lda zp2+1
.15c7	6a		        ror
.15c8	85 fe		        sta zp2+1
.15ca	a5 fd		        lda zp2
.15cc	6a		        ror
.15cd	85 fd		        sta zp2
.15cf	68		        pla
.15d0	28		        plp
.15d1			yxtoptr
.15d1	8c 27 25	        sty memptr+1
.15d4	8e 26 25	        stx memptr
.15d7	60		        rts
.15d8			ptrtoyx
.15d8	08		        php
.15d9	ac 27 25	        ldy memptr+1
.15dc	ae 26 25	        ldx memptr
.15df	28		        plp
.15e0	60		        rts
.15e1			incptr
.15e1	08		        php
.15e2	ee 26 25	        inc memptr
.15e5	d0 03		        bne norep
.15e7	ee 27 25	        inc memptr+1
.15ea	28		norep   plp
.15eb	60		        rts
.15ec			decptr
.15ec	08		        php
.15ed	48		        pha
.15ee	ad 26 25	        lda memptr
.15f1	d0 03		        bne noemp
.15f3	ee 27 25	        inc memptr+1
.15f6	ee 26 25	noemp   inc memptr
.15f9	68		        pla
.15fa	28		        plp
.15fb	60		        rts
.15fc			incptr8
.15fc	08		        php
.15fd	48		        pha
.15fe	98		        tya
.15ff	48		        pha
.1600	a0 08		        ldy #8
.1602	20 e1 15	again   jsr incptr
.1605	88		        dey
.1606	d0 fa		        bne again
.1608	68		        pla
.1609	a8		        tay
.160a	68		        pla
.160b	28		        plp
.160c	60		        rts
.160d			loop
.160d	ce 20 25	               dec  loopcount
.1610	d0 03		               bne  norep
.1612	ce 21 25	               dec  loopcount+1
.1615	ad 20 25	norep          lda  loopcount
.1618	c9 00		               cmp  #$00
.161a	d0 05		               bne  out
.161c	4d 21 25	               eor  loopcount+1
.161f	c9 ff		               cmp  #$ff
.1621	60		out            rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.1622			addtoword
.1622			addatoyx
.1622	08		        php
.1623	48		        pha
.1624	8c c7 24	        sty reponse+1
.1627	8e c6 24	        stx reponse
.162a	18		        clc
.162b	6d c6 24	        adc reponse
.162e	90 03		        bcc norep
.1630	ee c7 24	        inc reponse+1
.1633	8d c6 24	norep   sta reponse
.1636	ac c7 24	        ldy reponse+1
.1639	ae c6 24	        ldx reponse
.163c	68		        pla
.163d	28		        plp
.163e	60		        rts
.163f			subtoword
.163f			subatoyx
.163f	08		        php
.1640	48		        pha
.1641	8c c7 24	        sty reponse+1
.1644	8e c6 24	        stx reponse
.1647	38		        sec
.1648	ed c6 24	        sbc reponse
.164b	b0 03		        bcs noemp
.164d	ce c7 24	        dec reponse+1
.1650	8d c6 24	noemp   sta reponse
.1653	ac c7 24	        ldy reponse+1
.1656	ae c6 24	        ldx reponse
.1659	68		        pla
.165a	28		        plp
.165b	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.165c			putyxhex
.165c	20 63 13	        jsr pushall
.165f	98		        tya
.1660	48		        pha
.1661	20 ce 16	        jsr lsr4bits
.1664	20 d5 16	        jsr nibtohex
.1667	8d 1b 25	        sta hexstr+0
.166a	68		        pla
.166b	20 d5 16	        jsr nibtohex
.166e	8d 1c 25	        sta hexstr+1
.1671	8a		        txa
.1672	20 91 16	        jsr atohex
.1675	a2 1b		        ldx #<hexstr+0
.1677	a0 25		        ldy #>hexstr+0
.1679	20 45 14	        jsr putsyx
.167c	20 9c 13	        jsr popall
.167f	60		        rts
.1680			putahex
.1680	20 d5 13	        jsr pushregs
.1683	20 91 16	        jsr atohex
.1686	a2 1d		        ldx #<hexstr+2
.1688	a0 25		        ldy #>hexstr+2
.168a	20 45 14	        jsr putsyx
.168d	20 02 14	        jsr popregs
.1690	60		        rts
.1691			atohex
.1691	08		        php
.1692	48		        pha
.1693	48		        pha
.1694	20 ce 16	        jsr lsr4bits
.1697	20 d5 16	        jsr nibtohex
.169a	8d 1b 25	        sta hexstr
.169d	68		        pla
.169e	20 d5 16	        jsr nibtohex
.16a1	8d 1c 25	        sta hexstr+1
.16a4	a9 00		        lda #$00
.16a6	8d 1d 25	        sta hexstr+2
.16a9	68		        pla
.16aa	28		        plp
.16ab	60		        rts
.16ac			atobin
.16ac	20 d5 13	               jsr  pushregs
.16af	a2 08		               ldx  #8
.16b1	a0 00		               ldy  #0
.16b3	18		               clc
.16b4	2a		nextbit        rol
.16b5	48		               pha
.16b6	69 00		               adc  #$00
.16b8	29 01		               and  #$01
.16ba	20 d5 16	               jsr  nibtohex
.16bd	99 0e 25	               sta  binstr,y
.16c0	68		               pla
.16c1	c8		               iny
.16c2	ca		               dex
.16c3	d0 ef		               bne  nextbit
.16c5	a9 00		               lda  #0
.16c7	99 0e 25	               sta  binstr,y
.16ca	20 02 14	               jsr  popregs
.16cd	60		               rts
.16ce			lsr4bits
.16ce	08		        php
.16cf	4a		        lsr a
.16d0	4a		        lsr a
.16d1	4a		        lsr a
.16d2	4a		        lsr a
.16d3	28		        plp
.16d4	60		        rts
.16d5			nibtohex
.16d5	08		        php
.16d6	29 0f		        and    #$0f
.16d8	f8		        sed
.16d9	18		        clc
.16da	69 90		        adc #$90
.16dc	69 40		        adc #$40
.16de	28		        plp
.16df	60		        rts
.16e0			bytestohex
.16e0	20 63 13	        jsr pushall
.16e3	84 fc		        sty zp1+1
.16e5	86 fb		        stx zp1
.16e7	08		            php
.16e8	48		            pha
.16e9	a9 20		            lda #32
.16eb	20 7a f2	            jsr chrout
.16ee	68		            pla
.16ef	28		            plp
.16f0	08		            php
.16f1	48		            pha
.16f2	a9 05		            lda #5
.16f4	20 7a f2	            jsr chrout
.16f7	68		            pla
.16f8	28		            plp
.16f9	08		            php
.16fa	48		            pha
.16fb	a9 24		            lda #36
.16fd	20 7a f2	            jsr chrout
.1700	68		            pla
.1701	28		            plp
.1702	20 5c 16	        jsr putyxhex   ; prn adreponsese
.1705	08		            php
.1706	48		            pha
.1707	a9 20		            lda #$20
.1709	20 7a f2	            jsr chrout
.170c	68		            pla
.170d	28		            plp
.170e	08		            php
.170f	48		            pha
.1710	a9 9f		            lda #159
.1712	20 7a f2	            jsr chrout
.1715	68		            pla
.1716	28		            plp
.1717	a0 00		        ldy #$00
.1719	aa		        tax
.171a	8c ff 24	another sty offset
.171d	b1 fb		        lda (zp1),y
.171f	20 80 16	        jsr putahex
.1722	48		        pha
.1723	20 42 17	        jsr petsciiaddr
.1726	68		        pla
.1727	8d 00 04	petscii sta $0400
.172a	48		        pha
.172b	a9 0d		        lda #$0d
.172d	8d 00 d8	petcol  sta $d800
.1730	68		        pla
.1731	08		            php
.1732	48		            pha
.1733	a9 20		            lda #$20
.1735	20 7a f2	            jsr chrout
.1738	68		            pla
.1739	28		            plp
.173a	c8		        iny
.173b	ca		        dex
.173c	d0 dc		        bne another
.173e	20 9c 13	        jsr popall
.1741	60		        rts
.1742			petsciiaddr
.1742	20 d5 13	        jsr pushregs
.1745	a9 1f		        lda #31
.1747	18		        clc
.1748	6d ff 24	        adc offset
.174b	20 22 16	        jsr addatoyx
.174e	8c 29 17	        sty petscii+2
.1751	8e 28 17	        stx petscii+1
.1754	8e 2e 17	        stx petcol+1
.1757	98		        tya
.1758	29 fb		        and #%11111011 ;#%00000100
.175a	09 d8		        ora #$d8
.175c	8d 2f 17	        sta petcol+2
.175f	a8		        tay
.1760	20 02 14	        jsr popregs
.1763	60		        rts
.1764			strhexval
.1764	20 63 13	        jsr pushall ; sauve registre
.1767	84 fc		        sty zp1+1   ; ptr dans zp1
.1769	86 fb		        stx zp1
.176b	20 f3 14	        jsr strlen  ;len de $(yyxx)->a
.176e	f0 3d		        beq oute    ; si 0 erreur C=1
.1770	a0 00		        ldy #$00    ; offset a 0
.1772	8c c7 24	        sty reponse+1; reponse a zero
.1775	8c c6 24	        sty reponse ;    ...
.1778	b1 fb		nextc   lda (zp1),y ;charge un caractere
.177a	f0 26		        beq out     ;On  a fini
.177c	c0 00		        cpy #$00    ;si c'est le premier
.177e	f0 07		        beq norol   ; pas de rol
.1780	48		        pha         ;
.1781	a9 04		        lda #$04    ;rol de 4 pos
.1783	20 dd 17	        jsr rolword ;
.1786	68		        pla         ;
.1787	09 20		norol   ora #%00100000
.1789	38		        sec
.178a	e9 30		        sbc #$30
.178c	c9 0a		        cmp #$0a
.178e	90 07		        bcc lt10
.1790	38		        sec
.1791	e9 27		        sbc #$27
.1793	c9 10		        cmp #$10
.1795	b0 16		        bcs oute
.1797	0d c6 24	lt10    ora reponse
.179a	8d c6 24	        sta reponse
.179d	c8		        iny
.179e	c0 04		        cpy #$04
.17a0	d0 d6		        bne nextc
.17a2	20 9c 13	out     jsr popall
.17a5	18		        clc          ;Carry 0 = good
.17a6	ac c7 24	        ldy reponse+1
.17a9	ae c6 24	        ldx reponse
.17ac	60		        rts
.17ad	20 9c 13	oute    jsr popall
.17b0	38		        sec
.17b1	60		        rts
.17b2			putahexdec
.17b2	20 d5 13	        jsr pushregs
.17b5	08		            php
.17b6	48		            pha
.17b7	a9 9e		            lda #sjaune
.17b9	20 7a f2	            jsr chrout
.17bc	68		            pla
.17bd	28		            plp
.17be	20 80 16	        jsr putahex
.17c1	08		            php
.17c2	48		            pha
.17c3	a9 20		            lda #$20
.17c5	20 7a f2	            jsr chrout
.17c8	68		            pla
.17c9	28		            plp
.17ca	08		            php
.17cb	48		            pha
.17cc	a9 9f		            lda #socean
.17ce	20 7a f2	            jsr chrout
.17d1	68		            pla
.17d2	28		            plp
.17d3	aa		        tax
.17d4	a9 00		        lda #$00
.17d6	20 cd dd	        jsr fiaxtf1
.17d9	20 02 14	        jsr popregs
.17dc	60		        rts
.17dd			rolword
.17dd	20 d5 13	        jsr pushregs
.17e0	a8		        tay
.17e1	18		again   clc
.17e2	2e c6 24	        rol reponse
.17e5	2e c7 24	        rol reponse+1
.17e8	88		        dey
.17e9	d0 f6		        bne again
.17eb	20 02 14	        jsr popregs
.17ee	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.17ef			clrkbbuf
.17ef	08		            php
.17f0	48		            pha
.17f1	a9 00		            lda #0
.17f3	85 c6		            sta 198
.17f5	68		            pla
.17f6	28		            plp
.17f7	60		            rts
.17f8			waitstop
.17f8	08		          php    ;\ sauve les flags
.17f9	48		          pha    ;/  et l'acc.
.17fa	20 ef 17	          jsr clrkbbuf
.17fd	20 70 f7	wait      jsr stop ; Veri [run/stop]
.1800	d0 fb		          bne wait ;loop pas pesee.
.1802	68		          pla    ;\ recup. acc et
.1803	28		          plp    ;/  les flags.
.1804	60		          rts
.1805			anykey
.1805	08		        php
.1806	48		        pha
.1807	20 ef 17	        jsr clrkbbuf
.180a	a5 cb		wait    lda 203    ;lit la matrice de
.180c	c9 40		        cmp #64    ; 64 = aucune clef
.180e	f0 fa		        beq wait   ; on en attend une.
.1810	20 19 18	        jsr kbfree ; Clavier relache.
.1813	20 ef 17	        jsr clrkbbuf
.1816	68		        pla
.1817	28		        plp
.1818	60		        rts
.1819			kbfree
.1819	08		        php
.181a	48		        pha
.181b	a5 cb		wait    lda 203    ; lit la matrice
.181d	c9 40		        cmp #64    ; 64 = aucune clef
.181f	d0 fa		        bne wait   ; attend la relache
.1821	68		        pla
.1822	28		        plp
.1823	60		        rts
.1824			getkey
.1824	08		        php
.1825	20 f5 f1	try     jsr getin  ;tente de lire
.1828	c9 00		        cmp #0     ; 0 si aucune.
.182a	f0 f9		        beq try    ; on reessaye
.182c	28		        plp
.182d	60		        rts
.182e			waitkey
.182e	08		        php
.182f	48		        pha
.1830	8d ba 24	        sta clef   ;Sauve clef voulue
.1833	20 ef 17	        jsr clrkbbuf
.1836	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.1839	cd ba 24	        cmp clef   ;Compare avec clef
.183c	d0 f8		        bne wait   ;Pas la bonne.
.183e	68		        pla
.183f	28		        plp
.1840	60		        rts
.1841			waitspace
.1841	a9 20		            lda #$20
.1843	20 2e 18	            jsr waitkey
.1846	20 ef 17	            jsr clrkbbuf
.1849	60		            rts
.184a			showkey
.184a	20 d5 13	        jsr pushregs
.184d	38		        sec
.184e	20 0a e5	        jsr plot
.1851	8e bc 24	        stx curx
.1854	8c bb 24	        sty cury
.1857	20 d5 13	        jsr pushregs
.185a	a0 1c		        ldy #39-11
.185c	a2 18		        ldx #24
.185e	18		        clc
.185f	20 0a e5	        jsr plot
.1862	20 02 14	        jsr popregs
.1865	20 7a f2	        jsr chrout
.1868	08		            php
.1869	48		            pha
.186a	a9 20		            lda #32
.186c	20 7a f2	            jsr chrout
.186f	68		            pla
.1870	28		            plp
.1871	08		            php
.1872	48		            pha
.1873	a9 24		            lda #36
.1875	20 7a f2	            jsr chrout
.1878	68		            pla
.1879	28		            plp
.187a	20 b2 17	        jsr putahexdec
.187d	18		        clc
.187e	ac bb 24	        ldy cury
.1881	ae bc 24	        ldx curx
.1884	20 0a e5	        jsr plot
.1887	20 02 14	        jsr popregs
.188a	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-screen.asm

.188b			scrnsave
.188b	20 63 13	        jsr pushall
.188e	20 d7 18	        jsr setcarptr
.1891	20 b1 18	        jsr zp1tozp2
.1894	20 e8 18	        jsr setcolptr
.1897	20 b1 18	        jsr zp1tozp2
.189a	20 9c 13	        jsr popall
.189d	60		        rts
.189e			scrnrest
.189e	20 63 13	        jsr pushall
.18a1	20 d7 18	        jsr setcarptr
.18a4	20 c4 18	        jsr zp2tozp1
.18a7	20 e8 18	        jsr setcolptr
.18aa	20 c4 18	        jsr zp2tozp1
.18ad	20 9c 13	        jsr popall
.18b0	60		        rts
.18b1			zp1tozp2
.18b1	a2 02		        ldx #>scrlen
.18b3	a0 00		        ldy #<scrlen
.18b5	b1 fb		nextcar lda (zp1),y
.18b7	91 fd		        sta (zp2),y
.18b9	c8		        iny
.18ba	d0 f9		        bne nextcar
.18bc	e6 fc		        inc zp1+1
.18be	e6 fe		        inc zp2+1
.18c0	ca		        dex
.18c1	d0 f2		        bne nextcar
.18c3	60		        rts
.18c4			zp2tozp1
.18c4	a2 02		        ldx #>scrlen
.18c6	a0 00		        ldy #<scrlen
.18c8	b1 fd		nextcar lda (zp2),y
.18ca	91 fb		        sta (zp1),y
.18cc	c8		        iny
.18cd	d0 f9		        bne nextcar
.18cf	e6 fc		        inc zp1+1
.18d1	e6 fe		        inc zp2+1
.18d3	ca		        dex
.18d4	d0 f2		        bne nextcar
.18d6	60		        rts
.18d7			setcarptr
.18d7	a9 00		        lda #<scrtxt
.18d9	85 fb		        sta zp1
.18db	a9 10		        lda #>scrtxt
.18dd	85 fc		        sta zp1+1
.18df	a9 b3		        lda #<scrncar
.18e1	85 fd		        sta zp2
.18e3	a9 22		        lda #>scrncar
.18e5	85 fe		        sta zp2+1
.18e7	60		        rts
.18e8			setcolptr
.18e8	a9 00		        lda #<scrcol
.18ea	85 fb		        sta zp1
.18ec	a9 94		        lda #>scrcol
.18ee	85 fc		        sta zp1+1
.18f0	a9 b3		        lda #<scrncol
.18f2	85 fd		        sta zp2
.18f4	a9 20		        lda #>scrncol
.18f6	85 fe		        sta zp2+1
.18f8	60		        rts
.18f9			fillscreen
.18f9	20 63 13	        jsr pushall
.18fc	a2 01		        ldx #$01
.18fe	a0 00		        ldy #$00
.1900	99 00 10	again   sta scrtxt,y
.1903	99 00 11	        sta scrtxt+256,y
.1906	48		        pha
.1907	ee 21 19	        inc col
.190a	ad 21 19	        lda col
.190d	29 7f		        and #$7f
.190f	29 07		        and #$07
.1911	09 18		        ora #$18
.1913	99 00 94	        sta scrcol,y
.1916	99 00 95	        sta scrcol+256,y
.1919	68		        pla
.191a	c8		        iny
.191b	d0 e3		        bne again
.191d	20 9c 13	        jsr popall
.1920	60		        rts
>1921	00		col     .byte 0

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=9519			libre    = *+3085
=9518			rp       = libre-$01;1 byte $cfff
=9517			ra       = rp-1     ;1 byte $cffe
=9516			rx       = ra-1     ;1 byte $cffd
=9515			ry       = rx-1     ;1 byte $cffc
=9514			rs       = ry-1     ;1 byte $cffb
=9512			pc       = rs-2     ;2 byte $cff9-$cffa
=9511			curcol   = pc-1     ;1 byte $cff6
=9510			memptr   = curcol-1;1 word $cff7-$cff8
=9508			src      = memptr-2
=9506			dst      = memptr-4
=9504			loopcount = memptr-6
=9504			hexv     = loopcount
.1922			a2hexstr
=9499			hexstr   = hexv-$05 ;5 byte
=9498			a2hexpfx = hexv-$06 ;1 byte
=9497			a2hexpy  = hexv-$07 ;1 byte
=9496			a2hexpx  = hexv-$08 ;1 byte
=9496			a2hexpos = hexv-$08 ;0 byte
=9495			a2hexcol = hexv-$09 ;1 byte
=9495			binv     = a2hexcol
=9486			binstr   = binv-$09 ;9 byte
=9485			a2binpfx = binv-$0a ;1 byte
=9484			a2binpy  = binv-$0b ;1 byte
=9483			a2binpx  = binv-$0c ;1 byte
=9483			a2binpos = binv-$0c ;0 byte
=9482			a2bincol = binv-$0d ;1 byte
=9482			decv     = a2bincol
=9476			decstr   = decv-$06 ;6 byte
=9475			a2decpfx = decv-$07 ;1 byte
=9474			a2decpy  = decv-$08 ;1 byte
=9473			a2decpx  = decv-$09 ;1 byte
=9473			a2decpos = decv-$09 ;0 byte
=9472			a2deccol = decv-$0a ;1 byte
=9471			offset   = decv-$0b ;1 byte
=9471			fltv     = offset
=9465			fvar1    = fltv-6  ; 6 byte
=9459			fvar2    = fltv-12 ; 6 byte
=9439			float1   = fltv-32 ;20 byte
=9419			float2   = fltv-52 ;20 byte
=9418			tval1    = fltv-53 ; 1 byte
=9416			tval2    = fltv-55 ; 2 byte
=9414			reponse  = tval2-2 ; 2 byte
=9414			edbox    = reponse
=9413			cleft    = edbox-1 ;1 byte
=9412			cright   = edbox-2 ;1 byte
=9411			cmid     = edbox-3 ;1 byte
=9410			dbtop    = edbox-4 ;1 byte
=9409			dbleft   = edbox-5 ;1 byte
=9408			dbwdth   = edbox-6 ;1 byte
=9407			dbhght   = edbox-7 ;1 byte
=9406			dbcoul   = edbox-8 ;1 byte
=9405			dbclin   = edbox-9 ;1 byte
=9405			ekeyb    = dbclin
=9404			curx     = ekeyb-1 ;1 byte
=9403			cury     = ekeyb-2 ;1 byte
=9402			clef     = ekeyb-3 ;1 byte
=9401			len      = clef-1  ;1 byte
=9400			cx       = clef-2  ;1 byte
=9399			cy       = clef-3  ;1 byte
=9398			bcol     = clef-4  ;1 byte
=9398			escr     = bcol         ;2051 bytes
=9397			loops    = escr-1       ;   1 byte
=9395			loop16   = loops-2      ;   2 byte
=8883			scrncar  = loop16-$200  ;  1k byte
=8371			scrncol  = scrncar-$200 ;  1k byte
=8371			diskvar = scrncol
=8369			ddatas  = diskvar-2 ;2 byte Data start
=8367			ddatae  = diskvar-4 ;2 byte Data end
=8366			ddev    = diskvar-5 ;1 byte Dev number
=8365			dlfsno  = diskvar-6 ;1 byte Lfs
=8363			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=8362			dfnlen  = diskvar-9 ;1 byte lenfilename
=8361			genbyte1 = dfnlen-1 ; 1 byte
=8359			genword1 = dfnlen-3 ; 2 byte
=8358			endofvars = genword1-1

;******  Return to file: keyfinder.asm


;******  End of listing
