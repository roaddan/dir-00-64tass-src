
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L dlbug20.txt -o dlbug20.prg dlbug20.asm
; Wed Feb 18 11:30:37 2026

;Offset	;Hex		;Source

;******  Processing input file: dlbug20.asm

="220260131-192144"	Version = "220260131-192144"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

=$1000			scrtxt    = $1000
=$9400			scrcol    = $9400
=$0200			scrlen    = $0200
=$1200			basstart  = $1200
>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	20 34 36 32	         .text format("%5d", bhstart)
>120a	32
>120b	00		         .byte $00   ;fin de cmd basic.
>120c	00 00		bcmd2    .word $00   ;adresse de la pro-
.120e	20 1a 12	bhstart   jsr bhscrini
.1211	ea		          nop
.1212	ea		          nop
.1213	ea		          nop
.1214	ea		          nop
.1215	ea		          nop
.1216	20 46 12	basnold   jsr main
.1219	60		          rts
.121a			bhscrini
.121a	08		        php
.121b	48		        pha
.121c	a9 84		        lda #(128+4)
.121e	8d 00 90	        sta vic0
.1221	ad 0f 90	bord    lda $900f    ;place la couleur
.1224	29 08		        and #%00001000
.1226	09 e3		        ora #%11100011
.1228	8d 0f 90	        sta $900f
.122b	a9 00		text    lda #$00    ;place la couleur
.122d	8d 86 02	        sta $0286   ; du texte.
.1230	a9 93		        lda #$93    ;efface l'ecran par
.1232	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.1235	68		        pla
.1236	28		        plp
.1237	60		        rts
.1238			bhprint
.1238	a0 00		        ldy #$00
.123a	b1 fb		nextc   lda ($fb),y
.123c	f0 07		        beq end
.123e	c8		        iny
.123f	20 d2 ff	        jsr $ffd2
.1242	4c 3a 12	        jmp nextc
.1245	60		end     rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm

.1246			R

;******  Return to file: dlbug20.asm

.1246			main
.1246	08		            php
.1247	48		            pha
.1248	a9 1b		            lda #(vblanc*16+(vocean|8))
.124a	8d 0f 90	            sta vic15
.124d	a9 06		            lda #vbleu
.124f	8d 86 02	            sta kcol
.1252	a9 93		            lda #147
.1254	20 d2 ff	            jsr $ffd2
.1257	68		            pla
.1258	28		            plp
.1259	08		            php
.125a	48		            pha
.125b	a9 0e		            lda #locase
.125d	20 7a f2	            jsr chrout
.1260	68		            pla
.1261	28		            plp
.1262	20 b4 19	          jsr fillscreen
.1265	20 b3 12	          jsr kmenu
.1268	08		            php
.1269	48		            pha
.126a	a9 1f		            lda #sbleu
.126c	20 7a f2	            jsr chrout
.126f	68		            pla
.1270	28		            plp
.1271	08		            php
.1272	48		            pha
.1273	a9 13		            lda #19
.1275	20 7a f2	            jsr chrout
.1278	68		            pla
.1279	28		            plp
.127a	08		            php
.127b	48		            pha
.127c	a9 24		            lda #'$'
.127e	20 7a f2	            jsr chrout
.1281	68		            pla
.1282	28		            plp
.1283	08		            php
.1284	a0 1b		            ldy #>prgend
.1286	a2 51		            ldx #<prgend
.1288	28		            plp
.1289	20 49 16	          jsr putyxhex
.128c	08		            php
.128d	48		            pha
.128e	a9 0d		            lda #13
.1290	20 7a f2	            jsr chrout
.1293	68		            pla
.1294	28		            plp
.1295	08		            php
.1296	48		            pha
.1297	a9 24		            lda #'$'
.1299	20 7a f2	            jsr chrout
.129c	68		            pla
.129d	28		            plp
.129e	08		            php
.129f	ac 52 1b	            ldy prgend+1
.12a2	ae 51 1b	            ldx prgend
.12a5	28		            plp
.12a6	20 49 16	          jsr putyxhex
.12a9	08		            php
.12aa	48		            pha
.12ab	a9 0d		            lda #13
.12ad	20 7a f2	            jsr chrout
.12b0	68		            pla
.12b1	28		            plp
.12b2	60		          rts
.12b3			kmenu
.12b3	20 af 13	          jsr  pushregs
.12b6	20 d6 18	uneclef   jsr  getkey
.12b9	20 58 18	          jsr  putahexdec
.12bc	c9 5f		          cmp  #$5f ;[ESC]
.12be	d0 03		          bne  keyr
.12c0	4c cd 12	          jmp  out
.12c3	c9 12		keyr      cmp  #$12 ;[CTRL][R]
.12c5	d0 03		          bne  nextkey
.12c7	20 d3 19	          jsr  showregs
.12ca	4c b6 12	nextkey   jmp  uneclef
.12cd	20 dc 13	out       jsr  popregs
.12d0	60		          rts

;******  Processing file: string-fr.asm

>12d1	20 90 12	rtitle         .byte 32,snoir,revson        ;0-2
>12d4	20 43 50 55	               .text " cpu registers hex " ;3-23
>12d8	20 52 45 47 49 53 54 45 52 53 20 48 45 58 20
>12e7	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>12eb	00		               .byte 0
>12ec	20 1f 92	rlable         .byte 32,sbleu,revsoff
>12ef	20 50 43 20	               .text " pc  ra rx ry sr sp"
>12f3	20 52 41 20 52 58 20 52 59 20 53 52 20 53 50
>1302	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1306	00		               .byte 0
>1307	20 1c 92	rvalues        .byte 32,srouge,revsoff        ;0-2 - 0
>130a	30 30 30 30	               .text "0000 00 00 00 00 00" ;3-23
>130e	20 30 30 20 30 30 20 30 30 20 30 30 20 30 30
>131d	90 92 20 0d	               .byte snoir,revsoff,32,$0d    ;24-27
>1321	00		               .byte 0
>1322	20 90 92	rbline         .byte 32,snoir,revsoff        ;0-2
>1325	c0		               .byte 192    ;9-13
>1326	53 4f 52 54	               .text "sortir=[ctrl]-[x]"
>132a	49 52 3d 5b 43 54 52 4c 5d 2d 5b 58 5d
>1337	c0		               .byte 192         ;19-23
>1338	90 92 20 0d	               .byte snoir,revsoff,32,$0d    ;24-27
>133c	00		               .byte 0

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.133d			pushall
.133d	08		         php     ;s;rp,pcl,pch
.133e	8d fd 0f	         sta ra  ;sauve a
.1341	68		         pla     ;s:pcl,pch
.1342	8d fe 0f	         sta rp  ;sauve rp
.1345	68		         pla     ;s:pch
.1346	8d f8 0f	         sta pc  ;sauve pcl
.1349	68		         pla     ;s:
.134a	8d f9 0f	         sta pc+1;sauve pch
.134d	a5 fb		         lda $fb ;sauve fb
.134f	48		         pha     ;s:fb
.1350	a5 fc		         lda $fc ;sauve fc
.1352	48		         pha     ;s:fc,fb
.1353	a5 fd		         lda $fd ;sauve fd
.1355	48		         pha     ;s:fd,fc,fb
.1356	a5 fe		         lda $fe ;sauve fe
.1358	48		         pha     ;s:fe,fd,fc,fb
.1359	ad fe 0f	         lda rp  ;sauve rp
.135c	48		         pha     ;s:rp,fe,fd,fc,fb
.135d	ad fd 0f	         lda ra  ;sauve ra
.1360	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.1361	8a		         txa     ;sauve rx
.1362	48		         pha     ;s:rx,ra,rp,fe-fb
.1363	98		         tya     ;sauve y
.1364	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.1365	ad f9 0f	         lda pc+1;replace l'adresse
.1368	48		         pha     ;s:pch,ry,rx,ra,...
.1369	ad f8 0f	         lda pc  ; de retour.
.136c	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.136d	ad fe 0f	         lda rp  ;place les flags
.1370	48		         pha     ; sur le stack.
.1371	ad fd 0f	         lda ra  ;recupere ra
.1374	28		         plp     ;recupere les flags.
.1375	60		         rts
.1376			popall
.1376	08		         php     ;s:rp,pcl,pch,ry,rx,...
.1377	8d fd 0f	         sta ra
.137a	68		         pla     ;s:pcl,pch,ry,rx,...
.137b	8d fe 0f	         sta rp  ;s:pch,ry,rx,ra,rp,...
.137e	68		         pla
.137f	8d f8 0f	         sta pc  ;sauve pcl
.1382	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.1383	8d f9 0f	         sta pc+1;sauve pch
.1386	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.1387	a8		         tay     ;recupere ry
.1388	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.1389	aa		         tax     ;recupere rx
.138a	68		         pla     ;s:rp,fe,fd,fc,fb
.138b	8d fd 0f	         sta ra  ;recupere ra
.138e	68		         pla     ;s:fe,fd,fc,fb
.138f	8d fe 0f	         sta rp  ;recupere les flags.
.1392	68		         pla     ;s:fd,fc,fb
.1393	85 fe		         sta $fe ;reccupere fe
.1395	68		         pla     ;s:fc,fb
.1396	85 fd		         sta $fd ;recupere fd
.1398	68		         pla     ;s:fb
.1399	85 fc		         sta $fc ;recupere fc
.139b	68		         pla     ;s:
.139c	85 fb		         sta $fb ;recupere fb
.139e	ad f9 0f	         lda pc+1;replaace l'adresse de
.13a1	48		         pha     ;s:pch
.13a2	ad f8 0f	         lda pc  ;retour sur la pile
.13a5	48		         pha     ;s:pcl,pch
.13a6	ad fe 0f	         lda rp  ;recupere les flags
.13a9	48		         pha     ;s:rp,pcl,pch
.13aa	ad fd 0f	         lda ra  ;recupere ra
.13ad	28		         plp     ;s:pcl,pch
.13ae	60		         rts
.13af			pushregs
.13af	08		         php     ;s;rp,pcl,pch
.13b0	8d fd 0f	         sta ra  ; -- sauve a
.13b3	68		         pla     ;s:pcl,pch
.13b4	8d fe 0f	         sta rp  ; -- sauve rp
.13b7	68		         pla     ;s:pch
.13b8	8d f8 0f	         sta pc  ; -- sauve pcl
.13bb	68		         pla     ;s:
.13bc	8d f9 0f	         sta pc+1; -- sauve pch
.13bf	ad fe 0f	         lda rp  ; -- sauve rp
.13c2	48		         pha     ;s:rp
.13c3	ad fd 0f	         lda ra  ; -- sauve ra
.13c6	48		         pha     ;s:ra,rp
.13c7	8a		         txa     ; -- tfr rx
.13c8	48		         pha     ;s:rx,ra,rp
.13c9	98		         tya     ; -- tfr ry
.13ca	48		         pha     ;s:ry,rx,ra,rp
.13cb	ad f9 0f	         lda pc+1; -- replace l'adresse
.13ce	48		         pha     ;s:pch,ry,rx,ra,rp
.13cf	ad f8 0f	         lda pc  ; -- de retour.
.13d2	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.13d3	ad fe 0f	         lda rp  ; -- place les flags
.13d6	48		         pha     ;    sur le stack.
.13d7	ad fd 0f	         lda ra  ; -- recupere ra
.13da	28		         plp     ; -- recupere flags.
.13db	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.13dc			popregs
.13dc	08		         php
.13dd	8d fd 0f	         sta ra
.13e0	68		         pla
.13e1	8d fe 0f	         sta rp
.13e4	68		         pla     ;s:pch,ry,rx,ra,rp
.13e5	8d f8 0f	         sta pc  ; -- sauve pcl
.13e8	68		         pla     ;s:ry,rx,ra,rp
.13e9	8d f9 0f	         sta pc+1; -- sauve pch
.13ec	68		         pla     ;s:rx,ra,rp
.13ed	a8		         tay     ;recupere ry
.13ee	68		         pla     ;s:ra,rp
.13ef	aa		         tax     ;recupere rx
.13f0	68		         pla     ;s:rp
.13f1	8d fd 0f	         sta ra  ;recupere ra
.13f4	68		         pla     ;s:
.13f5	8d fe 0f	         sta rp  ;recupere les flags.
.13f8	ad f9 0f	         lda pc+1;replace l'adresse de
.13fb	48		         pha     ;s:pch
.13fc	ad f8 0f	         lda pc  ;retour sur la pile
.13ff	48		         pha     ;s:pcl,pch
.1400	ad fe 0f	         lda rp  ;recupere les flags
.1403	48		         pha     ;s:rp,pcl,pch
.1404	ad fd 0f	         lda ra  ;recupere ra
.1407	28		         plp     ;s:pcl,pch
.1408	60		         rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.1409			puts
.1409	20 3d 13	          jsr pushall
.140c	a0 00		          ldy #$00   ; y = offset
.140e	b1 fb		nextc     lda ($fb),y;lit un caractere
.1410	f0 09		          beq out    ;si 0 on sort
.1412	20 7a f2	          jsr chrout ;on l'affiche
.1415	20 56 15	          jsr inczp1 ;pointe le prochain
.1418	4c 0e 14	          jmp nextc  ; et l'affiche
.141b	20 76 13	out       jsr popall
.141e	60		          rts
.141f			putsyx
.141f	20 3d 13	          jsr pushall;sauve reg + zps
.1422	86 fb		          stx $fb    ;$yyxx dans
.1424	84 fc		          sty $fb+1  ; zp1
.1426	20 09 14	          jsr puts
.1429	20 76 13	          jsr popall ;recup reg + zps
.142c	60		          rts
.142d			putsxy
.142d	20 3d 13	        jsr pushall;sauve reg + zps
.1430	86 fb		        stx $fb    ;$yyxx dans
.1432	84 fc		        sty $fb+1  ; zp1
.1434	a0 00		        ldy #$00
.1436	b1 fb		        lda ($fb),y
.1438	aa		        tax
.1439	20 56 15	        jsr inczp1
.143c	b1 fb		        lda ($fb),y
.143e	20 56 15	        jsr inczp1
.1441	a8		        tay
.1442	20 97 14	        jsr gotoxy
.1445	20 09 14	        jsr puts
.1448	20 76 13	        jsr popall ;recup reg + zps
.144b	60		        rts
.144c			putsc
.144c	08		          php       ;flag sur stack
.144d	48		          pha       ;acc sur stack
.144e	48		          pha       ;sauvegarde acc
.144f	ad 86 02	          lda kcol  ;recup coul. carac.
.1452	8d f7 0f	          sta curcol; et la sauvegarde
.1455	68		          pla       ;recup. acc
.1456	8d 86 02	          sta kcol  ;place coul. voulue
.1459	20 09 14	          jsr puts  ;affiche la chaine
.145c	ad f7 0f	          lda curcol;recup coul. carac.
.145f	8d 86 02	          sta kcol  ; et la replace
.1462	68		          pla       ;recup acc
.1463	28		          plp       ;recup flag
.1464	60		          rts
.1465			putscyx
.1465	08		          php       ;sauve registres
.1466	48		          pha       ; ...
.1467	48		          pha       ;sauve acc
.1468	ad 86 02	          lda kcol  ;recup couleur carac.
.146b	8d f7 0f	          sta curcol; et sauvegarde
.146e	68		          pla       ;recup acc
.146f	8d 86 02	          sta kcol  ;place couleur carac.
.1472	20 1f 14	          jsr putsyx;affiche la chaine
.1475	ad f7 0f	          lda curcol
.1478	8d 86 02	          sta kcol
.147b	68		          pla
.147c	28		          plp
.147d	60		          rts
.147e			putscxy
.147e	08		          php       ;sauve registres
.147f	48		          pha       ; ...
.1480	48		          pha       ;sauve acc
.1481	ad 86 02	          lda kcol  ;recup couleur carac.
.1484	8d f7 0f	          sta curcol; et sauvegarde
.1487	68		          pla       ;recup acc
.1488	8d 86 02	          sta kcol   ;place couleur carac.
.148b	20 1f 14	          jsr putsyx ;affiche la chaine
.148e	ad f7 0f	          lda curcol
.1491	8d 86 02	          sta kcol
.1494	68		          pla
.1495	28		          plp
.1496	60		          rts
.1497			gotoxy
.1497	20 af 13	          jsr pushregs
.149a	8a		          txa ; interchange x et y
.149b	48		          pha ; ...
.149c	98		          tya ; ...
.149d	aa		          tax ; ...
.149e	68		          pla ; ...
.149f	a8		          tay ; ...
.14a0	c0 00		txlow     cpy #0
.14a2	10 02		          bpl txhigh
.14a4	a2 00		          ldx #0
.14a6	e0 19		txhigh    cpx #25
.14a8	30 02		          bmi tylow
.14aa	a2 18		          ldx #24
.14ac	c0 00		tylow     cpy #0
.14ae	10 02		          bpl tyhigh
.14b0	a0 00		          ldy #0
.14b2	c0 28		tyhigh    cpy #40
.14b4	30 02		          bmi allok
.14b6	a0 27		          ldy #39
.14b8	18		allok     clc
.14b9	20 0a e5	          jsr plot
.14bc	20 dc 13	          jsr popregs
.14bf	60		          rts
.14c0			putnch
.14c0	20 af 13	        jsr pushregs
.14c3	20 7a f2	again   jsr chrout
.14c6	ca		        dex
.14c7	d0 fa		        bne again
.14c9	20 dc 13	        jsr popregs
.14cc	60		        rts
.14cd			strlen
.14cd	20 3d 13	        jsr pushall
.14d0	84 fc		        sty zp1+1
.14d2	86 fb		        stx zp1
.14d4	a0 00		        ldy #$00
.14d6	8c 88 0f	        sty len
.14d9	b1 fb		next    lda (zp1),y
.14db	f0 07		        beq out
.14dd	ee 88 0f	        inc len
.14e0	c8		        iny
.14e1	4c d9 14	        jmp next
.14e4	20 76 13	out     jsr popall
.14e7	ad 88 0f	        lda len
.14ea	60		        rts
.14eb			cursor
.14eb	20 af 13	          jsr  pushregs
.14ee	90 12		          bcc  get    ;C=0 récupération.
.14f0	20 0a e5	          jsr  plot  ;récupère position
.14f3	8c 87 0f	          sty  cx     ;curseur et sauve
.14f6	8e 86 0f	          stx  cy     ;dans vars locales.
.14f9	ad 86 02	          lda  kcol   ;Sauve couleur
.14fc	8d 85 0f	          sta  bcol   ; BASIC du texte.
.14ff	4c 11 15	          jmp  out    ;Fini on sort.
.1502	ae 86 0f	get       ldx  cy     ;C=1, charge x
.1505	ac 87 0f	          ldy  cx     ; ligne, y col.
.1508	20 0a e5	          jsr  plot  ;Position curseur.
.150b	ad 85 0f	          lda  bcol   ;replace couleur
.150e	8d 86 02	          sta  kcol ; basic sauvegardé.
.1511	20 dc 13	out       jsr  popregs
.1514	60		          rts
.1515			curget
.1515			cursave
.1515	08		          php
.1516	38		          sec
.1517	20 eb 14	          jsr  cursor
.151a	28		          plp
.151b	60		          rts
.151c			curput
.151c			currest
.151c	08		          php
.151d	18		          clc
.151e	20 eb 14	          jsr  cursor
.1521	28		          plp
.1522	60		          rts
.1523			isprnable
.1523	08		          php
.1524	c9 a0		          cmp  #160
.1526	b0 0b		          bcs  yes
.1528	c5 85		          cmp  133
.152a	b0 04		          bcs  no
.152c	c9 20		          cmp  #32
.152e	b0 03		          bcs  yes
.1530	28		no        plp
.1531	18		          clc
.1532	60		          rts
.1533	28		yes       plp
.1534	38		          sec
.1535	60		          rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.1536			blkfill
.1536	20 3d 13	bf0     jsr pushall
.1539	84 fc		        sty zp1+1
.153b	a0 00		        ldy #$00
.153d	84 fb		        sty zp1
.153f	91 fb		bf1     sta (zp1),y
.1541	c8		        iny
.1542	d0 fb		        bne bf1
.1544	20 76 13	        jsr popall
.1547	60		        rts
.1548			memfill
.1548	20 af 13	        jsr pushregs
.154b	20 36 15	mf1     jsr blkfill
.154e	c8		        iny
.154f	ca		        dex
.1550	d0 f9		        bne mf1
.1552	20 dc 13	        jsr popregs
.1555	60		        rts
.1556			inczp1
.1556	08		         php
.1557	e6 fb		         inc zp1
.1559	d0 02		         bne repzp1
.155b	e6 fc		         inc zp1+1
.155d	28		repzp1   plp
.155e	60		         rts
.155f			inczp2
.155f	08		         php
.1560	e6 fd		         inc zp2
.1562	d0 02		         bne repzp2
.1564	e6 fe		         inc zp2+1
.1566	28		repzp2   plp
.1567	60		         rts
.1568			deczp1
.1568	08		         php
.1569	48		         pha
.156a	a5 fb		         lda zp1
.156c	d0 02		         bne noemp
.156e	c6 fc		         dec zp1+1
.1570	c6 fb		noemp    dec zp1
.1572	68		         pla
.1573	28		         plp
.1574	60		         rts
.1575			deczp2
.1575	08		         php
.1576	48		         pha
.1577	a5 fd		         lda zp2
.1579	d0 02		         bne noemp
.157b	c6 fe		         dec zp2+1
.157d	c6 fd		noemp    dec zp2
.157f	68		         pla
.1580	28		         plp
.1581	60		         rts
.1582			rolzp1
.1582	08		        php
.1583	48		        pha
.1584	18		        clc
.1585	a5 fb		        lda zp1
.1587	2a		        rol
.1588	85 fb		        sta zp1
.158a	a5 fc		        lda zp1+1
.158c	2a		        rol
.158d	85 fc		        sta zp1+1
.158f	68		        pla
.1590	28		        plp
.1591			rorzp1
.1591	08		        php
.1592	48		        pha
.1593	18		        clc
.1594	a5 fc		        lda zp1+1
.1596	6a		        ror
.1597	85 fc		        sta zp1+1
.1599	a5 fb		        lda zp1
.159b	6a		        ror
.159c	85 fb		        sta zp1
.159e	68		        pla
.159f	28		        plp
.15a0			rolzp2
.15a0	08		        php
.15a1	48		        pha
.15a2	18		        clc
.15a3	a5 fd		        lda zp2
.15a5	2a		        rol
.15a6	85 fd		        sta zp2
.15a8	a5 fe		        lda zp2+1
.15aa	2a		        rol
.15ab	85 fe		        sta zp2+1
.15ad	68		        pla
.15ae	28		        plp
.15af			rorzp2
.15af	08		        php
.15b0	48		        pha
.15b1	18		        clc
.15b2	a5 fe		        lda zp2+1
.15b4	6a		        ror
.15b5	85 fe		        sta zp2+1
.15b7	a5 fd		        lda zp2
.15b9	6a		        ror
.15ba	85 fd		        sta zp2
.15bc	68		        pla
.15bd	28		        plp
.15be			yxtoptr
.15be	8c f6 0f	        sty memptr+1
.15c1	8e f5 0f	        stx memptr
.15c4	60		        rts
.15c5			ptrtoyx
.15c5	08		        php
.15c6	ac f6 0f	        ldy memptr+1
.15c9	ae f5 0f	        ldx memptr
.15cc	28		        plp
.15cd	60		        rts
.15ce			incptr
.15ce	08		        php
.15cf	ee f5 0f	        inc memptr
.15d2	d0 03		        bne norep
.15d4	ee f6 0f	        inc memptr+1
.15d7	28		norep   plp
.15d8	60		        rts
.15d9			decptr
.15d9	08		        php
.15da	48		        pha
.15db	ad f5 0f	        lda memptr
.15de	d0 03		        bne noemp
.15e0	ee f6 0f	        inc memptr+1
.15e3	ee f5 0f	noemp   inc memptr
.15e6	68		        pla
.15e7	28		        plp
.15e8	60		        rts
.15e9			incptr8
.15e9	08		        php
.15ea	48		        pha
.15eb	98		        tya
.15ec	48		        pha
.15ed	a0 08		        ldy #8
.15ef	20 ce 15	again   jsr incptr
.15f2	88		        dey
.15f3	d0 fa		        bne again
.15f5	68		        pla
.15f6	a8		        tay
.15f7	68		        pla
.15f8	28		        plp
.15f9	60		        rts
.15fa			loop
.15fa	ce ef 0f	               dec  loopcount
.15fd	d0 03		               bne  norep
.15ff	ce f0 0f	               dec  loopcount+1
.1602	ad ef 0f	norep          lda  loopcount
.1605	c9 00		               cmp  #$00
.1607	d0 05		               bne  out
.1609	4d f0 0f	               eor  loopcount+1
.160c	c9 ff		               cmp  #$ff
.160e	60		out            rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.160f			addtoword
.160f			addatoyx
.160f	08		        php
.1610	48		        pha
.1611	8c 96 0f	        sty reponse+1
.1614	8e 95 0f	        stx reponse
.1617	18		        clc
.1618	6d 95 0f	        adc reponse
.161b	90 03		        bcc norep
.161d	ee 96 0f	        inc reponse+1
.1620	8d 95 0f	norep   sta reponse
.1623	ac 96 0f	        ldy reponse+1
.1626	ae 95 0f	        ldx reponse
.1629	68		        pla
.162a	28		        plp
.162b	60		        rts
.162c			subtoword
.162c			subatoyx
.162c	08		        php
.162d	48		        pha
.162e	8c 96 0f	        sty reponse+1
.1631	8e 95 0f	        stx reponse
.1634	38		        sec
.1635	ed 95 0f	        sbc reponse
.1638	b0 03		        bcs noemp
.163a	ce 96 0f	        dec reponse+1
.163d	8d 95 0f	noemp   sta reponse
.1640	ac 96 0f	        ldy reponse+1
.1643	ae 95 0f	        ldx reponse
.1646	68		        pla
.1647	28		        plp
.1648	60		        rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.1649			putyxhex
.1649	20 3d 13	        jsr pushall
.164c	98		        tya
.164d	48		        pha
.164e	20 cc 16	        jsr lsr4bits
.1651	20 df 16	        jsr nibtohex
.1654	8d ea 0f	        sta hexstr+0
.1657	68		        pla
.1658	20 df 16	        jsr nibtohex
.165b	8d eb 0f	        sta hexstr+1
.165e	8a		        txa
.165f	20 7e 16	        jsr atohex
.1662	a2 ea		        ldx #<hexstr+0
.1664	a0 0f		        ldy #>hexstr+0
.1666	20 1f 14	        jsr putsyx
.1669	20 76 13	        jsr popall
.166c	60		        rts
.166d			putahex
.166d	20 af 13	        jsr pushregs
.1670	20 7e 16	        jsr atohex
.1673	a2 ec		        ldx #<hexstr+2
.1675	a0 0f		        ldy #>hexstr+2
.1677	20 1f 14	        jsr putsyx
.167a	20 dc 13	        jsr popregs
.167d	60		        rts
.167e			atohex
.167e	08		        php
.167f	48		        pha
.1680	48		        pha
.1681	20 cc 16	        jsr lsr4bits
.1684	20 df 16	        jsr nibtohex
.1687	8d ec 0f	        sta hexstr+2
.168a	68		        pla
.168b	20 df 16	        jsr nibtohex
.168e	8d ed 0f	        sta hexstr+3
.1691	a9 00		        lda #$00
.1693	8d ee 0f	        sta hexstr+4
.1696	68		        pla
.1697	28		        plp
.1698	60		        rts
.1699			putabin
.1699	20 af 13	          jsr     pushregs
.169c	20 aa 16	          jsr     atobin
.169f	a2 dd		          ldx     #<binstr
.16a1	a0 0f		          ldy     #>binstr
.16a3	20 1f 14	          jsr     putsyx
.16a6	20 dc 13	          jsr     popregs
.16a9	60		          rts
.16aa			atobin
.16aa	20 af 13	          jsr  pushregs
.16ad	a2 08		          ldx  #8
.16af	a0 00		          ldy  #0
.16b1	18		          clc
.16b2	2a		nextbit   rol
.16b3	48		          pha
.16b4	69 00		          adc  #$00
.16b6	29 01		          and  #$01
.16b8	20 df 16	          jsr  nibtohex
.16bb	99 dd 0f	          sta  binstr,y
.16be	68		          pla
.16bf	c8		          iny
.16c0	ca		          dex
.16c1	d0 ef		          bne  nextbit
.16c3	a9 00		          lda  #0
.16c5	99 dd 0f	          sta  binstr,y
.16c8	20 dc 13	          jsr  popregs
.16cb	60		          rts
.16cc			lsr4bits
.16cc	08		          php
.16cd	4a		          lsr a
.16ce	4a		          lsr a
.16cf	4a		          lsr a
.16d0	4a		          lsr a
.16d1	28		          plp
.16d2	60		          rts
.16d3			nibtohexb
.16d3	08		        php
.16d4	29 0f		        and #$0f
.16d6	f8		        sed
.16d7	18		        clc
.16d8	69 90		        adc #$90
.16da	69 40		        adc #$40
.16dc	d8		        cld
.16dd	28		        plp
.16de	60		        rts
.16df			nibtohex
.16df	08		        php
.16e0	8c fe 16	        sty myy
.16e3	29 0f		        and #$0f
.16e5	a8		        tay
.16e6	b9 ee 16	        lda hextbl,y
.16e9	ac fe 16	        ldy myy
.16ec	28		        plp
.16ed	60		        rts
>16ee	30 31 32 33	hextbl  .byte $30,$31,$32,$33,$34
>16f2	34
>16f3	35 36 37 38	        .byte $35,$36,$37,$38,$39
>16f7	39
>16f8	41 42 43 44	        .byte $41,$42,$43,$44,$45
>16fc	45
>16fd	46		        .byte $46
>16fe	00		myy     .byte $00
.16ff			bytestohex
.16ff	20 3d 13	        jsr pushall
.1702	84 fc		        sty zp1+1
.1704	86 fb		        stx zp1
.1706	08		            php
.1707	48		            pha
.1708	a9 20		            lda #32
.170a	20 7a f2	            jsr chrout
.170d	68		            pla
.170e	28		            plp
.170f	08		            php
.1710	48		            pha
.1711	a9 05		            lda #5
.1713	20 7a f2	            jsr chrout
.1716	68		            pla
.1717	28		            plp
.1718	08		            php
.1719	48		            pha
.171a	a9 24		            lda #36
.171c	20 7a f2	            jsr chrout
.171f	68		            pla
.1720	28		            plp
.1721	20 49 16	        jsr putyxhex   ; prn adreponsese
.1724	08		            php
.1725	48		            pha
.1726	a9 20		            lda #$20
.1728	20 7a f2	            jsr chrout
.172b	68		            pla
.172c	28		            plp
.172d	08		            php
.172e	48		            pha
.172f	a9 9f		            lda #159
.1731	20 7a f2	            jsr chrout
.1734	68		            pla
.1735	28		            plp
.1736	a0 00		        ldy #$00
.1738	aa		        tax
.1739	8c ce 0f	another sty offset
.173c	b1 fb		        lda (zp1),y
.173e	20 6d 16	        jsr putahex
.1741	48		        pha
.1742	20 61 17	        jsr petsciiaddr
.1745	68		        pla
.1746	8d 00 04	petscii sta $0400
.1749	48		        pha
.174a	a9 0d		        lda #$0d
.174c	8d 00 d8	petcol  sta $d800
.174f	68		        pla
.1750	08		            php
.1751	48		            pha
.1752	a9 20		            lda #$20
.1754	20 7a f2	            jsr chrout
.1757	68		            pla
.1758	28		            plp
.1759	c8		        iny
.175a	ca		        dex
.175b	d0 dc		        bne another
.175d	20 76 13	        jsr popall
.1760	60		        rts
.1761			petsciiaddr
.1761	20 af 13	        jsr pushregs
.1764	a9 1f		        lda #31
.1766	18		        clc
.1767	6d ce 0f	        adc offset
.176a	20 0f 16	        jsr addatoyx
.176d	8c 48 17	        sty petscii+2
.1770	8e 47 17	        stx petscii+1
.1773	8e 4d 17	        stx petcol+1
.1776	98		        tya
.1777	29 fb		        and #%11111011 ;#%00000100
.1779	09 d8		        ora #$d8
.177b	8d 4e 17	        sta petcol+2
.177e	a8		        tay
.177f	20 dc 13	        jsr popregs
.1782	60		        rts
.1783			strhexval
.1783	20 3d 13	        jsr pushall ; sauve registre
.1786	84 fc		        sty zp1+1   ; ptr dans zp1
.1788	86 fb		        stx zp1
.178a	20 cd 14	        jsr strlen  ;len de $(yyxx)->a
.178d	f0 3d		        beq oute    ; si 0 erreur C=1
.178f	a0 00		        ldy #$00    ; offset a 0
.1791	8c 96 0f	        sty reponse+1; reponse a zero
.1794	8c 95 0f	        sty reponse ;    ...
.1797	b1 fb		nextc   lda (zp1),y ;charge un caractere
.1799	f0 26		        beq out     ;On  a fini
.179b	c0 00		        cpy #$00    ;si c'est le premier
.179d	f0 07		        beq norol   ; pas de rol
.179f	48		        pha         ;
.17a0	a9 04		        lda #$04    ;rol de 4 pos
.17a2	20 8c 18	        jsr rolword ;
.17a5	68		        pla         ;
.17a6	09 20		norol   ora #%00100000
.17a8	38		        sec
.17a9	e9 30		        sbc #$30
.17ab	c9 0a		        cmp #$0a
.17ad	90 07		        bcc lt10
.17af	38		        sec
.17b0	e9 27		        sbc #$27
.17b2	c9 10		        cmp #$10
.17b4	b0 16		        bcs oute
.17b6	0d 95 0f	lt10    ora reponse
.17b9	8d 95 0f	        sta reponse
.17bc	c8		        iny
.17bd	c0 04		        cpy #$04
.17bf	d0 d6		        bne nextc
.17c1	20 76 13	out     jsr popall
.17c4	18		        clc          ;Carry 0 = good
.17c5	ac 96 0f	        ldy reponse+1
.17c8	ae 95 0f	        ldx reponse
.17cb	60		        rts
.17cc	20 76 13	oute    jsr popall
.17cf	38		        sec
.17d0	60		        rts
.17d1			showra
.17d1	20 af 13	          jsr  pushregs
.17d4	ac 86 02	          ldy  kcol
.17d7	08		            php
.17d8	48		            pha
.17d9	a9 90		            lda #snoir
.17db	20 7a f2	            jsr chrout
.17de	68		            pla
.17df	28		            plp
.17e0	20 23 15	          jsr  isprnable
.17e3	b0 13		          bcs  okprn
.17e5	48		          pha
.17e6	08		            php
.17e7	48		            pha
.17e8	a9 1c		            lda #srouge
.17ea	20 7a f2	            jsr chrout
.17ed	68		            pla
.17ee	28		            plp
.17ef	a9 2e		          lda  #'.'
.17f1	20 7a f2	          jsr  chrout
.17f4	68		          pla
.17f5	4c fb 17	          jmp  noprn
.17f8	20 7a f2	okprn     jsr  chrout
.17fb			noprn
.17fb	08		            php
.17fc	48		            pha
.17fd	a9 20		            lda #32
.17ff	20 7a f2	            jsr chrout
.1802	68		            pla
.1803	28		            plp
.1804	08		            php
.1805	48		            pha
.1806	a9 1f		            lda #sbleu
.1808	20 7a f2	            jsr chrout
.180b	68		            pla
.180c	28		            plp
.180d	08		            php
.180e	48		            pha
.180f	a9 24		            lda #36
.1811	20 7a f2	            jsr chrout
.1814	68		            pla
.1815	28		            plp
.1816	20 6d 16	          jsr putahex
.1819	08		            php
.181a	48		            pha
.181b	a9 20		            lda #32
.181d	20 7a f2	            jsr chrout
.1820	68		            pla
.1821	28		            plp
.1822	08		            php
.1823	48		            pha
.1824	a9 1c		            lda #srouge
.1826	20 7a f2	            jsr chrout
.1829	68		            pla
.182a	28		            plp
.182b	08		            php
.182c	48		            pha
.182d	a9 25		            lda #37
.182f	20 7a f2	            jsr chrout
.1832	68		            pla
.1833	28		            plp
.1834	20 99 16	          jsr putabin
.1837	08		            php
.1838	48		            pha
.1839	a9 20		            lda #32
.183b	20 7a f2	            jsr chrout
.183e	68		            pla
.183f	28		            plp
.1840	08		            php
.1841	48		            pha
.1842	a9 9c		            lda #smauve
.1844	20 7a f2	            jsr chrout
.1847	68		            pla
.1848	28		            plp
.1849	48		          pha
.184a	aa		          tax
.184b	a9 00		          lda #$00
.184d	20 cd dd	          jsr fiaxtf1
.1850	68		          pla
.1851	8c 86 02	          sty kcol
.1854	20 dc 13	          jsr popregs
.1857	60		          rts
.1858			putahexdec
.1858	20 af 13	          jsr pushregs
.185b	20 15 15	          jsr  curget    ; Sauvegarde la position du curseur.
.185e	20 af 13	        jsr pushregs
.1861	a0 01		        ldy #1
.1863	a2 16		        ldx #22
.1865	18		        clc
.1866	20 0a e5	        jsr plot
.1869	20 dc 13	        jsr popregs
.186c	08		            php
.186d	48		            pha
.186e	a9 20		            lda #32
.1870	20 7a f2	            jsr chrout
.1873	68		            pla
.1874	28		            plp
.1875	20 d1 17	          jsr  showra    ; Affiche .a en ascii, hexa, bin et dec.
.1878	c9 63		          cmp  #99       ; Estce que le code ascii est > 99 dec.
.187a	10 09		          bpl  nospc     ; Non, on saute.
.187c	08		            php
.187d	48		            pha
.187e	a9 20		            lda #32
.1880	20 7a f2	            jsr chrout
.1883	68		            pla
.1884	28		            plp
.1885	20 1c 15	nospc     jsr  curput    ; Replkace le curseur à sa position initiale.
.1888	20 dc 13	          jsr popregs
.188b	60		          rts
.188c			rolword
.188c	20 af 13	        jsr pushregs
.188f	a8		        tay
.1890	18		again   clc
.1891	2e 95 0f	        rol reponse
.1894	2e 96 0f	        rol reponse+1
.1897	88		        dey
.1898	d0 f6		        bne again
.189a	20 dc 13	        jsr popregs
.189d	60		        rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.189e			clrkbbuf
.189e	08		          php
.189f	48		          pha
.18a0	a9 00		          lda #0
.18a2	85 c6		          sta 198
.18a4	20 e1 ff	          jsr $ffe1
.18a7	68		          pla
.18a8	28		          plp
.18a9	60		          rts
.18aa			waitstop
.18aa	08		          php    ;\ sauve les flags
.18ab	48		          pha    ;/  et l'acc.
.18ac	20 9e 18	          jsr clrkbbuf
.18af	20 70 f7	wait      jsr stop ; Veri [run/stop]
.18b2	d0 fb		          bne wait ;loop pas pesee.
.18b4	68		          pla    ;\ recup. acc et
.18b5	28		          plp    ;/  les flags.
.18b6	60		          rts
.18b7			anykey
.18b7	08		          php
.18b8	48		          pha
.18b9	20 9e 18	          jsr clrkbbuf
.18bc	a5 cb		wait      lda 203    ;lit la matrice de
.18be	c9 40		          cmp #64    ; 64 = aucune clef
.18c0	f0 fa		          beq wait   ; on en attend une.
.18c2	20 cb 18	          jsr kbfree ; Clavier relache.
.18c5	20 9e 18	          jsr clrkbbuf
.18c8	68		          pla
.18c9	28		          plp
.18ca	60		          rts
.18cb			kbfree
.18cb	08		        php
.18cc	48		        pha
.18cd	a5 cb		wait    lda 203    ; lit la matrice
.18cf	c9 40		        cmp #64    ; 64 = aucune clef
.18d1	d0 fa		        bne wait   ; attend la relache
.18d3	68		        pla
.18d4	28		        plp
.18d5	60		        rts
.18d6			getkey
.18d6	08		        php
.18d7	20 e1 ff	        jsr $ffe1
.18da	20 f5 f1	try     jsr getin  ;tente de lire
.18dd	c9 00		        cmp #0     ; 0 si aucune.
.18df	f0 f9		        beq try    ; on reessaye
.18e1	28		        plp
.18e2	60		        rts
.18e3			waitkey
.18e3	08		        php
.18e4	48		        pha
.18e5	8d 89 0f	        sta clef   ;Sauve clef voulue
.18e8	20 9e 18	        jsr clrkbbuf
.18eb	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.18ee	cd 89 0f	        cmp clef   ;Compare avec clef
.18f1	d0 f8		        bne wait   ;Pas la bonne.
.18f3	68		        pla
.18f4	28		        plp
.18f5	60		        rts
.18f6			waitspace
.18f6	a9 20		          lda #$20
.18f8	20 e3 18	          jsr waitkey
.18fb	20 9e 18	          jsr clrkbbuf
.18fe	60		          rts
.18ff			showkey
.18ff	20 af 13	        jsr pushregs
.1902	38		        sec
.1903	20 0a e5	        jsr plot
.1906	8e 8b 0f	        stx curx
.1909	8c 8a 0f	        sty cury
.190c	20 af 13	        jsr pushregs
.190f	a0 00		        ldy #0
.1911	a2 16		        ldx #22
.1913	18		        clc
.1914	20 0a e5	        jsr plot
.1917	20 dc 13	        jsr popregs
.191a	20 7a f2	        jsr chrout
.191d	20 d1 17	        jsr showra
.1920	18		        clc
.1921	ac 8a 0f	        ldy cury
.1924	ae 8b 0f	        ldx curx
.1927	20 0a e5	        jsr plot
.192a	20 dc 13	        jsr popregs
.192d	60		        rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-screen.asm

.192e			scrnsave
.192e	20 3d 13	        jsr pushall
.1931	20 86 19	        jsr setcarptr
.1934	20 54 19	        jsr zp1tozp2
.1937	20 9d 19	        jsr setcolptr
.193a	20 54 19	        jsr zp1tozp2
.193d	20 76 13	        jsr popall
.1940	60		        rts
.1941			scrnrest
.1941	20 3d 13	        jsr pushall
.1944	20 86 19	        jsr setcarptr
.1947	20 6d 19	        jsr zp2tozp1
.194a	20 9d 19	        jsr setcolptr
.194d	20 6d 19	        jsr zp2tozp1
.1950	20 76 13	        jsr popall
.1953	60		        rts
.1954			zp1tozp2
.1954	20 3d 13	        jsr pushall
.1957	a2 02		        ldx #>scrlen
.1959	a0 00		        ldy #<scrlen
.195b	b1 fb		nextcar lda (zp1),y
.195d	91 fd		        sta (zp2),y
.195f	c8		        iny
.1960	d0 f9		        bne nextcar
.1962	e6 fc		        inc zp1+1
.1964	e6 fe		        inc zp2+1
.1966	ca		        dex
.1967	d0 f2		        bne nextcar
.1969	20 76 13	        jsr popall
.196c	60		        rts
.196d			zp2tozp1
.196d	20 3d 13	        jsr pushall
.1970	a2 02		        ldx #>scrlen
.1972	a0 00		        ldy #<scrlen
.1974	b1 fd		nextcar lda (zp2),y
.1976	91 fb		        sta (zp1),y
.1978	c8		        iny
.1979	d0 f9		        bne nextcar
.197b	e6 fc		        inc zp1+1
.197d	e6 fe		        inc zp2+1
.197f	ca		        dex
.1980	d0 f2		        bne nextcar
.1982	20 76 13	        jsr popall
.1985	60		        rts
.1986			setcarptr
.1986	20 af 13	        jsr pushregs
.1989	a9 00		        lda #<scrtxt
.198b	85 fb		        sta zp1
.198d	a9 10		        lda #>scrtxt
.198f	85 fc		        sta zp1+1
.1991	a9 82		        lda #<scrncar
.1993	85 fd		        sta zp2
.1995	a9 0d		        lda #>scrncar
.1997	85 fe		        sta zp2+1
.1999	20 dc 13	        jsr popregs
.199c	60		        rts
.199d			setcolptr
.199d	20 af 13	        jsr pushregs
.19a0	a9 00		        lda #<scrcol
.19a2	85 fb		        sta zp1
.19a4	a9 94		        lda #>scrcol
.19a6	85 fc		        sta zp1+1
.19a8	a9 82		        lda #<scrncol
.19aa	85 fd		        sta zp2
.19ac	a9 0b		        lda #>scrncol
.19ae	85 fe		        sta zp2+1
.19b0	20 dc 13	        jsr popregs
.19b3	60		        rts
.19b4			fillscreen
.19b4	20 3d 13	          jsr pushall
.19b7	a2 03		          ldx #$03
.19b9	a0 00		          ldy #$00
.19bb	a9 66		          lda #102
.19bd	99 00 10	again     sta scrtxt,y
.19c0	99 00 11	          sta scrtxt+256,y
.19c3	48		          pha
.19c4	8a		          txa
.19c5	99 00 94	          sta scrcol,y
.19c8	99 00 95	          sta scrcol+256,y
.19cb	68		          pla
.19cc	c8		          iny
.19cd	d0 ee		          bne again
.19cf	20 76 13	          jsr popall
.19d2	60		          rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-showregs.asm

.19d3			showregs
.19d3	20 2e 19	          jsr scrnsave
.19d6	08		          php
.19d7	8d fb 1a	          sta  ar
.19da	68		          pla       ;acc<-sr
.19db	8d fe 1a	          sta  sr
.19de	8e fc 1a	          stx  xr
.19e1	8c fd 1a	          sty  yr
.19e4	ba		          tsx       ; x<-sp
.19e5	8e ff 1a	          stx  sp
.19e8	68		          pla
.19e9	8d 00 1b	          sta  thispcl
.19ec	68		          pla
.19ed	8d 01 1b	          sta  thispch
.19f0	48		          pha
.19f1	ad 00 1b	          lda  thispcl
.19f4	48		          pha
.19f5	a9 00		          lda #$00
.19f7	a2 09		          ldx #regline   ; No. de ligne
.19f9	a8		          tay
.19fa	18		          clc
.19fb	20 0a e5	          jsr plot       ; pos. curseur.
.19fe	08		            php
.19ff	48		            pha
.1a00	a9 90		            lda #snoir
.1a02	20 7a f2	            jsr chrout
.1a05	68		            pla
.1a06	28		            plp
.1a07	20 af 13	          jsr  pushregs
.1a0a	a9 b0		          lda #176
.1a0c	8d d1 12	          sta rtitle+0
.1a0f	a9 ae		          lda #174
.1a11	8d e9 12	          sta rtitle+24
.1a14	a2 d1		          ldx  #<rtitle
.1a16	a0 12		          ldy  #>rtitle
.1a18	20 1f 14	          jsr  putsyx
.1a1b	20 dc 13	          jsr  popregs
.1a1e	20 af 13	          jsr  pushregs
.1a21	a9 dd		          lda #221
.1a23	8d ec 12	          sta rlable+0
.1a26	a9 dd		          lda #221
.1a28	8d 04 13	          sta rlable+24
.1a2b	a2 ec		          ldx  #<rlable
.1a2d	a0 12		          ldy  #>rlable
.1a2f	20 1f 14	          jsr  putsyx
.1a32	20 dc 13	          jsr  popregs
.1a35	20 af 13	          jsr  pushregs
.1a38	a9 dd		          lda #221
.1a3a	8d 07 13	          sta rvalues+0
.1a3d	a9 dd		          lda #221
.1a3f	8d 1f 13	          sta rvalues+24
.1a42	a2 07		          ldx  #<rvalues
.1a44	a0 13		          ldy  #>rvalues
.1a46	20 1f 14	          jsr  putsyx
.1a49	20 dc 13	          jsr  popregs
.1a4c	20 af 13	          jsr  pushregs
.1a4f	a9 ad		          lda #173
.1a51	8d 22 13	          sta rbline+0
.1a54	a9 bd		          lda #189
.1a56	8d 3a 13	          sta rbline+24
.1a59	a2 22		          ldx  #<rbline
.1a5b	a0 13		          ldy  #>rbline
.1a5d	20 1f 14	          jsr  putsyx
.1a60	20 dc 13	          jsr  popregs
.1a63	ac 01 1b	          ldy  thispch
.1a66	ae 00 1b	          ldx  thispcl
.1a69	e8		          inx       ; Aj. LSB adresse
.1a6a	90 01		          bcc  go   ; Report? Non Go!
.1a6c	c8		          iny       ; Oui, Aj. MSB
.1a6d			go
.1a6d	20 af 13	        jsr pushregs
.1a70	a0 01		        ldy #1
.1a72	a2 0b		        ldx #regline+2
.1a74	18		        clc
.1a75	20 0a e5	        jsr plot
.1a78	20 dc 13	        jsr popregs
.1a7b	20 49 16	          jsr putyxhex   ; pc
.1a7e	ad fb 1a	          lda  ar
.1a81	20 af 13	        jsr pushregs
.1a84	a0 06		        ldy #6
.1a86	a2 0b		        ldx #regline+2
.1a88	18		        clc
.1a89	20 0a e5	        jsr plot
.1a8c	20 dc 13	        jsr popregs
.1a8f	20 6d 16	          jsr putahex    ; reg x
.1a92	ad fc 1a	          lda  xr
.1a95	20 af 13	        jsr pushregs
.1a98	a0 09		        ldy #9
.1a9a	a2 0b		        ldx #regline+2
.1a9c	18		        clc
.1a9d	20 0a e5	        jsr plot
.1aa0	20 dc 13	        jsr popregs
.1aa3	20 6d 16	          jsr  putahex    ; reg x
.1aa6	ad fd 1a	          lda  yr
.1aa9	20 af 13	        jsr pushregs
.1aac	a0 0c		        ldy #12
.1aae	a2 0b		        ldx #regline+2
.1ab0	18		        clc
.1ab1	20 0a e5	        jsr plot
.1ab4	20 dc 13	        jsr popregs
.1ab7	20 6d 16	          jsr  putahex    ; reg y
.1aba	ad fe 1a	          lda  sr
.1abd	20 af 13	        jsr pushregs
.1ac0	a0 0f		        ldy #15
.1ac2	a2 0b		        ldx #regline+2
.1ac4	18		        clc
.1ac5	20 0a e5	        jsr plot
.1ac8	20 dc 13	        jsr popregs
.1acb	20 6d 16	          jsr putahex    ; status reg
.1ace	ad ff 1a	          lda  sp
.1ad1	8a		          txa
.1ad2	20 af 13	        jsr pushregs
.1ad5	a0 12		        ldy #18
.1ad7	a2 0b		        ldx #regline+2
.1ad9	18		        clc
.1ada	20 0a e5	        jsr plot
.1add	20 dc 13	        jsr popregs
.1ae0	20 6d 16	          jsr putahex    ; sp
.1ae3	20 9e 18	          jsr  clrkbbuf
.1ae6	20 b7 18	          jsr  anykey
.1ae9	20 41 19	          jsr scrnrest
.1aec	ad fb 1a	          lda  ar
.1aef	ae fc 1a	          ldx  xr
.1af2	ac fd 1a	          ldy  yr
.1af5	ad fe 1a	          lda  sr
.1af8	48		          pha
.1af9	28		          plp
.1afa	60		          rts
=9			regline   = 9
>1afb	00		ar        .byte     0
>1afc	00		xr        .byte     0
>1afd	00		yr        .byte     0
>1afe	00		sr        .byte     0
>1aff	00		sp        .byte     0
>1b00	00		thispcl       .byte     0
>1b01	00		thispch       .byte     0
.1b02			showstack
.1b02	8d 4e 1b	          sta ra
.1b05	08		          php
.1b06	68		          pla
.1b07	8d 4d 1b	          sta sr
.1b0a	8e 4f 1b	          stx rx
.1b0d	8c 50 1b	          sty ry
.1b10	38		          sec
.1b11	a0 10		          ldy  #$10
.1b13	ba		          tsx
.1b14	e8		          inx
.1b15	8a		          txa
.1b16	20 d1 17	          jsr showra
.1b19	08		            php
.1b1a	48		            pha
.1b1b	a9 0d		            lda #13
.1b1d	20 7a f2	            jsr chrout
.1b20	68		            pla
.1b21	28		            plp
.1b22	08		            php
.1b23	48		            pha
.1b24	a9 0d		            lda #13
.1b26	20 7a f2	            jsr chrout
.1b29	68		            pla
.1b2a	28		            plp
.1b2b	bd 00 01	morey     lda $0100,x
.1b2e	20 d1 17	          jsr showra
.1b31	08		            php
.1b32	48		            pha
.1b33	a9 0d		            lda #13
.1b35	20 7a f2	            jsr chrout
.1b38	68		            pla
.1b39	28		            plp
.1b3a	e8		          inx
.1b3b	88		          dey
.1b3c	d0 ed		          bne morey
.1b3e	ad 4d 1b	          lda sr
.1b41	48		          pha
.1b42	ad 4e 1b	          lda ra
.1b45	ae 4f 1b	          ldx rx
.1b48	ac 50 1b	          ldy ry
.1b4b	28		          plp
.1b4c	60		          rts
>1b4d	00		sr        .byte 0
>1b4e	00		ra        .byte 0
>1b4f	00		rx        .byte 0
>1b50	00		ry        .byte 0

;******  Return to file: dlbug20.asm

>1b51	34 12		prgend    .word $1234

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			ffac1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			ffac1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; f1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; f1=atn(f1).

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100   ;region conv FP a ascii
=$0286			kcol      = $0286   ;Couleur car affiche.
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$9000			vic       = $9000
=$9110			via1      = $9110   ;cia1 base address
=$dd00			via2      = $dd00   ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=			kcint       =   cint        ;   , init vic + ecran.
=			kioinit     =   ioinit      ;   , init i/o dev.
=			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.1b53	4c 46 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=$0400			blk0s   = $0400
=$0fff			blk0e   = $0fff
=$2000			blk1s   = $2000
=$3fff			blk1e   = $3fff
=$4000			blk2s   = $4000
=$5fff			blk2e   = $5fff
=$6400			blk3s   = $6400
=$7fff			blk3e   = $7fff
=$a000			blk5s   = $a000
=$bfff			blk5e   = $bfff
=$0fff			libre    = blk0e   ; *+3085
=4094			rp       = libre-$01     ;    1 byte
=4093			ra       = rp-1          ;    1 byte
=4092			rx       = ra-1          ;    1 byte
=4091			ry       = rx-1          ;    1 byte
=4090			rs       = ry-1          ;    1 byte
=4088			pc       = rs-2          ;    2 bytes
=4087			curcol   = pc-1          ;    1 byte
=4085			memptr   = curcol-2      ;    2 bytes
=4083			src      = memptr-2      ;    2 bytes
=4081			dst      = src-2         ;    2 bytes
=4079			loopcount = dst-2        ;    2 bytes
=4079			hexv     = loopcount
=4074			hexstr   = hexv-$05      ;    5 bytes
=4073			a2hexpfx = hexv-$06      ;    1 byte
=4072			a2hexpy  = hexv-$07      ;    1 byte
=4071			a2hexpx  = hexv-$08      ;    1 byte
=4071			a2hexpos = hexv-$08      ;    0 byte
=4070			a2hexcol = hexv-$09      ;    1 byte
=4070			binv     = a2hexcol
=4061			binstr   = binv-$09      ;    9 bytes
=4060			a2binpfx = binv-$0a      ;    1 byte
=4059			a2binpy  = binv-$0b      ;    1 byte
=4058			a2binpx  = binv-$0c      ;    1 byte
=4058			a2binpos = binv-$0c      ;    0 byte
=4057			a2bincol = binv-$0d      ;    1 byte
=4057			decv     = a2bincol
=4051			decstr   = decv-$06      ;    6 bytes
=4050			a2decpfx = decv-$07      ;    1 byte
=4049			a2decpy  = decv-$08      ;    1 byte
=4048			a2decpx  = decv-$09      ;    1 byte
=4048			a2decpos = decv-$09      ;    0 byte
=4047			a2deccol = decv-$0a      ;    1 byte
=4046			offset   = decv-$0b      ;    1 byte
=4046			fltv     = offset        ;
=4040			fvar1    = fltv-6        ;    6 bytes
=4034			fvar2    = fltv-12       ;    6 bytes
=4014			float1   = fltv-32       ;   20 bytes
=3994			float2   = fltv-52       ;   20 bytes
=3993			tval1    = fltv-53       ;    1 byte
=3991			tval2    = fltv-55       ;    2 bytes
=3989			reponse  = tval2-2       ;    2 byte
=3989			edbox    = reponse
=3988			cleft    = edbox-1       ;    1 byte
=3987			cright   = edbox-2       ;    1 byte
=3986			cmid     = edbox-3       ;    1 byte
=3985			dbtop    = edbox-4       ;    1 byte
=3984			dbleft   = edbox-5       ;    1 byte
=3983			dbwdth   = edbox-6       ;    1 byte
=3982			dbhght   = edbox-7       ;    1 byte
=3981			dbcoul   = edbox-8       ;    1 byte
=3980			dbclin   = edbox-9       ;    1 byte
=3979			curx     = dbclin-1      ;    1 byte
=3978			cury     = dbclin-2      ;    1 byte
=3977			clef     = dbclin-3      ;    1 byte
=3976			len      = clef-1        ;    1 byte
=3975			cx       = clef-2        ;    1 byte
=3974			cy       = clef-3        ;    1 byte
=3973			bcol     = clef-4        ;    1 byte
=3973			escr     = bcol          ; 2051 bytes
=3972			loops    = escr-1        ;    1 byte
=3970			loop16   = loops-2       ;    2 byte
=3458			scrncar  = loop16-$200   ;  512 byte
=2946			scrncol  = scrncar-$200  ;  512 byte
=2946			diskvar  = scrncol
=2944			ddatas   = diskvar-2 ;2 byte
=2942			ddatae   = diskvar-4 ;2 byte
=2941			ddev     = diskvar-5 ;1 byte
=2940			dlfsno   = diskvar-6 ;1 byte
=2938			dfnptr   = diskvar-8 ;2 byte
=2937			dfnlen   = diskvar-9 ;1 byte
=2936			genbyte1 = dfnlen-1 ; 1 byte
=2934			genword1 = dfnlen-3 ; 2 byte
=2933			freevar  = genword1-1 ;1 byte

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vic.asm

=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vicbas    = $900a;NRRRRRRR
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vicalt    = $900b;OSSSSSSS
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vicsop    = $900c;PTTTTTTT
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vicnoi    = $900d;QUUUUUUU
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vicvol    = $900e;WWWWVVVV
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0d			vvertp  =   %00001101
=$0e			vbleu1  =   %00001110
=$0e			vbleup  =   %00001110
=$0f			vgris2  =   %00001111
=$08			vinv      = vorange
=133			v1do1     =    133  ; 32.703-  32.746- 0.131 %
=140			v1dod1    =    140  ; 34.648-  34.739- 0.264 %
=146			v1re1     =    146  ; 36.708-  36.651- 0.155 %
=152			v1red1    =    152  ; 38.891-  38.786- 0.269 %
=158			v1mi1     =    158  ; 41.203-  41.186- 0.043 %
=163			v1fa1     =    163  ; 43.654-  43.424- 0.526 %
=169			v1fad1    =    169  ; 46.249-  46.453- 0.442 %
=173			v1so1     =    173  ; 48.999-  48.720- 0.571 %
=178			v1so1d    =    178  ; 51.913-  51.883- 0.058 %
=182			v1la1     =    182  ; 55.000-  54.726- 0.498 %
=186			v1lad1    =    186  ; 58.270-  57.899- 0.638 %
=190			v1si1     =    190  ; 61.735-  61.462- 0.444 %
=194			v1do2     =    194  ; 65.406-  65.492- 0.131 %
=197			v1dod2    =    197  ; 69.296-  69.478- 0.264 %
=201			v1re2     =    201  ; 73.416-  73.303- 0.155 %
=204			v1red2    =    204  ; 77.782-  77.573- 0.269 %
=207			v1mi2     =    207  ; 82.407-  82.371- 0.043 %
=209			v1fa2     =    209  ; 87.307-  86.848- 0.526 %
=212			v1fad2    =    212  ; 92.499-  92.907- 0.442 %
=214			v1so2     =    214  ; 97.999-  97.439- 0.571 %
=217			v1so2d    =    217  ;103.826- 103.766- 0.058 %
=219			v1la2     =    219  ;110.000- 109.452- 0.498 %
=221			v1lad2    =    221  ;116.541- 115.797- 0.638 %
=223			v1si2     =    223  ;123.471- 122.923- 0.444 %
=224			v1do3     =    224  ;130.813- 130.984- 0.131 %
=226			v1dod3    =    226  ;138.591- 138.957- 0.264 %
=228			v1re3     =    228  ;146.832- 146.606- 0.155 %
=229			v1red3    =    229  ;155.563- 155.146- 0.269 %
=231			v1mi3     =    231  ;164.814- 164.742- 0.043 %
=232			v1fa3     =    232  ;174.614- 173.696- 0.526 %
=233			v1fad3    =    233  ;184.997- 185.814- 0.442 %
=235			v1so3     =    235  ;195.998- 194.878- 0.571 %
=236			v1sod3    =    236  ;207.652- 207.532- 0.058 %
=237			v1la3     =    237  ;220.000- 218.904- 0.498 %
=238			v1lad3    =    238  ;233.082- 231.594- 0.638 %
=239			v1si3     =    239  ;246.942- 245.846- 0.444 %
=240			v1do4     =    240  ;261.626- 261.967- 0.131 %
=0			v1dod4    =      0  ;277.183- 275.517- 0.601 %
=0			v1re4     =      0  ;293.665- 295.926- 0.770 %
=242			v1red4    =    242  ;311.127- 313.333- 0.709 %
=243			v1mi4     =    243  ;329.628- 332.917- 0.998 %
=0			v1fa4     =      0  ;349.228- 347.391- 0.526 %
=244			v1fad4    =    244  ;369.994- 371.628- 0.442 %
=245			v1so4     =    245  ;391.995- 389.756- 0.571 %
=0			v1sod4    =      0  ;415.305- 420.526- 1.257 %
=246			v1la4     =    246  ;440.000- 443.889- 0.884 %
=0			v1lad4    =      0  ;466.164- 470.000- 0.823 %
=247			v1si4     =    247  ;493.883- 499.375- 1.112 %
=0			v1do5     =      0  ;523.251- 515.484- 1.484 %
=0			v1dod5    =      0  ;554.365- 551.034- 0.601 %
=0			v1re5     =      0  ;587.329- 591.852- 0.770 %
=0			v1red5    =      0  ;622.254- 614.615- 1.228 %
=249			v1mi5     =    249  ;659.255- 665.833- 0.998 %
=0			v1fa5     =      0  ;698.456- 694.783- 0.526 %
=0			v1fad5    =      0  ;739.989- 726.364- 1.841 %
=250			v1so5     =    250  ;783.991- 799.000- 1.914 %
=0			v1sod5    =      0  ;830.609- 841.053- 1.257 %
=0			v1la5     =      0  ;880.000- 887.778- 0.884 %
=0			v1lad5    =      0  ;932.327- 940.000- 0.823 %
=133			v2do2     =    133  ; 65.406-  65.492- 0.131 %
=140			v2dod2    =    140  ; 69.296-  69.478- 0.264 %
=146			v2re2     =    146  ; 73.416-  73.303- 0.155 %
=152			v2red2    =    152  ; 77.782-  77.573- 0.269 %
=158			v2mi2     =    158  ; 82.407-  82.371- 0.043 %
=163			v2fa2     =    163  ; 87.307-  86.848- 0.526 %
=169			v2fad2    =    169  ; 92.499-  92.907- 0.442 %
=173			v2so2     =    173  ; 97.999-  97.439- 0.571 %
=178			v2sod2    =    178  ;103.826- 103.766- 0.058 %
=182			v2la2     =    182  ;110.000- 109.452- 0.498 %
=186			v2lad2    =    186  ;116.541- 115.797- 0.638 %
=190			v2si2     =    190  ;123.471- 122.923- 0.444 %
=194			v2do3     =    194  ;130.813- 130.984- 0.131 %
=197			v2dod3    =    197  ;138.591- 138.957- 0.264 %
=201			v2re3     =    201  ;146.832- 146.606- 0.155 %
=204			v2red3    =    204  ;155.563- 155.146- 0.269 %
=207			v2mi3     =    207  ;164.814- 164.742- 0.043 %
=209			v2fa3     =    209  ;174.614- 173.696- 0.526 %
=212			v2fad3    =    212  ;184.997- 185.814- 0.442 %
=214			v2so3     =    214  ;195.998- 194.878- 0.571 %
=217			v2sod3    =    217  ;207.652- 207.532- 0.058 %
=219			v2la3     =    219  ;220.000- 218.904- 0.498 %
=221			v2lad3    =    221  ;233.082- 231.594- 0.638 %
=223			v2si3     =    223  ;246.942- 245.846- 0.444 %
=225			v2do4     =    225  ;261.626- 261.967- 0.131 %
=226			v2dod4    =    226  ;277.183- 275.517- 0.601 %
=228			v2re4     =    228  ;293.665- 295.926- 0.770 %
=229			v2red4    =    229  ;311.127- 313.333- 0.709 %
=231			v2mi4     =    231  ;329.628- 332.917- 0.998 %
=232			v2fa4     =    232  ;349.228- 347.391- 0.526 %
=233			v2fad4    =    233  ;369.994- 371.628- 0.442 %
=235			v2so4     =    235  ;391.995- 389.756- 0.571 %
=236			v2sod4    =    236  ;415.305- 420.526- 1.257 %
=237			v2la4     =    237  ;440.000- 443.889- 0.884 %
=238			v2lad4    =    238  ;466.164- 470.000- 0.823 %
=239			v2si4     =    239  ;493.883- 499.375- 1.112 %
=240			v2do5     =    240  ;523.251- 515.484- 1.484 %
=0			v2dod5    =      0  ;554.365- 551.034- 0.601 %
=0			v2re5     =      0  ;587.329- 591.852- 0.770 %
=242			v2red5    =    242  ;622.254- 614.615- 1.228 %
=243			v2mi5     =    243  ;659.255- 665.833- 0.998 %
=0			v2fa5     =      0  ;698.456- 694.783- 0.526 %
=244			v2fad5    =    244  ;739.989- 726.364- 1.841 %
=245			v2so5     =    245  ;783.991- 799.000- 1.914 %
=0			v2sod5    =      0  ;830.609- 841.053- 1.257 %
=246			v2la5     =    246  ;880.000- 887.778- 0.884 %
=0			v2lad5    =      0  ;932.327- 940.000- 0.823 %
=133			v3do3     =    133  ;130.813- 130.984- 0.131 %
=140			v3dod3    =    140  ;138.591- 138.957- 0.264 %
=146			v3re3     =    146  ;146.832- 146.606- 0.155 %
=152			v3red3    =    152  ;155.563- 155.146- 0.269 %
=158			v3mi3     =    158  ;164.814- 164.742- 0.043 %
=163			v3fa3     =    163  ;174.614- 173.696- 0.526 %
=169			v3fad3    =    169  ;184.997- 185.814- 0.442 %
=173			v3so3     =    173  ;195.998- 194.878- 0.571 %
=178			v3sod3    =    178  ;207.652- 207.532- 0.058 %
=182			v3la3     =    182  ;220.000- 218.904- 0.498 %
=186			v3lad3    =    186  ;233.082- 231.594- 0.638 %
=190			v3si3     =    190  ;246.942- 245.846- 0.444 %
=194			v3do4     =    194  ;261.626- 261.967- 0.131 %
=197			v3dod4    =    197  ;277.183- 275.517- 0.601 %
=201			v3re4     =    201  ;293.665- 295.926- 0.770 %
=204			v3red4    =    204  ;311.127- 313.333- 0.709 %
=207			v3mi4     =    207  ;329.628- 332.917- 0.998 %
=209			v3fa4     =    209  ;349.228- 347.391- 0.526 %
=212			v3fad4    =    212  ;369.994- 371.628- 0.442 %
=214			v3so4     =    214  ;391.995- 389.756- 0.571 %
=217			v3sod4    =    217  ;415.305- 420.526- 1.257 %
=219			v3la4     =    219  ;440.000- 443.889- 0.884 %
=221			v3lad4    =    221  ;466.164- 470.000- 0.823 %
=223			v3si4     =    223  ;493.883- 499.375- 1.112 %
=224			v3do5     =    224  ;523.251- 515.484- 1.484 %
=226			v3dod5    =    226  ;554.365- 551.034- 0.601 %
=228			v3re5     =    228  ;587.329- 591.852- 0.770 %
=229			v3red5    =    229  ;622.254- 614.615- 1.228 %
=231			v3mi5     =    231  ;659.255- 665.833- 0.998 %
=232			v3fa5     =    232  ;698.456- 694.783- 0.526 %
=233			v3fad5    =    233  ;739.989- 726.364- 1.841 %
=235			v3so5     =    235  ;783.991- 799.000- 1.914 %
=236			v3sod5    =    236  ;830.609- 841.053- 1.257 %
=237			v3la5     =    237  ;880.000- 887.778- 0.884 %
=238			v3lad5    =    238  ;932.327- 940.000- 0.823 %

;******  Return to file: dlbug20.asm


;******  End of listing
