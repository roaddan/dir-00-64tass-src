
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L dlbug20.txt -o dlbug20.prg dlbug20.asm
; Fri Jan 30 00:45:11 2026

;Offset	;Hex		;Source

;******  Processing input file: dlbug20.asm

="20260123-101151a"	Version = "20260123-101151a"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

=$1000			scrtxt    = $1000
=$9400			scrcol    = $9400
=$0200			scrlen    = $0200
>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	20 34 36 32	         .text format("%5d", bhstart)
>120a	32
>120b	00		         .byte $00   ;fin de cmd basic.
>120c	00 00		bcmd2    .word $00   ;adresse de la pro-
.120e	20 1a 12	bhstart   jsr bhscrini
.1211	ea		          nop
.1212	ea		          nop
.1213	ea		          nop
.1214	ea		          nop
.1215	ea		          nop
.1216	20 46 12	basnold   jsr main
.1219	60		          rts
.121a			bhscrini
.121a	08		        php
.121b	48		        pha
.121c	a9 84		        lda #(128+4)
.121e	8d 00 90	        sta vic0
.1221	ad 0f 90	bord    lda $900f    ;place la couleur
.1224	29 08		        and #%00001000
.1226	09 e3		        ora #%11100011
.1228	8d 0f 90	        sta $900f
.122b	a9 00		text    lda #$00    ;place la couleur
.122d	8d 86 02	        sta $0286   ; du texte.
.1230	a9 93		        lda #$93    ;efface l'ecran par
.1232	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.1235	68		        pla
.1236	28		        plp
.1237	60		        rts
.1238			bhprint
.1238	a0 00		        ldy #$00
.123a	b1 fb		nextc   lda ($fb),y
.123c	f0 07		        beq end
.123e	c8		        iny
.123f	20 d2 ff	        jsr $ffd2
.1242	4c 3a 12	        jmp nextc
.1245	60		end     rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm


;******  Return to file: dlbug20.asm

.1246			main
.1246	08		            php
.1247	48		            pha
.1248	a9 1b		            lda #(vblanc*16+(vocean|8))
.124a	8d 0f 90	            sta  vic15
.124d	a9 06		            lda #vbleu
.124f	8d 86 02	            sta kcol
.1252	a9 93		            lda #147
.1254	20 d2 ff	            jsr $ffd2
.1257	68		            pla
.1258	28		            plp
.1259	08		            php
.125a	48		            pha
.125b	a9 0e		            lda #locase
.125d	20 7a f2	            jsr chrout
.1260	68		            pla
.1261	28		            plp
.1262	a9 07		          lda  #7
.1264	85 fe		          sta  $fe
.1266	a9 06		          lda  #6
.1268	85 fd		          sta  $fd
.126a	a9 05		          lda  #5
.126c	85 fc		          sta  $fc
.126e	a9 04		          lda  #4
.1270	85 fb		          sta  $fb
.1272	a9 01		          lda  #1
.1274	a2 02		          ldx  #2
.1276	a0 03		          ldy  #3
.1278	20 66 14	          jsr pushall
.127b	38		          sec
.127c	a0 10		          ldy  #$10
.127e	ba		          tsx
.127f	e8		          inx
.1280	8a		          txa
.1281	20 fa 18	          jsr showra
.1284	08		            php
.1285	48		            pha
.1286	a9 0d		            lda #13
.1288	20 7a f2	            jsr chrout
.128b	68		            pla
.128c	28		            plp
.128d	08		            php
.128e	48		            pha
.128f	a9 0d		            lda #13
.1291	20 7a f2	            jsr chrout
.1294	68		            pla
.1295	28		            plp
.1296	bd 00 01	morey     lda $0100,x
.1299	20 fa 18	          jsr showra
.129c	08		            php
.129d	48		            pha
.129e	a9 0d		            lda #13
.12a0	20 7a f2	            jsr chrout
.12a3	68		            pla
.12a4	28		            plp
.12a5	e8		          inx
.12a6	88		          dey
.12a7	d0 ed		          bne morey
.12a9	20 9f 14	          jsr popall
.12ac	20 b9 12	          jsr kmenu
.12af	08		            php
.12b0	48		            pha
.12b1	a9 1f		            lda #sbleu
.12b3	20 7a f2	            jsr chrout
.12b6	68		            pla
.12b7	28		            plp
.12b8	60		          rts
.12b9			kmenu
.12b9	20 d8 14	          jsr  pushregs  ; Sauvegarde les registres.
.12bc	20 ff 19	uneclef   jsr  getkey    ; Attend une clef.
.12bf	20 81 19	          jsr  putahexdec; Affiche .a en ascii, hexa, bin et dec.
.12c2	c9 51		          cmp  #$51 ;'Q' ; Est-ce la lettre 'Q'?
.12c4	d0 03		          bne  keyr      ; Non on en verifie une autre.
.12c6	4c d3 12	          jmp  out       ; Oui, on quitte la fonction
.12c9	c9 52		keyr      cmp  #$52 ;'R' ; Est-ce la lettre 'R'?
.12cb	d0 03		          bne  nextkey   ; Non on en verifie une autre.
.12cd	20 d7 12	          jsr  showregs  ; Oui, On affiche les registres.
.12d0	4c bc 12	nextkey   jmp  uneclef   ; On retourne chercher une autre clef.
.12d3	20 05 15	out       jsr  popregs   ; Récupère les rehgistres.
.12d6	60		          rts
.12d7			showregs
.12d7	20 d8 14	          jsr pushregs
.12da	ba		          tsx
.12db	8e f4 13	          stx  mysp
.12de	08		            php
.12df	48		            pha
.12e0	a9 0e		            lda #locase
.12e2	20 7a f2	            jsr chrout
.12e5	68		            pla
.12e6	28		            plp
.12e7	38		          sec
.12e8	20 0a e5	          jsr plot
.12eb	8e f5 13	          stx x
.12ee	8c f6 13	          sty y
.12f1	20 57 1a	          jsr scrnsave
.12f4	a9 00		          lda #$00
.12f6	aa		          tax
.12f7	a8		          tay
.12f8	18		          clc
.12f9	20 0a e5	          jsr plot
.12fc	08		            php
.12fd	48		            pha
.12fe	a9 90		            lda #snoir
.1300	20 7a f2	            jsr chrout
.1303	68		            pla
.1304	28		            plp
.1305	20 d8 14	          jsr  pushregs
.1308	a9 b0		          lda #176
.130a	8d fa 13	          sta rtitle+0
.130d	a9 ae		          lda #174
.130f	8d 12 14	          sta rtitle+24
.1312	a2 fa		          ldx  #<rtitle
.1314	a0 13		          ldy  #>rtitle
.1316	20 48 15	          jsr  putsyx
.1319	20 05 15	          jsr  popregs
.131c	20 d8 14	          jsr  pushregs
.131f	a9 dd		          lda #221
.1321	8d 15 14	          sta rlable+0
.1324	a9 dd		          lda #221
.1326	8d 2d 14	          sta rlable+24
.1329	a2 15		          ldx  #<rlable
.132b	a0 14		          ldy  #>rlable
.132d	20 48 15	          jsr  putsyx
.1330	20 05 15	          jsr  popregs
.1333	20 d8 14	          jsr  pushregs
.1336	a9 dd		          lda #221
.1338	8d 30 14	          sta rvalues+0
.133b	a9 dd		          lda #221
.133d	8d 48 14	          sta rvalues+24
.1340	a2 30		          ldx  #<rvalues
.1342	a0 14		          ldy  #>rvalues
.1344	20 48 15	          jsr  putsyx
.1347	20 05 15	          jsr  popregs
.134a	20 d8 14	          jsr  pushregs
.134d	a9 ad		          lda #173
.134f	8d 4b 14	          sta rbline+0
.1352	a9 bd		          lda #189
.1354	8d 63 14	          sta rbline+24
.1357	a2 4b		          ldx  #<rbline
.1359	a0 14		          ldy  #>rbline
.135b	20 48 15	          jsr  putsyx
.135e	20 05 15	          jsr  popregs
.1361	68		          pla
.1362	20 d8 14	        jsr pushregs
.1365	a0 0c		        ldy #12
.1367	a2 02		        ldx #2
.1369	18		        clc
.136a	20 0a e5	        jsr plot
.136d	20 05 15	        jsr popregs
.1370	20 96 17	          jsr putahex    ; ry
.1373	68		          pla
.1374	20 d8 14	        jsr pushregs
.1377	a0 09		        ldy #9
.1379	a2 02		        ldx #2
.137b	18		        clc
.137c	20 0a e5	        jsr plot
.137f	20 05 15	        jsr popregs
.1382	20 96 17	          jsr putahex    ; rx
.1385	68		          pla
.1386	20 d8 14	        jsr pushregs
.1389	a0 06		        ldy #6
.138b	a2 02		        ldx #2
.138d	18		        clc
.138e	20 0a e5	        jsr plot
.1391	20 05 15	        jsr popregs
.1394	20 96 17	          jsr putahex    ; ra
.1397	68		          pla
.1398	20 d8 14	        jsr pushregs
.139b	a0 0f		        ldy #15
.139d	a2 02		        ldx #2
.139f	18		        clc
.13a0	20 0a e5	        jsr plot
.13a3	20 05 15	        jsr popregs
.13a6	20 96 17	          jsr putahex    ; sr
.13a9	68		          pla
.13aa	aa		          tax
.13ab	68		          pla
.13ac	a8		          tay
.13ad	e8		          inx
.13ae	90 01		          bcc go
.13b0	c8		          iny
.13b1			go
.13b1	20 d8 14	        jsr pushregs
.13b4	a0 01		        ldy #1
.13b6	a2 02		        ldx #2
.13b8	18		        clc
.13b9	20 0a e5	        jsr plot
.13bc	20 05 15	        jsr popregs
.13bf	20 72 17	          jsr putyxhex   ; pc
.13c2	ae f4 13	          ldx mysp
.13c5	8a		          txa
.13c6	20 d8 14	        jsr pushregs
.13c9	a0 12		        ldy #18
.13cb	a2 02		        ldx #2
.13cd	18		        clc
.13ce	20 0a e5	        jsr plot
.13d1	20 05 15	        jsr popregs
.13d4	20 96 17	          jsr putahex    ; sp
.13d7	a9 5f		          lda #$5f  ; [ESC]
.13d9	20 0c 1a	          jsr waitkey
.13dc	20 c7 19	          jsr clrkbbuf
.13df	20 6a 1a	          jsr scrnrest
.13e2	18		          clc
.13e3	ae f5 13	          ldx  x
.13e6	ac f6 13	          ldy  y
.13e9	20 0a e5	          jsr  plot
.13ec	ae f4 13	          ldx  mysp
.13ef	9a		          txs
.13f0	20 05 15	          jsr  popregs
.13f3	60		          rts
>13f4	00		mysp           .byte     0
>13f5	00		x              .byte     0
>13f6	00		y              .byte     0

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			ffac1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			ffac1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; f1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; f1=atn(f1).

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=			kcint       =   cint        ;   , init vic + ecran.
=			kioinit     =   ioinit      ;   , init i/o dev.
=			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.13f7	4c 46 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: dlbug20.asm


;******  Processing file: string-fr.asm

>13fa	20 90 12	rtitle         .byte 32,snoir,revson        ;0-2
>13fd	20 c3 d0 d5	               .text " CPU REGISTERS HEX " ;3-23
>1401	20 d2 c5 c7 c9 d3 d4 c5 d2 d3 20 c8 c5 d8 20
>1410	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1414	00		               .byte 0
>1415	20 1f 92	rlable         .byte 32,sbleu,revsoff
>1418	20 d0 c3 20	               .text " PC  RA RX RY SR SP"
>141c	20 d2 c1 20 d2 d8 20 d2 d9 20 d3 d2 20 d3 d0
>142b	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>142f	00		               .byte 0
>1430	20 1c 92	rvalues         .byte 32,srouge,revsoff        ;0-2 - 0
>1433	30 30 30 30	               .text "0000 00 00 00 00 00" ;3-23
>1437	20 30 30 20 30 30 20 30 30 20 30 30 20 30 30
>1446	90 92 20 0d	               .byte snoir,revsoff,32,$0d    ;24-27
>144a	00		               .byte 0
>144b	20 90 92	rbline         .byte 32,snoir,revsoff        ;0-2
>144e	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;3-8   ;1
>1452	c0
>1453	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;9-13
>1457	c0
>1458	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;14-18
>145c	c0
>145d	c0 c0 c0 c0	               .byte 192,192,192,192         ;19-23
>1461	90 92 20 0d	               .byte snoir,revsoff,32,$0d    ;24-27
>1465	00		               .byte 0

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.1466			pushall
.1466	08		         php     ;s;rp,pcl,pch
.1467	8d fe 7f	         sta ra  ;sauve a
.146a	68		         pla     ;s:pcl,pch
.146b	8d ff 7f	         sta rp  ;sauve rp
.146e	68		         pla     ;s:pch
.146f	8d f9 7f	         sta pc  ;sauve pcl
.1472	68		         pla     ;s:
.1473	8d fa 7f	         sta pc+1;sauve pch
.1476	a5 fb		         lda $fb ;sauve fb
.1478	48		         pha     ;s:fb
.1479	a5 fc		         lda $fc ;sauve fc
.147b	48		         pha     ;s:fc,fb
.147c	a5 fd		         lda $fd ;sauve fd
.147e	48		         pha     ;s:fd,fc,fb
.147f	a5 fe		         lda $fe ;sauve fe
.1481	48		         pha     ;s:fe,fd,fc,fb
.1482	ad ff 7f	         lda rp  ;sauve rp
.1485	48		         pha     ;s:rp,fe,fd,fc,fb
.1486	ad fe 7f	         lda ra  ;sauve ra
.1489	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.148a	8a		         txa     ;sauve rx
.148b	48		         pha     ;s:rx,ra,rp,fe-fb
.148c	98		         tya     ;sauve y
.148d	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.148e	ad fa 7f	         lda pc+1;replace l'adresse
.1491	48		         pha     ;s:pch,ry,rx,ra,...
.1492	ad f9 7f	         lda pc  ; de retour.
.1495	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.1496	ad ff 7f	         lda rp  ;place les flags
.1499	48		         pha     ; sur le stack.
.149a	ad fe 7f	         lda ra  ;recupere ra
.149d	28		         plp     ;recupere les flags.
.149e	60		         rts
.149f			popall
.149f	08		         php     ;s:rp,pcl,pch,ry,rx,...
.14a0	8d fe 7f	         sta ra
.14a3	68		         pla     ;s:pcl,pch,ry,rx,...
.14a4	8d ff 7f	         sta rp  ;s:pch,ry,rx,ra,rp,...
.14a7	68		         pla
.14a8	8d f9 7f	         sta pc  ;sauve pcl
.14ab	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.14ac	8d fa 7f	         sta pc+1;sauve pch
.14af	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.14b0	a8		         tay     ;recupere ry
.14b1	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.14b2	aa		         tax     ;recupere rx
.14b3	68		         pla     ;s:rp,fe,fd,fc,fb
.14b4	8d fe 7f	         sta ra  ;recupere ra
.14b7	68		         pla     ;s:fe,fd,fc,fb
.14b8	8d ff 7f	         sta rp  ;recupere les flags.
.14bb	68		         pla     ;s:fd,fc,fb
.14bc	85 fe		         sta $fe ;reccupere fe
.14be	68		         pla     ;s:fc,fb
.14bf	85 fd		         sta $fd ;recupere fd
.14c1	68		         pla     ;s:fb
.14c2	85 fc		         sta $fc ;recupere fc
.14c4	68		         pla     ;s:
.14c5	85 fb		         sta $fb ;recupere fb
.14c7	ad fa 7f	         lda pc+1;replaace l'adresse de
.14ca	48		         pha     ;s:pch
.14cb	ad f9 7f	         lda pc  ;retour sur la pile
.14ce	48		         pha     ;s:pcl,pch
.14cf	ad ff 7f	         lda rp  ;recupere les flags
.14d2	48		         pha     ;s:rp,pcl,pch
.14d3	ad fe 7f	         lda ra  ;recupere ra
.14d6	28		         plp     ;s:pcl,pch
.14d7	60		         rts
.14d8			pushregs
.14d8	08		         php     ;s;rp,pcl,pch
.14d9	8d fe 7f	         sta ra  ; -- sauve a
.14dc	68		         pla     ;s:pcl,pch
.14dd	8d ff 7f	         sta rp  ; -- sauve rp
.14e0	68		         pla     ;s:pch
.14e1	8d f9 7f	         sta pc  ; -- sauve pcl
.14e4	68		         pla     ;s:
.14e5	8d fa 7f	         sta pc+1; -- sauve pch
.14e8	ad ff 7f	         lda rp  ; -- sauve rp
.14eb	48		         pha     ;s:rp
.14ec	ad fe 7f	         lda ra  ; -- sauve ra
.14ef	48		         pha     ;s:ra,rp
.14f0	8a		         txa     ; -- tfr rx
.14f1	48		         pha     ;s:rx,ra,rp
.14f2	98		         tya     ; -- tfr ry
.14f3	48		         pha     ;s:ry,rx,ra,rp
.14f4	ad fa 7f	         lda pc+1; -- replace l'adresse
.14f7	48		         pha     ;s:pch,ry,rx,ra,rp
.14f8	ad f9 7f	         lda pc  ; -- de retour.
.14fb	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.14fc	ad ff 7f	         lda rp  ; -- place les flags
.14ff	48		         pha     ;    sur le stack.
.1500	ad fe 7f	         lda ra  ; -- recupere ra
.1503	28		         plp     ; -- recupere flags.
.1504	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1505			popregs
.1505	08		         php
.1506	8d fe 7f	         sta ra
.1509	68		         pla
.150a	8d ff 7f	         sta rp
.150d	68		         pla     ;s:pch,ry,rx,ra,rp
.150e	8d f9 7f	         sta pc  ; -- sauve pcl
.1511	68		         pla     ;s:ry,rx,ra,rp
.1512	8d fa 7f	         sta pc+1; -- sauve pch
.1515	68		         pla     ;s:rx,ra,rp
.1516	a8		         tay     ;recupere ry
.1517	68		         pla     ;s:ra,rp
.1518	aa		         tax     ;recupere rx
.1519	68		         pla     ;s:rp
.151a	8d fe 7f	         sta ra  ;recupere ra
.151d	68		         pla     ;s:
.151e	8d ff 7f	         sta rp  ;recupere les flags.
.1521	ad fa 7f	         lda pc+1;replace l'adresse de
.1524	48		         pha     ;s:pch
.1525	ad f9 7f	         lda pc  ;retour sur la pile
.1528	48		         pha     ;s:pcl,pch
.1529	ad ff 7f	         lda rp  ;recupere les flags
.152c	48		         pha     ;s:rp,pcl,pch
.152d	ad fe 7f	         lda ra  ;recupere ra
.1530	28		         plp     ;s:pcl,pch
.1531	60		         rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.1532			puts
.1532	20 66 14	          jsr pushall
.1535	a0 00		          ldy #$00   ; y = offset
.1537	b1 fb		nextc     lda ($fb),y;lit un caractere
.1539	f0 09		          beq out    ;si 0 on sort
.153b	20 7a f2	          jsr chrout ;on l'affiche
.153e	20 7f 16	          jsr inczp1 ;pointe le prochain
.1541	4c 37 15	          jmp nextc  ; et l'affiche
.1544	20 9f 14	out       jsr popall
.1547	60		          rts
.1548			putsyx
.1548	20 66 14	          jsr pushall;sauve reg + zps
.154b	86 fb		          stx $fb    ;$yyxx dans
.154d	84 fc		          sty $fb+1  ; zp1
.154f	20 32 15	          jsr puts
.1552	20 9f 14	          jsr popall ;recup reg + zps
.1555	60		          rts
.1556			putsxy
.1556	20 66 14	        jsr pushall;sauve reg + zps
.1559	86 fb		        stx $fb    ;$yyxx dans
.155b	84 fc		        sty $fb+1  ; zp1
.155d	a0 00		        ldy #$00
.155f	b1 fb		        lda ($fb),y
.1561	aa		        tax
.1562	20 7f 16	        jsr inczp1
.1565	b1 fb		        lda ($fb),y
.1567	20 7f 16	        jsr inczp1
.156a	a8		        tay
.156b	20 c0 15	        jsr gotoxy
.156e	20 32 15	        jsr puts
.1571	20 9f 14	        jsr popall ;recup reg + zps
.1574	60		        rts
.1575			putsc
.1575	08		          php       ;flag sur stack
.1576	48		          pha       ;acc sur stack
.1577	48		          pha       ;sauvegarde acc
.1578	ad 86 02	          lda kcol  ;recup coul. carac.
.157b	8d f8 7f	          sta curcol; et la sauvegarde
.157e	68		          pla       ;recup. acc
.157f	8d 86 02	          sta kcol  ;place coul. voulue
.1582	20 32 15	          jsr puts  ;affiche la chaine
.1585	ad f8 7f	          lda curcol;recup coul. carac.
.1588	8d 86 02	          sta kcol  ; et la replace
.158b	68		          pla       ;recup acc
.158c	28		          plp       ;recup flag
.158d	60		          rts
.158e			putscyx
.158e	08		          php       ;sauve registres
.158f	48		          pha       ; ...
.1590	48		          pha       ;sauve acc
.1591	ad 86 02	          lda kcol  ;recup couleur carac.
.1594	8d f8 7f	          sta curcol; et sauvegarde
.1597	68		          pla       ;recup acc
.1598	8d 86 02	          sta kcol  ;place couleur carac.
.159b	20 48 15	          jsr putsyx;affiche la chaine
.159e	ad f8 7f	          lda curcol
.15a1	8d 86 02	          sta kcol
.15a4	68		          pla
.15a5	28		          plp
.15a6	60		          rts
.15a7			putscxy
.15a7	08		          php       ;sauve registres
.15a8	48		          pha       ; ...
.15a9	48		          pha       ;sauve acc
.15aa	ad 86 02	          lda kcol  ;recup couleur carac.
.15ad	8d f8 7f	          sta curcol; et sauvegarde
.15b0	68		          pla       ;recup acc
.15b1	8d 86 02	          sta kcol   ;place couleur carac.
.15b4	20 48 15	          jsr putsyx ;affiche la chaine
.15b7	ad f8 7f	          lda curcol
.15ba	8d 86 02	          sta kcol
.15bd	68		          pla
.15be	28		          plp
.15bf	60		          rts
.15c0			gotoxy
.15c0	20 d8 14	          jsr pushregs
.15c3	8a		          txa ; interchange x et y
.15c4	48		          pha ; ...
.15c5	98		          tya ; ...
.15c6	aa		          tax ; ...
.15c7	68		          pla ; ...
.15c8	a8		          tay ; ...
.15c9	c0 00		txlow     cpy #0
.15cb	10 02		          bpl txhigh
.15cd	a2 00		          ldx #0
.15cf	e0 19		txhigh    cpx #25
.15d1	30 02		          bmi tylow
.15d3	a2 18		          ldx #24
.15d5	c0 00		tylow     cpy #0
.15d7	10 02		          bpl tyhigh
.15d9	a0 00		          ldy #0
.15db	c0 28		tyhigh    cpy #40
.15dd	30 02		          bmi allok
.15df	a0 27		          ldy #39
.15e1	18		allok     clc
.15e2	20 0a e5	          jsr plot
.15e5	20 05 15	          jsr popregs
.15e8	60		          rts
.15e9			putnch
.15e9	20 d8 14	        jsr pushregs
.15ec	20 7a f2	again   jsr chrout
.15ef	ca		        dex
.15f0	d0 fa		        bne again
.15f2	20 05 15	        jsr popregs
.15f5	60		        rts
.15f6			strlen
.15f6	20 66 14	        jsr pushall
.15f9	84 fc		        sty zp1+1
.15fb	86 fb		        stx zp1
.15fd	a0 00		        ldy #$00
.15ff	8c 8a 7f	        sty len
.1602	b1 fb		next    lda (zp1),y
.1604	f0 07		        beq out
.1606	ee 8a 7f	        inc len
.1609	c8		        iny
.160a	4c 02 16	        jmp next
.160d	20 9f 14	out     jsr popall
.1610	ad 8a 7f	        lda len
.1613	60		        rts
.1614			cursor
.1614	20 d8 14	          jsr  pushregs
.1617	90 12		          bcc  get    ;C=0 récupération.
.1619	20 0a e5	          jsr  plot  ;récupère position
.161c	8c 89 7f	          sty  cx     ;curseur et sauve
.161f	8e 88 7f	          stx  cy     ;dans vars locales.
.1622	ad 86 02	          lda  kcol   ;Sauve couleur
.1625	8d 87 7f	          sta  bcol   ; BASIC du texte.
.1628	4c 3a 16	          jmp  out    ;Fini on sort.
.162b	ae 88 7f	get       ldx  cy     ;C=1, charge x
.162e	ac 89 7f	          ldy  cx     ; ligne, y col.
.1631	20 0a e5	          jsr  plot  ;Position curseur.
.1634	ad 87 7f	          lda  bcol   ;replace couleur
.1637	8d 86 02	          sta  kcol ; basic sauvegardé.
.163a	20 05 15	out       jsr  popregs
.163d	60		          rts
.163e			curget
.163e			cursave
.163e	08		          php
.163f	38		          sec
.1640	20 14 16	          jsr  cursor
.1643	28		          plp
.1644	60		          rts
.1645			curput
.1645			currest
.1645	08		          php
.1646	18		          clc
.1647	20 14 16	          jsr  cursor
.164a	28		          plp
.164b	60		          rts
.164c			isprnable
.164c	08		          php
.164d	c9 a0		          cmp  #160
.164f	b0 0b		          bcs  yes
.1651	c5 85		          cmp  133
.1653	b0 04		          bcs  no
.1655	c9 21		          cmp  #33
.1657	b0 03		          bcs  yes
.1659	28		no        plp
.165a	18		          clc
.165b	60		          rts
.165c	28		yes       plp
.165d	38		          sec
.165e	60		          rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.165f			blkfill
.165f	20 66 14	bf0     jsr pushall
.1662	84 fc		        sty zp1+1
.1664	a0 00		        ldy #$00
.1666	84 fb		        sty zp1
.1668	91 fb		bf1     sta (zp1),y
.166a	c8		        iny
.166b	d0 fb		        bne bf1
.166d	20 9f 14	        jsr popall
.1670	60		        rts
.1671			memfill
.1671	20 d8 14	        jsr pushregs
.1674	20 5f 16	mf1     jsr blkfill
.1677	c8		        iny
.1678	ca		        dex
.1679	d0 f9		        bne mf1
.167b	20 05 15	        jsr popregs
.167e	60		        rts
.167f			inczp1
.167f	08		         php
.1680	e6 fb		         inc zp1
.1682	d0 02		         bne repzp1
.1684	e6 fc		         inc zp1+1
.1686	28		repzp1   plp
.1687	60		         rts
.1688			inczp2
.1688	08		         php
.1689	e6 fd		         inc zp2
.168b	d0 02		         bne repzp2
.168d	e6 fe		         inc zp2+1
.168f	28		repzp2   plp
.1690	60		         rts
.1691			deczp1
.1691	08		         php
.1692	48		         pha
.1693	a5 fb		         lda zp1
.1695	d0 02		         bne noemp
.1697	c6 fc		         dec zp1+1
.1699	c6 fb		noemp    dec zp1
.169b	68		         pla
.169c	28		         plp
.169d	60		         rts
.169e			deczp2
.169e	08		         php
.169f	48		         pha
.16a0	a5 fd		         lda zp2
.16a2	d0 02		         bne noemp
.16a4	c6 fe		         dec zp2+1
.16a6	c6 fd		noemp    dec zp2
.16a8	68		         pla
.16a9	28		         plp
.16aa	60		         rts
.16ab			rolzp1
.16ab	08		        php
.16ac	48		        pha
.16ad	18		        clc
.16ae	a5 fb		        lda zp1
.16b0	2a		        rol
.16b1	85 fb		        sta zp1
.16b3	a5 fc		        lda zp1+1
.16b5	2a		        rol
.16b6	85 fc		        sta zp1+1
.16b8	68		        pla
.16b9	28		        plp
.16ba			rorzp1
.16ba	08		        php
.16bb	48		        pha
.16bc	18		        clc
.16bd	a5 fc		        lda zp1+1
.16bf	6a		        ror
.16c0	85 fc		        sta zp1+1
.16c2	a5 fb		        lda zp1
.16c4	6a		        ror
.16c5	85 fb		        sta zp1
.16c7	68		        pla
.16c8	28		        plp
.16c9			rolzp2
.16c9	08		        php
.16ca	48		        pha
.16cb	18		        clc
.16cc	a5 fd		        lda zp2
.16ce	2a		        rol
.16cf	85 fd		        sta zp2
.16d1	a5 fe		        lda zp2+1
.16d3	2a		        rol
.16d4	85 fe		        sta zp2+1
.16d6	68		        pla
.16d7	28		        plp
.16d8			rorzp2
.16d8	08		        php
.16d9	48		        pha
.16da	18		        clc
.16db	a5 fe		        lda zp2+1
.16dd	6a		        ror
.16de	85 fe		        sta zp2+1
.16e0	a5 fd		        lda zp2
.16e2	6a		        ror
.16e3	85 fd		        sta zp2
.16e5	68		        pla
.16e6	28		        plp
.16e7			yxtoptr
.16e7	8c f8 7f	        sty memptr+1
.16ea	8e f7 7f	        stx memptr
.16ed	60		        rts
.16ee			ptrtoyx
.16ee	08		        php
.16ef	ac f8 7f	        ldy memptr+1
.16f2	ae f7 7f	        ldx memptr
.16f5	28		        plp
.16f6	60		        rts
.16f7			incptr
.16f7	08		        php
.16f8	ee f7 7f	        inc memptr
.16fb	d0 03		        bne norep
.16fd	ee f8 7f	        inc memptr+1
.1700	28		norep   plp
.1701	60		        rts
.1702			decptr
.1702	08		        php
.1703	48		        pha
.1704	ad f7 7f	        lda memptr
.1707	d0 03		        bne noemp
.1709	ee f8 7f	        inc memptr+1
.170c	ee f7 7f	noemp   inc memptr
.170f	68		        pla
.1710	28		        plp
.1711	60		        rts
.1712			incptr8
.1712	08		        php
.1713	48		        pha
.1714	98		        tya
.1715	48		        pha
.1716	a0 08		        ldy #8
.1718	20 f7 16	again   jsr incptr
.171b	88		        dey
.171c	d0 fa		        bne again
.171e	68		        pla
.171f	a8		        tay
.1720	68		        pla
.1721	28		        plp
.1722	60		        rts
.1723			loop
.1723	ce f1 7f	               dec  loopcount
.1726	d0 03		               bne  norep
.1728	ce f2 7f	               dec  loopcount+1
.172b	ad f1 7f	norep          lda  loopcount
.172e	c9 00		               cmp  #$00
.1730	d0 05		               bne  out
.1732	4d f2 7f	               eor  loopcount+1
.1735	c9 ff		               cmp  #$ff
.1737	60		out            rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.1738			addtoword
.1738			addatoyx
.1738	08		        php
.1739	48		        pha
.173a	8c 98 7f	        sty reponse+1
.173d	8e 97 7f	        stx reponse
.1740	18		        clc
.1741	6d 97 7f	        adc reponse
.1744	90 03		        bcc norep
.1746	ee 98 7f	        inc reponse+1
.1749	8d 97 7f	norep   sta reponse
.174c	ac 98 7f	        ldy reponse+1
.174f	ae 97 7f	        ldx reponse
.1752	68		        pla
.1753	28		        plp
.1754	60		        rts
.1755			subtoword
.1755			subatoyx
.1755	08		        php
.1756	48		        pha
.1757	8c 98 7f	        sty reponse+1
.175a	8e 97 7f	        stx reponse
.175d	38		        sec
.175e	ed 97 7f	        sbc reponse
.1761	b0 03		        bcs noemp
.1763	ce 98 7f	        dec reponse+1
.1766	8d 97 7f	noemp   sta reponse
.1769	ac 98 7f	        ldy reponse+1
.176c	ae 97 7f	        ldx reponse
.176f	68		        pla
.1770	28		        plp
.1771	60		        rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.1772			putyxhex
.1772	20 66 14	        jsr pushall
.1775	98		        tya
.1776	48		        pha
.1777	20 f5 17	        jsr lsr4bits
.177a	20 08 18	        jsr nibtohex
.177d	8d ec 7f	        sta hexstr+0
.1780	68		        pla
.1781	20 08 18	        jsr nibtohex
.1784	8d ed 7f	        sta hexstr+1
.1787	8a		        txa
.1788	20 a7 17	        jsr atohex
.178b	a2 ec		        ldx #<hexstr+0
.178d	a0 7f		        ldy #>hexstr+0
.178f	20 48 15	        jsr putsyx
.1792	20 9f 14	        jsr popall
.1795	60		        rts
.1796			putahex
.1796	20 d8 14	        jsr pushregs
.1799	20 a7 17	        jsr atohex
.179c	a2 ee		        ldx #<hexstr+2
.179e	a0 7f		        ldy #>hexstr+2
.17a0	20 48 15	        jsr putsyx
.17a3	20 05 15	        jsr popregs
.17a6	60		        rts
.17a7			atohex
.17a7	08		        php
.17a8	48		        pha
.17a9	48		        pha
.17aa	20 f5 17	        jsr lsr4bits
.17ad	20 08 18	        jsr nibtohex
.17b0	8d ee 7f	        sta hexstr+2
.17b3	68		        pla
.17b4	20 08 18	        jsr nibtohex
.17b7	8d ef 7f	        sta hexstr+3
.17ba	a9 00		        lda #$00
.17bc	8d f0 7f	        sta hexstr+4
.17bf	68		        pla
.17c0	28		        plp
.17c1	60		        rts
.17c2			putabin
.17c2	20 d8 14	          jsr     pushregs
.17c5	20 d3 17	          jsr     atobin
.17c8	a2 df		          ldx     #<binstr
.17ca	a0 7f		          ldy     #>binstr
.17cc	20 48 15	          jsr     putsyx
.17cf	20 05 15	          jsr     popregs
.17d2	60		          rts
.17d3			atobin
.17d3	20 d8 14	          jsr  pushregs
.17d6	a2 08		          ldx  #8
.17d8	a0 00		          ldy  #0
.17da	18		          clc
.17db	2a		nextbit   rol
.17dc	48		          pha
.17dd	69 00		          adc  #$00
.17df	29 01		          and  #$01
.17e1	20 08 18	          jsr  nibtohex
.17e4	99 df 7f	          sta  binstr,y
.17e7	68		          pla
.17e8	c8		          iny
.17e9	ca		          dex
.17ea	d0 ef		          bne  nextbit
.17ec	a9 00		          lda  #0
.17ee	99 df 7f	          sta  binstr,y
.17f1	20 05 15	          jsr  popregs
.17f4	60		          rts
.17f5			lsr4bits
.17f5	08		          php
.17f6	4a		          lsr a
.17f7	4a		          lsr a
.17f8	4a		          lsr a
.17f9	4a		          lsr a
.17fa	28		          plp
.17fb	60		          rts
.17fc			nibtohexb
.17fc	08		        php
.17fd	29 0f		        and #$0f
.17ff	f8		        sed
.1800	18		        clc
.1801	69 90		        adc #$90
.1803	69 40		        adc #$40
.1805	d8		        cld
.1806	28		        plp
.1807	60		        rts
.1808			nibtohex
.1808	08		        php
.1809	8c 27 18	        sty myy
.180c	29 0f		        and #$0f
.180e	a8		        tay
.180f	b9 17 18	        lda hextbl,y
.1812	ac 27 18	        ldy myy
.1815	28		        plp
.1816	60		        rts
>1817	30 31 32 33	hextbl  .byte $30,$31,$32,$33,$34
>181b	34
>181c	35 36 37 38	        .byte $35,$36,$37,$38,$39
>1820	39
>1821	41 42 43 44	        .byte $41,$42,$43,$44,$45
>1825	45
>1826	46		        .byte $46
>1827	00		myy     .byte $00
.1828			bytestohex
.1828	20 66 14	        jsr pushall
.182b	84 fc		        sty zp1+1
.182d	86 fb		        stx zp1
.182f	08		            php
.1830	48		            pha
.1831	a9 20		            lda #32
.1833	20 7a f2	            jsr chrout
.1836	68		            pla
.1837	28		            plp
.1838	08		            php
.1839	48		            pha
.183a	a9 05		            lda #5
.183c	20 7a f2	            jsr chrout
.183f	68		            pla
.1840	28		            plp
.1841	08		            php
.1842	48		            pha
.1843	a9 24		            lda #36
.1845	20 7a f2	            jsr chrout
.1848	68		            pla
.1849	28		            plp
.184a	20 72 17	        jsr putyxhex   ; prn adreponsese
.184d	08		            php
.184e	48		            pha
.184f	a9 20		            lda #$20
.1851	20 7a f2	            jsr chrout
.1854	68		            pla
.1855	28		            plp
.1856	08		            php
.1857	48		            pha
.1858	a9 9f		            lda #159
.185a	20 7a f2	            jsr chrout
.185d	68		            pla
.185e	28		            plp
.185f	a0 00		        ldy #$00
.1861	aa		        tax
.1862	8c d0 7f	another sty offset
.1865	b1 fb		        lda (zp1),y
.1867	20 96 17	        jsr putahex
.186a	48		        pha
.186b	20 8a 18	        jsr petsciiaddr
.186e	68		        pla
.186f	8d 00 04	petscii sta $0400
.1872	48		        pha
.1873	a9 0d		        lda #$0d
.1875	8d 00 d8	petcol  sta $d800
.1878	68		        pla
.1879	08		            php
.187a	48		            pha
.187b	a9 20		            lda #$20
.187d	20 7a f2	            jsr chrout
.1880	68		            pla
.1881	28		            plp
.1882	c8		        iny
.1883	ca		        dex
.1884	d0 dc		        bne another
.1886	20 9f 14	        jsr popall
.1889	60		        rts
.188a			petsciiaddr
.188a	20 d8 14	        jsr pushregs
.188d	a9 1f		        lda #31
.188f	18		        clc
.1890	6d d0 7f	        adc offset
.1893	20 38 17	        jsr addatoyx
.1896	8c 71 18	        sty petscii+2
.1899	8e 70 18	        stx petscii+1
.189c	8e 76 18	        stx petcol+1
.189f	98		        tya
.18a0	29 fb		        and #%11111011 ;#%00000100
.18a2	09 d8		        ora #$d8
.18a4	8d 77 18	        sta petcol+2
.18a7	a8		        tay
.18a8	20 05 15	        jsr popregs
.18ab	60		        rts
.18ac			strhexval
.18ac	20 66 14	        jsr pushall ; sauve registre
.18af	84 fc		        sty zp1+1   ; ptr dans zp1
.18b1	86 fb		        stx zp1
.18b3	20 f6 15	        jsr strlen  ;len de $(yyxx)->a
.18b6	f0 3d		        beq oute    ; si 0 erreur C=1
.18b8	a0 00		        ldy #$00    ; offset a 0
.18ba	8c 98 7f	        sty reponse+1; reponse a zero
.18bd	8c 97 7f	        sty reponse ;    ...
.18c0	b1 fb		nextc   lda (zp1),y ;charge un caractere
.18c2	f0 26		        beq out     ;On  a fini
.18c4	c0 00		        cpy #$00    ;si c'est le premier
.18c6	f0 07		        beq norol   ; pas de rol
.18c8	48		        pha         ;
.18c9	a9 04		        lda #$04    ;rol de 4 pos
.18cb	20 b5 19	        jsr rolword ;
.18ce	68		        pla         ;
.18cf	09 20		norol   ora #%00100000
.18d1	38		        sec
.18d2	e9 30		        sbc #$30
.18d4	c9 0a		        cmp #$0a
.18d6	90 07		        bcc lt10
.18d8	38		        sec
.18d9	e9 27		        sbc #$27
.18db	c9 10		        cmp #$10
.18dd	b0 16		        bcs oute
.18df	0d 97 7f	lt10    ora reponse
.18e2	8d 97 7f	        sta reponse
.18e5	c8		        iny
.18e6	c0 04		        cpy #$04
.18e8	d0 d6		        bne nextc
.18ea	20 9f 14	out     jsr popall
.18ed	18		        clc          ;Carry 0 = good
.18ee	ac 98 7f	        ldy reponse+1
.18f1	ae 97 7f	        ldx reponse
.18f4	60		        rts
.18f5	20 9f 14	oute    jsr popall
.18f8	38		        sec
.18f9	60		        rts
.18fa			showra
.18fa	20 d8 14	          jsr  pushregs
.18fd	ac 86 02	          ldy  kcol
.1900	08		            php
.1901	48		            pha
.1902	a9 90		            lda #snoir
.1904	20 7a f2	            jsr chrout
.1907	68		            pla
.1908	28		            plp
.1909	20 4c 16	          jsr  isprnable
.190c	b0 13		          bcs  okprn
.190e	48		          pha
.190f	08		            php
.1910	48		            pha
.1911	a9 1c		            lda #srouge
.1913	20 7a f2	            jsr chrout
.1916	68		            pla
.1917	28		            plp
.1918	a9 2e		          lda  #'.'
.191a	20 7a f2	          jsr  chrout
.191d	68		          pla
.191e	4c 24 19	          jmp  noprn
.1921	20 7a f2	okprn     jsr  chrout
.1924			noprn
.1924	08		            php
.1925	48		            pha
.1926	a9 20		            lda #32
.1928	20 7a f2	            jsr chrout
.192b	68		            pla
.192c	28		            plp
.192d	08		            php
.192e	48		            pha
.192f	a9 1f		            lda #sbleu
.1931	20 7a f2	            jsr chrout
.1934	68		            pla
.1935	28		            plp
.1936	08		            php
.1937	48		            pha
.1938	a9 24		            lda #36
.193a	20 7a f2	            jsr chrout
.193d	68		            pla
.193e	28		            plp
.193f	20 96 17	          jsr putahex
.1942	08		            php
.1943	48		            pha
.1944	a9 20		            lda #32
.1946	20 7a f2	            jsr chrout
.1949	68		            pla
.194a	28		            plp
.194b	08		            php
.194c	48		            pha
.194d	a9 1c		            lda #srouge
.194f	20 7a f2	            jsr chrout
.1952	68		            pla
.1953	28		            plp
.1954	08		            php
.1955	48		            pha
.1956	a9 25		            lda #37
.1958	20 7a f2	            jsr chrout
.195b	68		            pla
.195c	28		            plp
.195d	20 c2 17	          jsr putabin
.1960	08		            php
.1961	48		            pha
.1962	a9 20		            lda #32
.1964	20 7a f2	            jsr chrout
.1967	68		            pla
.1968	28		            plp
.1969	08		            php
.196a	48		            pha
.196b	a9 9c		            lda #smauve
.196d	20 7a f2	            jsr chrout
.1970	68		            pla
.1971	28		            plp
.1972	48		          pha
.1973	aa		          tax
.1974	a9 00		          lda #$00
.1976	20 cd dd	          jsr fiaxtf1
.1979	68		          pla
.197a	8c 86 02	          sty kcol
.197d	20 05 15	          jsr popregs
.1980	60		          rts
.1981			putahexdec
.1981	20 d8 14	          jsr pushregs
.1984	20 3e 16	          jsr  curget    ; Sauvegarde la position du curseur.
.1987	20 d8 14	        jsr pushregs
.198a	a0 01		        ldy #1
.198c	a2 16		        ldx #22
.198e	18		        clc
.198f	20 0a e5	        jsr plot
.1992	20 05 15	        jsr popregs
.1995	08		            php
.1996	48		            pha
.1997	a9 20		            lda #32
.1999	20 7a f2	            jsr chrout
.199c	68		            pla
.199d	28		            plp
.199e	20 fa 18	          jsr  showra    ; Affiche .a en ascii, hexa, bin et dec.
.19a1	c9 63		          cmp  #99       ; Estce que le code ascii est > 99 dec.
.19a3	10 09		          bpl  nospc     ; Non, on saute.
.19a5	08		            php
.19a6	48		            pha
.19a7	a9 20		            lda #32
.19a9	20 7a f2	            jsr chrout
.19ac	68		            pla
.19ad	28		            plp
.19ae	20 45 16	nospc     jsr  curput    ; Replkace le curseur à sa position initiale.
.19b1	20 05 15	          jsr popregs
.19b4	60		          rts
.19b5			rolword
.19b5	20 d8 14	        jsr pushregs
.19b8	a8		        tay
.19b9	18		again   clc
.19ba	2e 97 7f	        rol reponse
.19bd	2e 98 7f	        rol reponse+1
.19c0	88		        dey
.19c1	d0 f6		        bne again
.19c3	20 05 15	        jsr popregs
.19c6	60		        rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.19c7			clrkbbuf
.19c7	08		          php
.19c8	48		          pha
.19c9	a9 00		          lda #0
.19cb	85 c6		          sta 198
.19cd	20 e1 ff	          jsr $ffe1
.19d0	68		          pla
.19d1	28		          plp
.19d2	60		          rts
.19d3			waitstop
.19d3	08		          php    ;\ sauve les flags
.19d4	48		          pha    ;/  et l'acc.
.19d5	20 c7 19	          jsr clrkbbuf
.19d8	20 70 f7	wait      jsr stop ; Veri [run/stop]
.19db	d0 fb		          bne wait ;loop pas pesee.
.19dd	68		          pla    ;\ recup. acc et
.19de	28		          plp    ;/  les flags.
.19df	60		          rts
.19e0			anykey
.19e0	08		          php
.19e1	48		          pha
.19e2	20 c7 19	          jsr clrkbbuf
.19e5	a5 cb		wait      lda 203    ;lit la matrice de
.19e7	c9 40		          cmp #64    ; 64 = aucune clef
.19e9	f0 fa		          beq wait   ; on en attend une.
.19eb	20 f4 19	          jsr kbfree ; Clavier relache.
.19ee	20 c7 19	          jsr clrkbbuf
.19f1	68		          pla
.19f2	28		          plp
.19f3	60		          rts
.19f4			kbfree
.19f4	08		        php
.19f5	48		        pha
.19f6	a5 cb		wait    lda 203    ; lit la matrice
.19f8	c9 40		        cmp #64    ; 64 = aucune clef
.19fa	d0 fa		        bne wait   ; attend la relache
.19fc	68		        pla
.19fd	28		        plp
.19fe	60		        rts
.19ff			getkey
.19ff	08		        php
.1a00	20 e1 ff	        jsr $ffe1
.1a03	20 f5 f1	try     jsr getin  ;tente de lire
.1a06	c9 00		        cmp #0     ; 0 si aucune.
.1a08	f0 f9		        beq try    ; on reessaye
.1a0a	28		        plp
.1a0b	60		        rts
.1a0c			waitkey
.1a0c	08		        php
.1a0d	48		        pha
.1a0e	8d 8b 7f	        sta clef   ;Sauve clef voulue
.1a11	20 c7 19	        jsr clrkbbuf
.1a14	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.1a17	cd 8b 7f	        cmp clef   ;Compare avec clef
.1a1a	d0 f8		        bne wait   ;Pas la bonne.
.1a1c	68		        pla
.1a1d	28		        plp
.1a1e	60		        rts
.1a1f			waitspace
.1a1f	a9 20		          lda #$20
.1a21	20 0c 1a	          jsr waitkey
.1a24	20 c7 19	          jsr clrkbbuf
.1a27	60		          rts
.1a28			showkey
.1a28	20 d8 14	        jsr pushregs
.1a2b	38		        sec
.1a2c	20 0a e5	        jsr plot
.1a2f	8e 8d 7f	        stx curx
.1a32	8c 8c 7f	        sty cury
.1a35	20 d8 14	        jsr pushregs
.1a38	a0 00		        ldy #0
.1a3a	a2 16		        ldx #22
.1a3c	18		        clc
.1a3d	20 0a e5	        jsr plot
.1a40	20 05 15	        jsr popregs
.1a43	20 7a f2	        jsr chrout
.1a46	20 fa 18	        jsr showra
.1a49	18		        clc
.1a4a	ac 8c 7f	        ldy cury
.1a4d	ae 8d 7f	        ldx curx
.1a50	20 0a e5	        jsr plot
.1a53	20 05 15	        jsr popregs
.1a56	60		        rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-screen.asm

.1a57			scrnsave
.1a57	20 66 14	        jsr pushall
.1a5a	20 af 1a	        jsr setcarptr
.1a5d	20 7d 1a	        jsr zp1tozp2
.1a60	20 c6 1a	        jsr setcolptr
.1a63	20 7d 1a	        jsr zp1tozp2
.1a66	20 9f 14	        jsr popall
.1a69	60		        rts
.1a6a			scrnrest
.1a6a	20 66 14	        jsr pushall
.1a6d	20 af 1a	        jsr setcarptr
.1a70	20 96 1a	        jsr zp2tozp1
.1a73	20 c6 1a	        jsr setcolptr
.1a76	20 96 1a	        jsr zp2tozp1
.1a79	20 9f 14	        jsr popall
.1a7c	60		        rts
.1a7d			zp1tozp2
.1a7d	20 66 14	        jsr pushall
.1a80	a2 02		        ldx #>scrlen
.1a82	a0 00		        ldy #<scrlen
.1a84	b1 fb		nextcar lda (zp1),y
.1a86	91 fd		        sta (zp2),y
.1a88	c8		        iny
.1a89	d0 f9		        bne nextcar
.1a8b	e6 fc		        inc zp1+1
.1a8d	e6 fe		        inc zp2+1
.1a8f	ca		        dex
.1a90	d0 f2		        bne nextcar
.1a92	20 9f 14	        jsr popall
.1a95	60		        rts
.1a96			zp2tozp1
.1a96	20 66 14	        jsr pushall
.1a99	a2 02		        ldx #>scrlen
.1a9b	a0 00		        ldy #<scrlen
.1a9d	b1 fd		nextcar lda (zp2),y
.1a9f	91 fb		        sta (zp1),y
.1aa1	c8		        iny
.1aa2	d0 f9		        bne nextcar
.1aa4	e6 fc		        inc zp1+1
.1aa6	e6 fe		        inc zp2+1
.1aa8	ca		        dex
.1aa9	d0 f2		        bne nextcar
.1aab	20 9f 14	        jsr popall
.1aae	60		        rts
.1aaf			setcarptr
.1aaf	20 d8 14	        jsr pushregs
.1ab2	a9 00		        lda #<scrtxt
.1ab4	85 fb		        sta zp1
.1ab6	a9 10		        lda #>scrtxt
.1ab8	85 fc		        sta zp1+1
.1aba	a9 84		        lda #<scrncar
.1abc	85 fd		        sta zp2
.1abe	a9 7d		        lda #>scrncar
.1ac0	85 fe		        sta zp2+1
.1ac2	20 05 15	        jsr popregs
.1ac5	60		        rts
.1ac6			setcolptr
.1ac6	20 d8 14	        jsr pushregs
.1ac9	a9 00		        lda #<scrcol
.1acb	85 fb		        sta zp1
.1acd	a9 94		        lda #>scrcol
.1acf	85 fc		        sta zp1+1
.1ad1	a9 84		        lda #<scrncol
.1ad3	85 fd		        sta zp2
.1ad5	a9 7b		        lda #>scrncol
.1ad7	85 fe		        sta zp2+1
.1ad9	20 05 15	        jsr popregs
.1adc	60		        rts
.1add			fillscreen
.1add	20 66 14	          jsr pushall
.1ae0	a2 03		          ldx #$03
.1ae2	a0 00		          ldy #$00
.1ae4	a9 66		          lda #102
.1ae6	99 00 10	again     sta scrtxt,y
.1ae9	99 00 11	          sta scrtxt+256,y
.1aec	48		          pha
.1aed	8a		          txa
.1aee	99 00 94	          sta scrcol,y
.1af1	99 00 95	          sta scrcol+256,y
.1af4	68		          pla
.1af5	c8		          iny
.1af6	d0 ee		          bne again
.1af8	20 9f 14	          jsr popall
.1afb	60		          rts

;******  Return to file: dlbug20.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=$8000			libre    = $8000   ; *+3085
=32767			rp       = libre-$01;1 byte $cfff
=32766			ra       = rp-1     ;1 byte $cffe
=32765			rx       = ra-1     ;1 byte $cffd
=32764			ry       = rx-1     ;1 byte $cffc
=32763			rs       = ry-1     ;1 byte $cffb
=32761			pc       = rs-2     ;2 byte $cff9-$cffa
=32760			curcol   = pc-1     ;1 byte $cff6
=32759			memptr   = curcol-1;1 word $cff7-$cff8
=32757			src      = memptr-2
=32755			dst      = memptr-4
=32753			loopcount = memptr-6
=32753			hexv     = loopcount
.1afc			a2hexstr
=32748			hexstr   = hexv-$05 ;5 byte
=32747			a2hexpfx = hexv-$06 ;1 byte
=32746			a2hexpy  = hexv-$07 ;1 byte
=32745			a2hexpx  = hexv-$08 ;1 byte
=32745			a2hexpos = hexv-$08 ;0 byte
=32744			a2hexcol = hexv-$09 ;1 byte
=32744			binv     = a2hexcol
=32735			binstr   = binv-$09 ;9 byte
=32734			a2binpfx = binv-$0a ;1 byte
=32733			a2binpy  = binv-$0b ;1 byte
=32732			a2binpx  = binv-$0c ;1 byte
=32732			a2binpos = binv-$0c ;0 byte
=32731			a2bincol = binv-$0d ;1 byte
=32731			decv     = a2bincol
=32725			decstr   = decv-$06 ;6 byte
=32724			a2decpfx = decv-$07 ;1 byte
=32723			a2decpy  = decv-$08 ;1 byte
=32722			a2decpx  = decv-$09 ;1 byte
=32722			a2decpos = decv-$09 ;0 byte
=32721			a2deccol = decv-$0a ;1 byte
=32720			offset   = decv-$0b ;1 byte
=32720			fltv     = offset
=32714			fvar1    = fltv-6  ; 6 byte
=32708			fvar2    = fltv-12 ; 6 byte
=32688			float1   = fltv-32 ;20 byte
=32668			float2   = fltv-52 ;20 byte
=32667			tval1    = fltv-53 ; 1 byte
=32665			tval2    = fltv-55 ; 2 byte
=32663			reponse  = tval2-2 ; 2 byte
=32663			edbox    = reponse
=32662			cleft    = edbox-1 ;1 byte
=32661			cright   = edbox-2 ;1 byte
=32660			cmid     = edbox-3 ;1 byte
=32659			dbtop    = edbox-4 ;1 byte
=32658			dbleft   = edbox-5 ;1 byte
=32657			dbwdth   = edbox-6 ;1 byte
=32656			dbhght   = edbox-7 ;1 byte
=32655			dbcoul   = edbox-8 ;1 byte
=32654			dbclin   = edbox-9 ;1 byte
=32654			ekeyb    = dbclin
=32653			curx     = ekeyb-1 ;1 byte
=32652			cury     = ekeyb-2 ;1 byte
=32651			clef     = ekeyb-3 ;1 byte
=32650			len      = clef-1  ;1 byte
=32649			cx       = clef-2  ;1 byte
=32648			cy       = clef-3  ;1 byte
=32647			bcol     = clef-4  ;1 byte
=32647			escr     = bcol         ;2051 bytes
=32646			loops    = escr-1       ;   1 byte
=32644			loop16   = loops-2      ;   2 byte
=32132			scrncar  = loop16-$200  ;  1k byte
=31620			scrncol  = scrncar-$200 ;  1k byte
=31620			diskvar = scrncol
=31618			ddatas  = diskvar-2 ;2 byte Data start
=31616			ddatae  = diskvar-4 ;2 byte Data end
=31615			ddev    = diskvar-5 ;1 byte Dev number
=31614			dlfsno  = diskvar-6 ;1 byte Lfs
=31612			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=31611			dfnlen  = diskvar-9 ;1 byte lenfilename
=31610			genbyte1 = dfnlen-1 ; 1 byte
=31608			genword1 = dfnlen-3 ; 2 byte
=31607			endofvars = genword1-1

;******  Return to file: dlbug20.asm


;******  End of listing
