
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib -i -L v20test1.txt -o v20test1.prg v20test1.asm
; Sun Jan 18 21:36:19 2026

;Offset	;Hex		;Source

;******  Processing input file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	34 36 32 31	         .text "4621";adresse du debut
>120a	00		         .byte $00   ;fin de cmd basic.
>120b	00 00		bcmd2    .word $00   ;adresse de la pro-
.120d	20 13 12	        jsr bhscrini
.1210	4c 3f 12	basnold jmp main
.1213			bhscrini
.1213	08		        php
.1214	48		        pha
.1215	a9 84		        lda #(128+4)
.1217	8d 00 90	        sta vic0
.121a	ad 0f 90	bord    lda $900f    ;place la couleur
.121d	29 08		        and #%0001000
.121f	09 65		        ora #$65
.1221	8d 0f 90	        sta $900f
.1224	a9 01		text    lda #$01    ;place la couleur
.1226	8d 86 02	        sta $0286   ; du texte.
.1229	a9 93		        lda #$93    ;efface l'ecran par
.122b	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.122e	68		        pla
.122f	28		        plp
.1230	60		        rts
.1231			bhprint
.1231	a0 00		        ldy #$00
.1233	b1 fb		nextc   lda ($fb),y
.1235	f0 07		        beq end
.1237	c8		        iny
.1238	20 d2 ff	        jsr $ffd2
.123b	4c 33 12	        jmp nextc
.123e	60		end     rts

;******  Return to file: v20test1.asm

.123f			main
.123f	a2 00		        ldx #0
.1241	ad 73 12	put     lda chr
.1244	d0 0a		        bne skipit      ; Charge le caractere a afficher.
.1246	48		        pha
.1247	a9 42		        lda #(3*22)
.1249	8d 51 12	        sta skipit+1
.124c	8d 60 12	        sta go+1
.124f	68		        pla
.1250	9d 00 10	skipit  sta $1000,x     ;Affiche le caractere.
.1253	8a		        txa
.1254	29 07		        and #$07
.1256	c9 00		        cmp #0
.1258	d0 05		        bne go
.125a	18		        clc
.125b	69 81		        adc #$81
.125d	29 f7		        and #%11110111
.125f	9d 00 94	go      sta COLMEM,x
.1262	ee 73 12	        inc chr
.1265	e8		        inx
.1266	d0 d9		        bne put
.1268	a9 02		        lda #$02
.126a	8d 86 02	        sta kcol
.126d	a5 93		        lda 147
.126f	20 d2 ff	        jsr $ffd2
.1272	60		        rts
=$1000			SCREEN  =   $1000
=$9400			COLMEM  =   $9400
=36879			SCRBRD  =   36879
=646			CARCOL  =   646
=$fd			ZP2     =   $fd
>1273	00		chr       .byte     0
>1274	00		col       .byte     0
>1275	00		row       .byte     0
>1276	00		lin       .byte     0
>1277	00		adress    .byte     0

;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-push.asm

.1278			pushall
.1278	08		         php     ;s;rp,pcl,pch
.1279	8d b1 23	         sta ra  ;sauve a
.127c	68		         pla     ;s:pcl,pch
.127d	8d b2 23	         sta rp  ;sauve rp
.1280	68		         pla     ;s:pch
.1281	8d ac 23	         sta pc  ;sauve pcl
.1284	68		         pla     ;s:
.1285	8d ad 23	         sta pc+1;sauve pch
.1288	a5 fb		         lda $fb ;sauve fb
.128a	48		         pha     ;s:fb
.128b	a5 fc		         lda $fc ;sauve fc
.128d	48		         pha     ;s:fc,fb
.128e	a5 fd		         lda $fd ;sauve fd
.1290	48		         pha     ;s:fd,fc,fb
.1291	a5 fe		         lda $fe ;sauve fe
.1293	48		         pha     ;s:fe,fd,fc,fb
.1294	ad b2 23	         lda rp  ;sauve rp
.1297	48		         pha     ;s:rp,fe,fd,fc,fb
.1298	ad b1 23	         lda ra  ;sauve ra
.129b	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.129c	8a		         txa     ;sauve rx
.129d	48		         pha     ;s:rx,ra,rp,fe-fb
.129e	98		         tya     ;sauve y
.129f	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.12a0	ad ad 23	         lda pc+1;replace l'adresse
.12a3	48		         pha     ;s:pch,ry,rx,ra,...
.12a4	ad ac 23	         lda pc  ; de retour.
.12a7	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.12a8	ad b2 23	         lda rp  ;place les flags
.12ab	48		         pha     ; sur le stack.
.12ac	ad b1 23	         lda ra  ;recupere ra
.12af	28		         plp     ;recupere les flags.
.12b0	60		         rts
.12b1			popall
.12b1	08		         php     ;s:rp,pcl,pch,ry,rx,...
.12b2	8d b1 23	         sta ra
.12b5	68		         pla     ;s:pcl,pch,ry,rx,...
.12b6	8d b2 23	         sta rp  ;s:pch,ry,rx,ra,rp,...
.12b9	68		         pla
.12ba	8d ac 23	         sta pc  ;sauve pcl
.12bd	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.12be	8d ad 23	         sta pc+1;sauve pch
.12c1	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.12c2	a8		         tay     ;recupere ry
.12c3	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.12c4	aa		         tax     ;recupere rx
.12c5	68		         pla     ;s:rp,fe,fd,fc,fb
.12c6	8d b1 23	         sta ra  ;recupere ra
.12c9	68		         pla     ;s:fe,fd,fc,fb
.12ca	8d b2 23	         sta rp  ;recupere les flags.
.12cd	68		         pla     ;s:fd,fc,fb
.12ce	85 fe		         sta $fe ;reccupere fe
.12d0	68		         pla     ;s:fc,fb
.12d1	85 fd		         sta $fd ;recupere fd
.12d3	68		         pla     ;s:fb
.12d4	85 fc		         sta $fc ;recupere fc
.12d6	68		         pla     ;s:
.12d7	85 fb		         sta $fb ;recupere fb
.12d9	ad ad 23	         lda pc+1;replaace l'adresse de
.12dc	48		         pha     ;s:pch
.12dd	ad ac 23	         lda pc  ;retour sur la pile
.12e0	48		         pha     ;s:pcl,pch
.12e1	ad b2 23	         lda rp  ;recupere les flags
.12e4	48		         pha     ;s:rp,pcl,pch
.12e5	ad b1 23	         lda ra  ;recupere ra
.12e8	28		         plp     ;s:pcl,pch
.12e9	60		         rts
.12ea			pushregs
.12ea	08		         php     ;s;rp,pcl,pch
.12eb	8d b1 23	         sta ra  ; -- sauve a
.12ee	68		         pla     ;s:pcl,pch
.12ef	8d b2 23	         sta rp  ; -- sauve rp
.12f2	68		         pla     ;s:pch
.12f3	8d ac 23	         sta pc  ; -- sauve pcl
.12f6	68		         pla     ;s:
.12f7	8d ad 23	         sta pc+1; -- sauve pch
.12fa	ad b2 23	         lda rp  ; -- sauve rp
.12fd	48		         pha     ;s:rp
.12fe	ad b1 23	         lda ra  ; -- sauve ra
.1301	48		         pha     ;s:ra,rp
.1302	8a		         txa     ; -- tfr rx
.1303	48		         pha     ;s:rx,ra,rp
.1304	98		         tya     ; -- tfr ry
.1305	48		         pha     ;s:ry,rx,ra,rp
.1306	ad ad 23	         lda pc+1; -- replace l'adresse
.1309	48		         pha     ;s:pch,ry,rx,ra,rp
.130a	ad ac 23	         lda pc  ; -- de retour.
.130d	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.130e	ad b2 23	         lda rp  ; -- place les flags
.1311	48		         pha     ;    sur le stack.
.1312	ad b1 23	         lda ra  ; -- recupere ra
.1315	28		         plp     ; -- recupere flags.
.1316	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1317			popregs
.1317	08		         php
.1318	8d b1 23	         sta ra
.131b	68		         pla
.131c	8d b2 23	         sta rp
.131f	68		         pla     ;s:pch,ry,rx,ra,rp
.1320	8d ac 23	         sta pc  ; -- sauve pcl
.1323	68		         pla     ;s:ry,rx,ra,rp
.1324	8d ad 23	         sta pc+1; -- sauve pch
.1327	68		         pla     ;s:rx,ra,rp
.1328	a8		         tay     ;recupere ry
.1329	68		         pla     ;s:ra,rp
.132a	aa		         tax     ;recupere rx
.132b	68		         pla     ;s:rp
.132c	8d b1 23	         sta ra  ;recupere ra
.132f	68		         pla     ;s:
.1330	8d b2 23	         sta rp  ;recupere les flags.
.1333	ad ad 23	         lda pc+1;replace l'adresse de
.1336	48		         pha     ;s:pch
.1337	ad ac 23	         lda pc  ;retour sur la pile
.133a	48		         pha     ;s:pcl,pch
.133b	ad b2 23	         lda rp  ;recupere les flags
.133e	48		         pha     ;s:rp,pcl,pch
.133f	ad b1 23	         lda ra  ;recupere ra
.1342	28		         plp     ;s:pcl,pch
.1343	60		         rts

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-string.asm

.1344			puts
.1344	20 78 12	        jsr pushall
.1347	a0 00		        ldy #$00   ; y = offset
.1349	b1 fb		nextc   lda ($fb),y;lit un caractere
.134b	f0 09		        beq out    ;si 0 on sort
.134d	20 7a f2	        jsr chrout ;on l'affiche
.1350	20 7e 14	        jsr inczp1 ;pointe le prochain
.1353	4c 49 13	        jmp nextc  ; et l'affiche
.1356	20 b1 12	out     jsr popall
.1359	60		        rts
.135a			putsyx
.135a	20 78 12	        jsr pushall;sauve reg + zps
.135d	86 fb		        stx $fb    ;$yyxx dans
.135f	84 fc		        sty $fb+1  ; zp1
.1361	20 44 13	        jsr puts
.1364	20 b1 12	        jsr popall ;recup reg + zps
.1367	60		        rts
.1368			putsxy
.1368	20 78 12	        jsr pushall;sauve reg + zps
.136b	86 fb		        stx $fb    ;$yyxx dans
.136d	84 fc		        sty $fb+1  ; zp1
.136f	a0 00		        ldy #$00
.1371	b1 fb		        lda ($fb),y
.1373	aa		        tax
.1374	20 7e 14	        jsr inczp1
.1377	b1 fb		        lda ($fb),y
.1379	20 7e 14	        jsr inczp1
.137c	a8		        tay
.137d	20 d2 13	        jsr gotoxy
.1380	20 44 13	        jsr puts
.1383	20 b1 12	        jsr popall ;recup reg + zps
.1386	60		        rts
.1387			putsc
.1387	08		        php        ;flag sur stack
.1388	48		        pha        ;acc sur stack
.1389	48		        pha        ;sauvegarde acc
.138a	ad 86 02	        lda kcol   ;recup coul. carac.
.138d	8d ab 23	        sta curcol ; et la sauvegarde
.1390	68		        pla        ;recup. acc
.1391	8d 86 02	        sta kcol   ;place coul. voulue
.1394	20 44 13	        jsr puts   ;affiche la chaine
.1397	ad ab 23	        lda curcol ;recup coul. carac.
.139a	8d 86 02	        sta kcol   ; et la replace
.139d	68		        pla        ;recup acc
.139e	28		        plp        ;recup flag
.139f	60		        rts
.13a0			putscyx
.13a0	08		        php       ;sauve registres
.13a1	48		        pha       ; ...
.13a2	48		        pha       ;sauve acc
.13a3	ad 86 02	        lda kcol  ;recup couleur carac.
.13a6	8d ab 23	        sta curcol; et sauvegarde
.13a9	68		        pla       ;recup acc
.13aa	8d 86 02	        sta kcol  ;place couleur carac.
.13ad	20 5a 13	        jsr putsyx;affiche la chaine
.13b0	ad ab 23	        lda curcol
.13b3	8d 86 02	        sta kcol
.13b6	68		        pla
.13b7	28		        plp
.13b8	60		        rts
.13b9			putscxy
.13b9	08		        php       ;sauve registres
.13ba	48		        pha       ; ...
.13bb	48		        pha       ;sauve acc
.13bc	ad 86 02	        lda kcol  ;recup couleur carac.
.13bf	8d ab 23	        sta curcol; et sauvegarde
.13c2	68		        pla       ;recup acc
.13c3	8d 86 02	        sta kcol   ;place couleur carac.
.13c6	20 5a 13	        jsr putsyx ;affiche la chaine
.13c9	ad ab 23	        lda curcol
.13cc	8d 86 02	        sta kcol
.13cf	68		        pla
.13d0	28		        plp
.13d1	60		        rts
.13d2			gotoxy
.13d2	20 ea 12	        jsr pushregs
.13d5	8a		        txa ; interchange x et y
.13d6	48		        pha ; ...
.13d7	98		        tya ; ...
.13d8	aa		        tax ; ...
.13d9	68		        pla ; ...
.13da	a8		        tay ; ...
.13db	c0 00		txlow   cpy #0
.13dd	10 02		        bpl txhigh
.13df	a2 00		        ldx #0
.13e1	e0 19		txhigh  cpx #25
.13e3	30 02		        bmi tylow
.13e5	a2 18		        ldx #24
.13e7	c0 00		tylow   cpy #0
.13e9	10 02		        bpl tyhigh
.13eb	a0 00		        ldy #0
.13ed	c0 28		tyhigh  cpy #40
.13ef	30 02		        bmi allok
.13f1	a0 27		        ldy #39
.13f3	18		allok   clc
.13f4	20 0a e5	        jsr plot
.13f7	20 17 13	        jsr popregs
.13fa	60		        rts
.13fb			putnch
.13fb	20 ea 12	        jsr pushregs
.13fe	20 7a f2	again   jsr chrout
.1401	ca		        dex
.1402	d0 fa		        bne again
.1404	20 17 13	        jsr popregs
.1407	60		        rts
.1408			strlen
.1408	20 78 12	        jsr pushall
.140b	84 fc		        sty zp1+1
.140d	86 fb		        stx zp1
.140f	a0 00		        ldy #$00
.1411	8c 3d 23	        sty len
.1414	b1 fb		next    lda (zp1),y
.1416	f0 07		        beq out
.1418	ee 3d 23	        inc len
.141b	c8		        iny
.141c	4c 14 14	        jmp next
.141f	20 b1 12	out     jsr popall
.1422	ad 3d 23	        lda len
.1425	60		        rts
.1426			cursor
.1426	20 ea 12	        jsr  pushregs
.1429	90 12		        bcc  get    ;C=0 récupération.
.142b	20 0a e5	        jsr  plot  ;récupère position
.142e	8c 3c 23	        sty  cx     ;curseur et sauve
.1431	8e 3b 23	        stx  cy     ;dans vars locales.
.1434	ad 86 02	        lda  kcol   ;Sauve couleur
.1437	8d 3a 23	        sta  bcol   ; BASIC du texte.
.143a	4c 4c 14	        jmp  out    ;Fini on sort.
.143d	ae 3b 23	get     ldx  cy     ;C=1, charge x
.1440	ac 3c 23	        ldy  cx     ; ligne, y col.
.1443	20 0a e5	        jsr  plot  ;Position curseur.
.1446	ad 3a 23	        lda  bcol   ;replace couleur
.1449	8d 86 02	        sta  kcol ; basic sauvegardé.
.144c	20 17 13	out     jsr  popregs
.144f	60		        rts
.1450			cursave
.1450	08		        php
.1451	38		        sec
.1452	20 26 14	        jsr  cursor
.1455	28		        plp
.1456	60		        rts
.1457			curput
.1457	08		        php
.1458	18		        clc
.1459	20 26 14	        jsr  cursor
.145c	28		        plp
.145d	60		        rts

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-mem.asm

.145e			blkfill
.145e	20 78 12	bf0     jsr pushall
.1461	84 fc		        sty zp1+1
.1463	a0 00		        ldy #$00
.1465	84 fb		        sty zp1
.1467	91 fb		bf1     sta (zp1),y
.1469	c8		        iny
.146a	d0 fb		        bne bf1
.146c	20 b1 12	        jsr popall
.146f	60		        rts
.1470			memfill
.1470	20 ea 12	        jsr pushregs
.1473	20 5e 14	mf1     jsr blkfill
.1476	c8		        iny
.1477	ca		        dex
.1478	d0 f9		        bne mf1
.147a	20 17 13	        jsr popregs
.147d	60		        rts
.147e			inczp1
.147e	08		         php
.147f	e6 fb		         inc zp1
.1481	d0 02		         bne repzp1
.1483	e6 fc		         inc zp1+1
.1485	28		repzp1   plp
.1486	60		         rts
.1487			inczp2
.1487	08		         php
.1488	e6 fd		         inc zp2
.148a	d0 02		         bne repzp2
.148c	e6 fe		         inc zp2+1
.148e	28		repzp2   plp
.148f	60		         rts
.1490			deczp1
.1490	08		         php
.1491	48		         pha
.1492	a5 fb		         lda zp1
.1494	d0 02		         bne noemp
.1496	c6 fc		         dec zp1+1
.1498	c6 fb		noemp    dec zp1
.149a	68		         pla
.149b	28		         plp
.149c	60		         rts
.149d			deczp2
.149d	08		         php
.149e	48		         pha
.149f	a5 fd		         lda zp2
.14a1	d0 02		         bne noemp
.14a3	c6 fe		         dec zp2+1
.14a5	c6 fd		noemp    dec zp2
.14a7	68		         pla
.14a8	28		         plp
.14a9	60		         rts
.14aa			rolzp1
.14aa	08		        php
.14ab	48		        pha
.14ac	18		        clc
.14ad	a5 fb		        lda zp1
.14af	2a		        rol
.14b0	85 fb		        sta zp1
.14b2	a5 fc		        lda zp1+1
.14b4	2a		        rol
.14b5	85 fc		        sta zp1+1
.14b7	68		        pla
.14b8	28		        plp
.14b9			rorzp1
.14b9	08		        php
.14ba	48		        pha
.14bb	18		        clc
.14bc	a5 fc		        lda zp1+1
.14be	6a		        ror
.14bf	85 fc		        sta zp1+1
.14c1	a5 fb		        lda zp1
.14c3	6a		        ror
.14c4	85 fb		        sta zp1
.14c6	68		        pla
.14c7	28		        plp
.14c8			rolzp2
.14c8	08		        php
.14c9	48		        pha
.14ca	18		        clc
.14cb	a5 fd		        lda zp2
.14cd	2a		        rol
.14ce	85 fd		        sta zp2
.14d0	a5 fe		        lda zp2+1
.14d2	2a		        rol
.14d3	85 fe		        sta zp2+1
.14d5	68		        pla
.14d6	28		        plp
.14d7			rorzp2
.14d7	08		        php
.14d8	48		        pha
.14d9	18		        clc
.14da	a5 fe		        lda zp2+1
.14dc	6a		        ror
.14dd	85 fe		        sta zp2+1
.14df	a5 fd		        lda zp2
.14e1	6a		        ror
.14e2	85 fd		        sta zp2
.14e4	68		        pla
.14e5	28		        plp
.14e6			yxtoptr
.14e6	8c ab 23	        sty memptr+1
.14e9	8e aa 23	        stx memptr
.14ec	60		        rts
.14ed			ptrtoyx
.14ed	08		        php
.14ee	ac ab 23	        ldy memptr+1
.14f1	ae aa 23	        ldx memptr
.14f4	28		        plp
.14f5	60		        rts
.14f6			incptr
.14f6	08		        php
.14f7	ee aa 23	        inc memptr
.14fa	d0 03		        bne norep
.14fc	ee ab 23	        inc memptr+1
.14ff	28		norep   plp
.1500	60		        rts
.1501			decptr
.1501	08		        php
.1502	48		        pha
.1503	ad aa 23	        lda memptr
.1506	d0 03		        bne noemp
.1508	ee ab 23	        inc memptr+1
.150b	ee aa 23	noemp   inc memptr
.150e	68		        pla
.150f	28		        plp
.1510	60		        rts
.1511			incptr8
.1511	08		        php
.1512	48		        pha
.1513	98		        tya
.1514	48		        pha
.1515	a0 08		        ldy #8
.1517	20 f6 14	again   jsr incptr
.151a	88		        dey
.151b	d0 fa		        bne again
.151d	68		        pla
.151e	a8		        tay
.151f	68		        pla
.1520	28		        plp
.1521	60		        rts
.1522			loop
.1522	ce a4 23	               dec  loopcount
.1525	d0 03		               bne  norep
.1527	ce a5 23	               dec  loopcount+1
.152a	ad a4 23	norep          lda  loopcount
.152d	c9 00		               cmp  #$00
.152f	d0 05		               bne  out
.1531	4d a5 23	               eor  loopcount+1
.1534	c9 ff		               cmp  #$ff
.1536	60		out            rts

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-math.asm

.1537			addtoword
.1537			addatoyx
.1537	08		        php
.1538	48		        pha
.1539	8c 4b 23	        sty reponse+1
.153c	8e 4a 23	        stx reponse
.153f	18		        clc
.1540	6d 4a 23	        adc reponse
.1543	90 03		        bcc norep
.1545	ee 4b 23	        inc reponse+1
.1548	8d 4a 23	norep   sta reponse
.154b	ac 4b 23	        ldy reponse+1
.154e	ae 4a 23	        ldx reponse
.1551	68		        pla
.1552	28		        plp
.1553	60		        rts
.1554			subtoword
.1554			subatoyx
.1554	08		        php
.1555	48		        pha
.1556	8c 4b 23	        sty reponse+1
.1559	8e 4a 23	        stx reponse
.155c	38		        sec
.155d	ed 4a 23	        sbc reponse
.1560	b0 03		        bcs noemp
.1562	ce 4b 23	        dec reponse+1
.1565	8d 4a 23	noemp   sta reponse
.1568	ac 4b 23	        ldy reponse+1
.156b	ae 4a 23	        ldx reponse
.156e	68		        pla
.156f	28		        plp
.1570	60		        rts

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-conv.asm

.1571			putyxhex
.1571	20 78 12	        jsr pushall
.1574	98		        tya
.1575	48		        pha
.1576	20 e3 15	        jsr lsr4bits
.1579	20 ea 15	        jsr nibtohex
.157c	8d 9f 23	        sta hexstr+0
.157f	68		        pla
.1580	20 ea 15	        jsr nibtohex
.1583	8d a0 23	        sta hexstr+1
.1586	8a		        txa
.1587	20 a6 15	        jsr atohex
.158a	a2 9f		        ldx #<hexstr+0
.158c	a0 23		        ldy #>hexstr+0
.158e	20 5a 13	        jsr putsyx
.1591	20 b1 12	        jsr popall
.1594	60		        rts
.1595			putahex
.1595	20 ea 12	        jsr pushregs
.1598	20 a6 15	        jsr atohex
.159b	a2 a1		        ldx #<hexstr+2
.159d	a0 23		        ldy #>hexstr+2
.159f	20 5a 13	        jsr putsyx
.15a2	20 17 13	        jsr popregs
.15a5	60		        rts
.15a6			atohex
.15a6	08		        php
.15a7	48		        pha
.15a8	48		        pha
.15a9	20 e3 15	        jsr lsr4bits
.15ac	20 ea 15	        jsr nibtohex
.15af	8d 9f 23	        sta hexstr
.15b2	68		        pla
.15b3	20 ea 15	        jsr nibtohex
.15b6	8d a0 23	        sta hexstr+1
.15b9	a9 00		        lda #$00
.15bb	8d a1 23	        sta hexstr+2
.15be	68		        pla
.15bf	28		        plp
.15c0	60		        rts
.15c1			atobin
.15c1	20 ea 12	               jsr  pushregs
.15c4	a2 08		               ldx  #8
.15c6	a0 00		               ldy  #0
.15c8	18		               clc
.15c9	2a		nextbit        rol
.15ca	48		               pha
.15cb	69 00		               adc  #$00
.15cd	29 01		               and  #$01
.15cf	20 ea 15	               jsr  nibtohex
.15d2	99 92 23	               sta  binstr,y
.15d5	68		               pla
.15d6	c8		               iny
.15d7	ca		               dex
.15d8	d0 ef		               bne  nextbit
.15da	a9 00		               lda  #0
.15dc	99 92 23	               sta  binstr,y
.15df	20 17 13	               jsr  popregs
.15e2	60		               rts
.15e3			lsr4bits
.15e3	08		        php
.15e4	4a		        lsr a
.15e5	4a		        lsr a
.15e6	4a		        lsr a
.15e7	4a		        lsr a
.15e8	28		        plp
.15e9	60		        rts
.15ea			nibtohex
.15ea	08		        php
.15eb	29 0f		        and    #$0f
.15ed	f8		        sed
.15ee	18		        clc
.15ef	69 90		        adc #$90
.15f1	69 40		        adc #$40
.15f3	28		        plp
.15f4	60		        rts
.15f5			bytestohex
.15f5	20 78 12	        jsr pushall
.15f8	84 fc		        sty zp1+1
.15fa	86 fb		        stx zp1
.15fc	08		        php
.15fd	48		        pha
.15fe	a9 20		        lda #32
.1600	20 7a f2	        jsr chrout
.1603	68		        pla
.1604	28		        plp
.1605	08		        php
.1606	48		        pha
.1607	a9 05		        lda #5
.1609	20 7a f2	        jsr chrout
.160c	68		        pla
.160d	28		        plp
.160e	08		        php
.160f	48		        pha
.1610	a9 24		        lda #36
.1612	20 7a f2	        jsr chrout
.1615	68		        pla
.1616	28		        plp
.1617	20 71 15	        jsr putyxhex   ; prn adreponsese
.161a	08		        php
.161b	48		        pha
.161c	a9 20		        lda #$20
.161e	20 7a f2	        jsr chrout
.1621	68		        pla
.1622	28		        plp
.1623	08		        php
.1624	48		        pha
.1625	a9 9f		        lda #159
.1627	20 7a f2	        jsr chrout
.162a	68		        pla
.162b	28		        plp
.162c	a0 00		        ldy #$00
.162e	aa		        tax
.162f	8c 83 23	another sty offset
.1632	b1 fb		        lda (zp1),y
.1634	20 95 15	        jsr putahex
.1637	48		        pha
.1638	20 57 16	        jsr petsciiaddr
.163b	68		        pla
.163c	8d 00 04	petscii sta $0400
.163f	48		        pha
.1640	a9 0d		        lda #$0d
.1642	8d 00 d8	petcol  sta $d800
.1645	68		        pla
.1646	08		        php
.1647	48		        pha
.1648	a9 20		        lda #$20
.164a	20 7a f2	        jsr chrout
.164d	68		        pla
.164e	28		        plp
.164f	c8		        iny
.1650	ca		        dex
.1651	d0 dc		        bne another
.1653	20 b1 12	        jsr popall
.1656	60		        rts
.1657			petsciiaddr
.1657	20 ea 12	        jsr pushregs
.165a	08		        php
.165b	a4 d2		        ldy scrnlin+1
.165d	a6 d1		        ldx scrnlin
.165f	28		        plp
.1660	a9 1f		        lda #31
.1662	18		        clc
.1663	6d 83 23	        adc offset
.1666	20 37 15	        jsr addatoyx
.1669	8c 3e 16	        sty petscii+2
.166c	8e 3d 16	        stx petscii+1
.166f	8e 43 16	        stx petcol+1
.1672	98		        tya
.1673	29 fb		        and #%11111011 ;#%00000100
.1675	09 d8		        ora #$d8
.1677	8d 44 16	        sta petcol+2
.167a	a8		        tay
.167b	20 17 13	        jsr popregs
.167e	60		        rts
.167f			strhexval
.167f	20 78 12	        jsr pushall ; sauve registre
.1682	84 fc		        sty zp1+1   ; ptr dans zp1
.1684	86 fb		        stx zp1
.1686	20 08 14	        jsr strlen  ;len de $(yyxx)->a
.1689	f0 3d		        beq oute    ; si 0 erreur C=1
.168b	a0 00		        ldy #$00    ; offset a 0
.168d	8c 4b 23	        sty reponse+1; reponse a zero
.1690	8c 4a 23	        sty reponse ;    ...
.1693	b1 fb		nextc   lda (zp1),y ;charge un caractere
.1695	f0 26		        beq out     ;On  a fini
.1697	c0 00		        cpy #$00    ;si c'est le premier
.1699	f0 07		        beq norol   ; pas de rol
.169b	48		        pha         ;
.169c	a9 04		        lda #$04    ;rol de 4 pos
.169e	20 f8 16	        jsr rolword ;
.16a1	68		        pla         ;
.16a2	09 20		norol   ora #%00100000
.16a4	38		        sec
.16a5	e9 30		        sbc #$30
.16a7	c9 0a		        cmp #$0a
.16a9	90 07		        bcc lt10
.16ab	38		        sec
.16ac	e9 27		        sbc #$27
.16ae	c9 10		        cmp #$10
.16b0	b0 16		        bcs oute
.16b2	0d 4a 23	lt10    ora reponse
.16b5	8d 4a 23	        sta reponse
.16b8	c8		        iny
.16b9	c0 04		        cpy #$04
.16bb	d0 d6		        bne nextc
.16bd	20 b1 12	out     jsr popall
.16c0	18		        clc          ;Carry 0 = good
.16c1	ac 4b 23	        ldy reponse+1
.16c4	ae 4a 23	        ldx reponse
.16c7	60		        rts
.16c8	20 b1 12	oute    jsr popall
.16cb	38		        sec
.16cc	60		        rts
.16cd			putahexdec
.16cd	20 ea 12	        jsr pushregs
.16d0	08		        php
.16d1	48		        pha
.16d2	a9 9e		        lda #sjaune
.16d4	20 7a f2	        jsr chrout
.16d7	68		        pla
.16d8	28		        plp
.16d9	20 95 15	        jsr putahex
.16dc	08		        php
.16dd	48		        pha
.16de	a9 20		        lda #$20
.16e0	20 7a f2	        jsr chrout
.16e3	68		        pla
.16e4	28		        plp
.16e5	08		        php
.16e6	48		        pha
.16e7	a9 9f		        lda #socean
.16e9	20 7a f2	        jsr chrout
.16ec	68		        pla
.16ed	28		        plp
.16ee	aa		        tax
.16ef	a9 00		        lda #$00
.16f1	20 cd dd	        jsr fiaxtf1
.16f4	20 17 13	        jsr popregs
.16f7	60		        rts
.16f8			rolword
.16f8	20 ea 12	        jsr pushregs
.16fb	a8		        tay
.16fc	18		again   clc
.16fd	2e 4a 23	        rol reponse
.1700	2e 4b 23	        rol reponse+1
.1703	88		        dey
.1704	d0 f6		        bne again
.1706	20 17 13	        jsr popregs
.1709	60		        rts

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-keyb.asm

.170a			clrkbbuf
.170a	08		            php
.170b	48		            pha
.170c	a9 00		            lda #0
.170e	85 c6		            sta 198
.1710	68		            pla
.1711	28		            plp
.1712	60		            rts
.1713			waitstop
.1713	08		          php    ;\ sauve les flags
.1714	48		          pha    ;/  et l'acc.
.1715	20 0a 17	          jsr clrkbbuf
.1718	20 70 f7	wait      jsr stop ; Veri [run/stop]
.171b	d0 fb		          bne wait ;loop pas pesee.
.171d	68		          pla    ;\ recup. acc et
.171e	28		          plp    ;/  les flags.
.171f	60		          rts
.1720			anykey
.1720	08		        php
.1721	48		        pha
.1722	20 0a 17	        jsr clrkbbuf
.1725	a5 cb		wait    lda 203    ;lit la matrice de
.1727	c9 40		        cmp #64    ; 64 = aucune clef
.1729	f0 fa		        beq wait   ; on en attend une.
.172b	20 34 17	        jsr kbfree ; Clavier relache.
.172e	20 0a 17	        jsr clrkbbuf
.1731	68		        pla
.1732	28		        plp
.1733	60		        rts
.1734			kbfree
.1734	08		        php
.1735	48		        pha
.1736	a5 cb		wait    lda 203    ; lit la matrice
.1738	c9 40		        cmp #64    ; 64 = aucune clef
.173a	d0 fa		        bne wait   ; attend la relache
.173c	68		        pla
.173d	28		        plp
.173e	60		        rts
.173f			getkey
.173f	08		        php
.1740	20 f5 f1	try     jsr getin  ;tente de lire
.1743	c9 00		        cmp #0     ; 0 si aucune.
.1745	f0 f9		        beq try    ; on reessaye
.1747	28		        plp
.1748	60		        rts
.1749			waitkey
.1749	08		        php
.174a	48		        pha
.174b	8d 3e 23	        sta clef   ;Sauve clef voulue
.174e	20 0a 17	        jsr clrkbbuf
.1751	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.1754	cd 3e 23	        cmp clef   ;Compare avec clef
.1757	d0 f8		        bne wait   ;Pas la bonne.
.1759	68		        pla
.175a	28		        plp
.175b	60		        rts
.175c			waitspace
.175c	a9 20		            lda #$20
.175e	20 49 17	            jsr waitkey
.1761	20 0a 17	            jsr clrkbbuf
.1764	60		            rts
.1765			showkey
.1765	20 ea 12	        jsr pushregs
.1768	38		        sec
.1769	20 0a e5	        jsr plot
.176c	8e 40 23	        stx curx
.176f	8c 3f 23	        sty cury
.1772	20 ea 12	        jsr pushregs
.1775	a0 1c		        ldy #39-11
.1777	a2 18		        ldx #24
.1779	18		        clc
.177a	20 0a e5	        jsr plot
.177d	20 17 13	        jsr popregs
.1780	20 7a f2	        jsr chrout
.1783	08		        php
.1784	48		        pha
.1785	a9 20		        lda #32
.1787	20 7a f2	        jsr chrout
.178a	68		        pla
.178b	28		        plp
.178c	08		        php
.178d	48		        pha
.178e	a9 24		        lda #36
.1790	20 7a f2	        jsr chrout
.1793	68		        pla
.1794	28		        plp
.1795	20 cd 16	        jsr putahexdec
.1798	18		        clc
.1799	ac 3f 23	        ldy cury
.179c	ae 40 23	        ldx curx
.179f	20 0a e5	        jsr plot
.17a2	20 17 13	        jsr popregs
.17a5	60		        rts

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-vars.asm

=9139			libre    = *+3085
=9138			rp       = libre-$01;1 byte $cfff
=9137			ra       = rp-1     ;1 byte $cffe
=9136			rx       = ra-1     ;1 byte $cffd
=9135			ry       = rx-1     ;1 byte $cffc
=9134			rs       = ry-1     ;1 byte $cffb
=9132			pc       = rs-2     ;2 byte $cff9-$cffa
=9131			curcol   = pc-1     ;1 byte $cff6
=9130			memptr   = curcol-1;1 word $cff7-$cff8
=9128			src      = memptr-2
=9126			dst      = memptr-4
=9124			loopcount = memptr-6
=9124			hexv     = loopcount
.17a6			a2hexstr
=9119			hexstr   = hexv-$05 ;5 byte
=9118			a2hexpfx = hexv-$06 ;1 byte
=9117			a2hexpy  = hexv-$07 ;1 byte
=9116			a2hexpx  = hexv-$08 ;1 byte
=9116			a2hexpos = hexv-$08 ;0 byte
=9115			a2hexcol = hexv-$09 ;1 byte
=9115			binv     = a2hexcol
=9106			binstr   = binv-$09 ;9 byte
=9105			a2binpfx = binv-$0a ;1 byte
=9104			a2binpy  = binv-$0b ;1 byte
=9103			a2binpx  = binv-$0c ;1 byte
=9103			a2binpos = binv-$0c ;0 byte
=9102			a2bincol = binv-$0d ;1 byte
=9102			decv     = a2bincol
=9096			decstr   = decv-$06 ;6 byte
=9095			a2decpfx = decv-$07 ;1 byte
=9094			a2decpy  = decv-$08 ;1 byte
=9093			a2decpx  = decv-$09 ;1 byte
=9093			a2decpos = decv-$09 ;0 byte
=9092			a2deccol = decv-$0a ;1 byte
=9091			offset   = decv-$0b ;1 byte
=9091			fltv     = offset
=9085			fvar1    = fltv-6  ; 6 byte
=9079			fvar2    = fltv-12 ; 6 byte
=9059			float1   = fltv-32 ;20 byte
=9039			float2   = fltv-52 ;20 byte
=9038			tval1    = fltv-53 ; 1 byte
=9036			tval2    = fltv-55 ; 2 byte
=9034			reponse  = tval2-2 ; 2 byte
=9034			edbox    = reponse
=9033			cleft    = edbox-1 ;1 byte
=9032			cright   = edbox-2 ;1 byte
=9031			cmid     = edbox-3 ;1 byte
=9030			dbtop    = edbox-4 ;1 byte
=9029			dbleft   = edbox-5 ;1 byte
=9028			dbwdth   = edbox-6 ;1 byte
=9027			dbhght   = edbox-7 ;1 byte
=9026			dbcoul   = edbox-8 ;1 byte
=9025			dbclin   = edbox-9 ;1 byte
=9025			ekeyb    = dbclin
=9024			curx     = ekeyb-1 ;1 byte
=9023			cury     = ekeyb-2 ;1 byte
=9022			clef     = ekeyb-3 ;1 byte
=9021			len      = clef-1  ;1 byte
=9020			cx       = clef-2  ;1 byte
=9019			cy       = clef-3  ;1 byte
=9018			bcol     = clef-4  ;1 byte
=9018			escr     = bcol          ;   2051 bytes
=9017			loops    = escr-1       ; 1 byte
=9015			loop16   = loops-2      ; 2 byte
=7991			scrncar  = loop16-1024  ;1k byte
=6967			scrncol  = scrncar-1024 ;1k byte
=6967			diskvar = scrncol
=6965			ddatas  = diskvar-2 ;2 byte Data start
=6963			ddatae  = diskvar-4 ;2 byte Data end
=6962			ddev    = diskvar-5 ;1 byte Dev number
=6961			dlfsno  = diskvar-6 ;1 byte Lfs
=6959			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=6958			dfnlen  = diskvar-9 ;1 byte lenfilename
=6957			genbyte1 = dfnlen-1 ; 1 byte
=6955			genword1 = dfnlen-3 ; 2 byte
=6954			endofvars = genword1-1

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm


;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			fFAC1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			fFAC1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; ff1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; ff1=atn(f1).

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.17a6	4c 3f 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: v20test1.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$00			eot       = $00
=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: v20test1.asm


;******  End of listing
