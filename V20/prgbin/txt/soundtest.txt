
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L soundtest.txt -o soundtest.prg soundtest.asm
; Mon Feb  2 00:54:20 2026

;Offset	;Hex		;Source

;******  Processing input file: soundtest.asm

="20260131-192144"	version  = "20260131-192144"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

=$1000			scrtxt    = $1000
=$9400			scrcol    = $9400
=$0200			scrlen    = $0200
>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	20 34 36 32	         .text format("%5d", bhstart)
>120a	32
>120b	00		         .byte $00   ;fin de cmd basic.
>120c	00 00		bcmd2    .word $00   ;adresse de la pro-
.120e	20 1a 12	bhstart   jsr bhscrini
.1211	ea		          nop
.1212	ea		          nop
.1213	ea		          nop
.1214	ea		          nop
.1215	ea		          nop
.1216	20 46 12	basnold   jsr main
.1219	60		          rts
.121a			bhscrini
.121a	08		        php
.121b	48		        pha
.121c	a9 84		        lda #(128+4)
.121e	8d 00 90	        sta vic0
.1221	ad 0f 90	bord    lda $900f    ;place la couleur
.1224	29 08		        and #%00001000
.1226	09 e3		        ora #%11100011
.1228	8d 0f 90	        sta $900f
.122b	a9 00		text    lda #$00    ;place la couleur
.122d	8d 86 02	        sta $0286   ; du texte.
.1230	a9 93		        lda #$93    ;efface l'ecran par
.1232	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.1235	68		        pla
.1236	28		        plp
.1237	60		        rts
.1238			bhprint
.1238	a0 00		        ldy #$00
.123a	b1 fb		nextc   lda ($fb),y
.123c	f0 07		        beq end
.123e	c8		        iny
.123f	20 d2 ff	        jsr $ffd2
.1242	4c 3a 12	        jmp nextc
.1245	60		end     rts

;******  Return to file: soundtest.asm

.1246			main
.1246	a9 04		          lda #4
.1248	29 0f		          and #%00001111
.124a	8d 0e 90	          sta vicvol
.124d	20 74 12	here    jsr piano
.1250	ad 0a 90	          lda  vicbas
.1253	29 7f		          and  #%01111111
.1255	8d 0a 90	          sta  vicbas
.1258	ad 0b 90	          lda  vicalt
.125b	29 7f		          and  #%01111111
.125d	8d 0b 90	          sta  vicalt
.1260	ad 0c 90	          lda  vicsop
.1263	29 7f		          and  #%01111111
.1265	8d 0c 90	          sta  vicsop
.1268	ad 0d 90	          lda  vicnoi
.126b	29 7f		          and  #%01111111
.126d	8d 0d 90	          sta  vicnoi
.1270	4c 4d 12	        jmp here
.1273	60		        rts
.1274			piano
.1274	20 4d 13	        jsr pushall
.1277	20 e6 18	next    jsr getkey
.127a	c9 41		testa   cmp #$41
.127c	d0 07		        bne testw
.127e	a9 e1		          lda  #v2do4
.1280	09 80		          ora  #%10000000
.1282	8d 0a 90	          sta  vicbas
.1285	c9 57		testw   cmp #$57
.1287	d0 07		        bne tests
.1289	a9 e2		          lda  #v2dod4
.128b	09 80		          ora  #%10000000
.128d	8d 0a 90	          sta  vicbas
.1290	c9 53		tests   cmp #$53
.1292	d0 07		        bne teste
.1294	a9 e4		          lda  #v2re4
.1296	09 80		          ora  #%10000000
.1298	8d 0a 90	          sta  vicbas
.129b	c9 45		teste   cmp #$45
.129d	d0 07		        bne testd
.129f	a9 e5		          lda  #v2red4
.12a1	09 80		          ora  #%10000000
.12a3	8d 0a 90	          sta  vicbas
.12a6	c9 44		testd   cmp #$44
.12a8	d0 07		        bne testf
.12aa	a9 e7		          lda  #v2mi4
.12ac	09 80		          ora  #%10000000
.12ae	8d 0a 90	          sta  vicbas
.12b1	c9 46		testf   cmp #$46
.12b3	d0 07		        bne testt
.12b5	a9 e8		          lda  #v2fa4
.12b7	09 80		          ora  #%10000000
.12b9	8d 0a 90	          sta  vicbas
.12bc	c9 54		testt   cmp #$54
.12be	d0 07		        bne testg
.12c0	a9 e9		          lda  #v2fad4
.12c2	09 80		          ora  #%10000000
.12c4	8d 0a 90	          sta  vicbas
.12c7	c9 47		testg   cmp #$47
.12c9	d0 07		        bne testy
.12cb	a9 eb		          lda  #v2so4
.12cd	09 80		          ora  #%10000000
.12cf	8d 0a 90	          sta  vicbas
.12d2	c9 59		testy   cmp #$59
.12d4	d0 07		        bne testh
.12d6	a9 ec		          lda  #v2sod4
.12d8	09 80		          ora  #%10000000
.12da	8d 0a 90	          sta  vicbas
.12dd	c9 48		testh   cmp #$48
.12df	d0 07		        bne testu
.12e1	a9 ed		          lda  #v2la4
.12e3	09 80		          ora  #%10000000
.12e5	8d 0a 90	          sta  vicbas
.12e8	c9 55		testu   cmp #$55
.12ea	d0 07		        bne testj
.12ec	a9 ee		          lda  #v2lad4
.12ee	09 80		          ora  #%10000000
.12f0	8d 0a 90	          sta  vicbas
.12f3	c9 4a		testj   cmp #$4a
.12f5	d0 07		        bne testk
.12f7	a9 ef		          lda  #v2si4
.12f9	09 80		          ora  #%10000000
.12fb	8d 0a 90	          sta  vicbas
.12fe	c9 4b		testk   cmp #$4b
.1300	d0 07		        bne testesc
.1302	a9 f0		          lda  #v2do5
.1304	09 80		          ora  #%10000000
.1306	8d 0a 90	          sta  vicbas
.1309	c9 5f		testesc cmp #$5f
.130b	f0 03		        beq out
.130d	4c 77 12	        jmp next
.1310	20 86 13	out     jsr popall
.1313	60		        rts
.1314			colortest
.1314	a2 00		        ldx #0
.1316	ad 48 13	put     lda chr
.1319	d0 0a		        bne skipit      ; Charge le caractere a afficher.
.131b	48		        pha
.131c	a9 42		        lda #(3*22)
.131e	8d 26 13	        sta skipit+1
.1321	8d 35 13	        sta go+1
.1324	68		        pla
.1325	9d 00 10	skipit  sta $1000,x     ;Affiche le caractere.
.1328	8a		        txa
.1329	29 07		        and #$07
.132b	c9 00		        cmp #0
.132d	d0 05		        bne go
.132f	18		        clc
.1330	69 81		        adc #$81
.1332	29 f7		        and #%11110111
.1334	9d 00 94	go      sta COLMEM,x
.1337	ee 48 13	        inc chr
.133a	e8		        inx
.133b	d0 d9		        bne put
.133d	a9 02		        lda #$02
.133f	8d 86 02	        sta kcol
.1342	a5 93		        lda 147
.1344	20 d2 ff	        jsr $ffd2
.1347	60		        rts
=$1000			SCREEN  =   $1000
=$9400			COLMEM  =   $9400
=36879			SCRBRD  =   36879
=646			CARCOL  =   646
=$fd			ZP2     =   $fd
>1348	00		chr       .byte     0
>1349	00		col       .byte     0
>134a	00		row       .byte     0
>134b	00		lin       .byte     0
>134c	00		adress    .byte     0

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.134d			pushall
.134d	08		         php     ;s;rp,pcl,pch
.134e	8d fe 7f	         sta ra  ;sauve a
.1351	68		         pla     ;s:pcl,pch
.1352	8d ff 7f	         sta rp  ;sauve rp
.1355	68		         pla     ;s:pch
.1356	8d f9 7f	         sta pc  ;sauve pcl
.1359	68		         pla     ;s:
.135a	8d fa 7f	         sta pc+1;sauve pch
.135d	a5 fb		         lda $fb ;sauve fb
.135f	48		         pha     ;s:fb
.1360	a5 fc		         lda $fc ;sauve fc
.1362	48		         pha     ;s:fc,fb
.1363	a5 fd		         lda $fd ;sauve fd
.1365	48		         pha     ;s:fd,fc,fb
.1366	a5 fe		         lda $fe ;sauve fe
.1368	48		         pha     ;s:fe,fd,fc,fb
.1369	ad ff 7f	         lda rp  ;sauve rp
.136c	48		         pha     ;s:rp,fe,fd,fc,fb
.136d	ad fe 7f	         lda ra  ;sauve ra
.1370	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.1371	8a		         txa     ;sauve rx
.1372	48		         pha     ;s:rx,ra,rp,fe-fb
.1373	98		         tya     ;sauve y
.1374	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.1375	ad fa 7f	         lda pc+1;replace l'adresse
.1378	48		         pha     ;s:pch,ry,rx,ra,...
.1379	ad f9 7f	         lda pc  ; de retour.
.137c	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.137d	ad ff 7f	         lda rp  ;place les flags
.1380	48		         pha     ; sur le stack.
.1381	ad fe 7f	         lda ra  ;recupere ra
.1384	28		         plp     ;recupere les flags.
.1385	60		         rts
.1386			popall
.1386	08		         php     ;s:rp,pcl,pch,ry,rx,...
.1387	8d fe 7f	         sta ra
.138a	68		         pla     ;s:pcl,pch,ry,rx,...
.138b	8d ff 7f	         sta rp  ;s:pch,ry,rx,ra,rp,...
.138e	68		         pla
.138f	8d f9 7f	         sta pc  ;sauve pcl
.1392	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.1393	8d fa 7f	         sta pc+1;sauve pch
.1396	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.1397	a8		         tay     ;recupere ry
.1398	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.1399	aa		         tax     ;recupere rx
.139a	68		         pla     ;s:rp,fe,fd,fc,fb
.139b	8d fe 7f	         sta ra  ;recupere ra
.139e	68		         pla     ;s:fe,fd,fc,fb
.139f	8d ff 7f	         sta rp  ;recupere les flags.
.13a2	68		         pla     ;s:fd,fc,fb
.13a3	85 fe		         sta $fe ;reccupere fe
.13a5	68		         pla     ;s:fc,fb
.13a6	85 fd		         sta $fd ;recupere fd
.13a8	68		         pla     ;s:fb
.13a9	85 fc		         sta $fc ;recupere fc
.13ab	68		         pla     ;s:
.13ac	85 fb		         sta $fb ;recupere fb
.13ae	ad fa 7f	         lda pc+1;replaace l'adresse de
.13b1	48		         pha     ;s:pch
.13b2	ad f9 7f	         lda pc  ;retour sur la pile
.13b5	48		         pha     ;s:pcl,pch
.13b6	ad ff 7f	         lda rp  ;recupere les flags
.13b9	48		         pha     ;s:rp,pcl,pch
.13ba	ad fe 7f	         lda ra  ;recupere ra
.13bd	28		         plp     ;s:pcl,pch
.13be	60		         rts
.13bf			pushregs
.13bf	08		         php     ;s;rp,pcl,pch
.13c0	8d fe 7f	         sta ra  ; -- sauve a
.13c3	68		         pla     ;s:pcl,pch
.13c4	8d ff 7f	         sta rp  ; -- sauve rp
.13c7	68		         pla     ;s:pch
.13c8	8d f9 7f	         sta pc  ; -- sauve pcl
.13cb	68		         pla     ;s:
.13cc	8d fa 7f	         sta pc+1; -- sauve pch
.13cf	ad ff 7f	         lda rp  ; -- sauve rp
.13d2	48		         pha     ;s:rp
.13d3	ad fe 7f	         lda ra  ; -- sauve ra
.13d6	48		         pha     ;s:ra,rp
.13d7	8a		         txa     ; -- tfr rx
.13d8	48		         pha     ;s:rx,ra,rp
.13d9	98		         tya     ; -- tfr ry
.13da	48		         pha     ;s:ry,rx,ra,rp
.13db	ad fa 7f	         lda pc+1; -- replace l'adresse
.13de	48		         pha     ;s:pch,ry,rx,ra,rp
.13df	ad f9 7f	         lda pc  ; -- de retour.
.13e2	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.13e3	ad ff 7f	         lda rp  ; -- place les flags
.13e6	48		         pha     ;    sur le stack.
.13e7	ad fe 7f	         lda ra  ; -- recupere ra
.13ea	28		         plp     ; -- recupere flags.
.13eb	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.13ec			popregs
.13ec	08		         php
.13ed	8d fe 7f	         sta ra
.13f0	68		         pla
.13f1	8d ff 7f	         sta rp
.13f4	68		         pla     ;s:pch,ry,rx,ra,rp
.13f5	8d f9 7f	         sta pc  ; -- sauve pcl
.13f8	68		         pla     ;s:ry,rx,ra,rp
.13f9	8d fa 7f	         sta pc+1; -- sauve pch
.13fc	68		         pla     ;s:rx,ra,rp
.13fd	a8		         tay     ;recupere ry
.13fe	68		         pla     ;s:ra,rp
.13ff	aa		         tax     ;recupere rx
.1400	68		         pla     ;s:rp
.1401	8d fe 7f	         sta ra  ;recupere ra
.1404	68		         pla     ;s:
.1405	8d ff 7f	         sta rp  ;recupere les flags.
.1408	ad fa 7f	         lda pc+1;replace l'adresse de
.140b	48		         pha     ;s:pch
.140c	ad f9 7f	         lda pc  ;retour sur la pile
.140f	48		         pha     ;s:pcl,pch
.1410	ad ff 7f	         lda rp  ;recupere les flags
.1413	48		         pha     ;s:rp,pcl,pch
.1414	ad fe 7f	         lda ra  ;recupere ra
.1417	28		         plp     ;s:pcl,pch
.1418	60		         rts

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.1419			puts
.1419	20 4d 13	          jsr pushall
.141c	a0 00		          ldy #$00   ; y = offset
.141e	b1 fb		nextc     lda ($fb),y;lit un caractere
.1420	f0 09		          beq out    ;si 0 on sort
.1422	20 7a f2	          jsr chrout ;on l'affiche
.1425	20 66 15	          jsr inczp1 ;pointe le prochain
.1428	4c 1e 14	          jmp nextc  ; et l'affiche
.142b	20 86 13	out       jsr popall
.142e	60		          rts
.142f			putsyx
.142f	20 4d 13	          jsr pushall;sauve reg + zps
.1432	86 fb		          stx $fb    ;$yyxx dans
.1434	84 fc		          sty $fb+1  ; zp1
.1436	20 19 14	          jsr puts
.1439	20 86 13	          jsr popall ;recup reg + zps
.143c	60		          rts
.143d			putsxy
.143d	20 4d 13	        jsr pushall;sauve reg + zps
.1440	86 fb		        stx $fb    ;$yyxx dans
.1442	84 fc		        sty $fb+1  ; zp1
.1444	a0 00		        ldy #$00
.1446	b1 fb		        lda ($fb),y
.1448	aa		        tax
.1449	20 66 15	        jsr inczp1
.144c	b1 fb		        lda ($fb),y
.144e	20 66 15	        jsr inczp1
.1451	a8		        tay
.1452	20 a7 14	        jsr gotoxy
.1455	20 19 14	        jsr puts
.1458	20 86 13	        jsr popall ;recup reg + zps
.145b	60		        rts
.145c			putsc
.145c	08		          php       ;flag sur stack
.145d	48		          pha       ;acc sur stack
.145e	48		          pha       ;sauvegarde acc
.145f	ad 86 02	          lda kcol  ;recup coul. carac.
.1462	8d f8 7f	          sta curcol; et la sauvegarde
.1465	68		          pla       ;recup. acc
.1466	8d 86 02	          sta kcol  ;place coul. voulue
.1469	20 19 14	          jsr puts  ;affiche la chaine
.146c	ad f8 7f	          lda curcol;recup coul. carac.
.146f	8d 86 02	          sta kcol  ; et la replace
.1472	68		          pla       ;recup acc
.1473	28		          plp       ;recup flag
.1474	60		          rts
.1475			putscyx
.1475	08		          php       ;sauve registres
.1476	48		          pha       ; ...
.1477	48		          pha       ;sauve acc
.1478	ad 86 02	          lda kcol  ;recup couleur carac.
.147b	8d f8 7f	          sta curcol; et sauvegarde
.147e	68		          pla       ;recup acc
.147f	8d 86 02	          sta kcol  ;place couleur carac.
.1482	20 2f 14	          jsr putsyx;affiche la chaine
.1485	ad f8 7f	          lda curcol
.1488	8d 86 02	          sta kcol
.148b	68		          pla
.148c	28		          plp
.148d	60		          rts
.148e			putscxy
.148e	08		          php       ;sauve registres
.148f	48		          pha       ; ...
.1490	48		          pha       ;sauve acc
.1491	ad 86 02	          lda kcol  ;recup couleur carac.
.1494	8d f8 7f	          sta curcol; et sauvegarde
.1497	68		          pla       ;recup acc
.1498	8d 86 02	          sta kcol   ;place couleur carac.
.149b	20 2f 14	          jsr putsyx ;affiche la chaine
.149e	ad f8 7f	          lda curcol
.14a1	8d 86 02	          sta kcol
.14a4	68		          pla
.14a5	28		          plp
.14a6	60		          rts
.14a7			gotoxy
.14a7	20 bf 13	          jsr pushregs
.14aa	8a		          txa ; interchange x et y
.14ab	48		          pha ; ...
.14ac	98		          tya ; ...
.14ad	aa		          tax ; ...
.14ae	68		          pla ; ...
.14af	a8		          tay ; ...
.14b0	c0 00		txlow     cpy #0
.14b2	10 02		          bpl txhigh
.14b4	a2 00		          ldx #0
.14b6	e0 19		txhigh    cpx #25
.14b8	30 02		          bmi tylow
.14ba	a2 18		          ldx #24
.14bc	c0 00		tylow     cpy #0
.14be	10 02		          bpl tyhigh
.14c0	a0 00		          ldy #0
.14c2	c0 28		tyhigh    cpy #40
.14c4	30 02		          bmi allok
.14c6	a0 27		          ldy #39
.14c8	18		allok     clc
.14c9	20 0a e5	          jsr plot
.14cc	20 ec 13	          jsr popregs
.14cf	60		          rts
.14d0			putnch
.14d0	20 bf 13	        jsr pushregs
.14d3	20 7a f2	again   jsr chrout
.14d6	ca		        dex
.14d7	d0 fa		        bne again
.14d9	20 ec 13	        jsr popregs
.14dc	60		        rts
.14dd			strlen
.14dd	20 4d 13	        jsr pushall
.14e0	84 fc		        sty zp1+1
.14e2	86 fb		        stx zp1
.14e4	a0 00		        ldy #$00
.14e6	8c 8a 7f	        sty len
.14e9	b1 fb		next    lda (zp1),y
.14eb	f0 07		        beq out
.14ed	ee 8a 7f	        inc len
.14f0	c8		        iny
.14f1	4c e9 14	        jmp next
.14f4	20 86 13	out     jsr popall
.14f7	ad 8a 7f	        lda len
.14fa	60		        rts
.14fb			cursor
.14fb	20 bf 13	          jsr  pushregs
.14fe	90 12		          bcc  get    ;C=0 récupération.
.1500	20 0a e5	          jsr  plot  ;récupère position
.1503	8c 89 7f	          sty  cx     ;curseur et sauve
.1506	8e 88 7f	          stx  cy     ;dans vars locales.
.1509	ad 86 02	          lda  kcol   ;Sauve couleur
.150c	8d 87 7f	          sta  bcol   ; BASIC du texte.
.150f	4c 21 15	          jmp  out    ;Fini on sort.
.1512	ae 88 7f	get       ldx  cy     ;C=1, charge x
.1515	ac 89 7f	          ldy  cx     ; ligne, y col.
.1518	20 0a e5	          jsr  plot  ;Position curseur.
.151b	ad 87 7f	          lda  bcol   ;replace couleur
.151e	8d 86 02	          sta  kcol ; basic sauvegardé.
.1521	20 ec 13	out       jsr  popregs
.1524	60		          rts
.1525			curget
.1525			cursave
.1525	08		          php
.1526	38		          sec
.1527	20 fb 14	          jsr  cursor
.152a	28		          plp
.152b	60		          rts
.152c			curput
.152c			currest
.152c	08		          php
.152d	18		          clc
.152e	20 fb 14	          jsr  cursor
.1531	28		          plp
.1532	60		          rts
.1533			isprnable
.1533	08		          php
.1534	c9 a0		          cmp  #160
.1536	b0 0b		          bcs  yes
.1538	c5 85		          cmp  133
.153a	b0 04		          bcs  no
.153c	c9 20		          cmp  #32
.153e	b0 03		          bcs  yes
.1540	28		no        plp
.1541	18		          clc
.1542	60		          rts
.1543	28		yes       plp
.1544	38		          sec
.1545	60		          rts

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.1546			blkfill
.1546	20 4d 13	bf0     jsr pushall
.1549	84 fc		        sty zp1+1
.154b	a0 00		        ldy #$00
.154d	84 fb		        sty zp1
.154f	91 fb		bf1     sta (zp1),y
.1551	c8		        iny
.1552	d0 fb		        bne bf1
.1554	20 86 13	        jsr popall
.1557	60		        rts
.1558			memfill
.1558	20 bf 13	        jsr pushregs
.155b	20 46 15	mf1     jsr blkfill
.155e	c8		        iny
.155f	ca		        dex
.1560	d0 f9		        bne mf1
.1562	20 ec 13	        jsr popregs
.1565	60		        rts
.1566			inczp1
.1566	08		         php
.1567	e6 fb		         inc zp1
.1569	d0 02		         bne repzp1
.156b	e6 fc		         inc zp1+1
.156d	28		repzp1   plp
.156e	60		         rts
.156f			inczp2
.156f	08		         php
.1570	e6 fd		         inc zp2
.1572	d0 02		         bne repzp2
.1574	e6 fe		         inc zp2+1
.1576	28		repzp2   plp
.1577	60		         rts
.1578			deczp1
.1578	08		         php
.1579	48		         pha
.157a	a5 fb		         lda zp1
.157c	d0 02		         bne noemp
.157e	c6 fc		         dec zp1+1
.1580	c6 fb		noemp    dec zp1
.1582	68		         pla
.1583	28		         plp
.1584	60		         rts
.1585			deczp2
.1585	08		         php
.1586	48		         pha
.1587	a5 fd		         lda zp2
.1589	d0 02		         bne noemp
.158b	c6 fe		         dec zp2+1
.158d	c6 fd		noemp    dec zp2
.158f	68		         pla
.1590	28		         plp
.1591	60		         rts
.1592			rolzp1
.1592	08		        php
.1593	48		        pha
.1594	18		        clc
.1595	a5 fb		        lda zp1
.1597	2a		        rol
.1598	85 fb		        sta zp1
.159a	a5 fc		        lda zp1+1
.159c	2a		        rol
.159d	85 fc		        sta zp1+1
.159f	68		        pla
.15a0	28		        plp
.15a1			rorzp1
.15a1	08		        php
.15a2	48		        pha
.15a3	18		        clc
.15a4	a5 fc		        lda zp1+1
.15a6	6a		        ror
.15a7	85 fc		        sta zp1+1
.15a9	a5 fb		        lda zp1
.15ab	6a		        ror
.15ac	85 fb		        sta zp1
.15ae	68		        pla
.15af	28		        plp
.15b0			rolzp2
.15b0	08		        php
.15b1	48		        pha
.15b2	18		        clc
.15b3	a5 fd		        lda zp2
.15b5	2a		        rol
.15b6	85 fd		        sta zp2
.15b8	a5 fe		        lda zp2+1
.15ba	2a		        rol
.15bb	85 fe		        sta zp2+1
.15bd	68		        pla
.15be	28		        plp
.15bf			rorzp2
.15bf	08		        php
.15c0	48		        pha
.15c1	18		        clc
.15c2	a5 fe		        lda zp2+1
.15c4	6a		        ror
.15c5	85 fe		        sta zp2+1
.15c7	a5 fd		        lda zp2
.15c9	6a		        ror
.15ca	85 fd		        sta zp2
.15cc	68		        pla
.15cd	28		        plp
.15ce			yxtoptr
.15ce	8c f8 7f	        sty memptr+1
.15d1	8e f7 7f	        stx memptr
.15d4	60		        rts
.15d5			ptrtoyx
.15d5	08		        php
.15d6	ac f8 7f	        ldy memptr+1
.15d9	ae f7 7f	        ldx memptr
.15dc	28		        plp
.15dd	60		        rts
.15de			incptr
.15de	08		        php
.15df	ee f7 7f	        inc memptr
.15e2	d0 03		        bne norep
.15e4	ee f8 7f	        inc memptr+1
.15e7	28		norep   plp
.15e8	60		        rts
.15e9			decptr
.15e9	08		        php
.15ea	48		        pha
.15eb	ad f7 7f	        lda memptr
.15ee	d0 03		        bne noemp
.15f0	ee f8 7f	        inc memptr+1
.15f3	ee f7 7f	noemp   inc memptr
.15f6	68		        pla
.15f7	28		        plp
.15f8	60		        rts
.15f9			incptr8
.15f9	08		        php
.15fa	48		        pha
.15fb	98		        tya
.15fc	48		        pha
.15fd	a0 08		        ldy #8
.15ff	20 de 15	again   jsr incptr
.1602	88		        dey
.1603	d0 fa		        bne again
.1605	68		        pla
.1606	a8		        tay
.1607	68		        pla
.1608	28		        plp
.1609	60		        rts
.160a			loop
.160a	ce f1 7f	               dec  loopcount
.160d	d0 03		               bne  norep
.160f	ce f2 7f	               dec  loopcount+1
.1612	ad f1 7f	norep          lda  loopcount
.1615	c9 00		               cmp  #$00
.1617	d0 05		               bne  out
.1619	4d f2 7f	               eor  loopcount+1
.161c	c9 ff		               cmp  #$ff
.161e	60		out            rts

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.161f			addtoword
.161f			addatoyx
.161f	08		        php
.1620	48		        pha
.1621	8c 98 7f	        sty reponse+1
.1624	8e 97 7f	        stx reponse
.1627	18		        clc
.1628	6d 97 7f	        adc reponse
.162b	90 03		        bcc norep
.162d	ee 98 7f	        inc reponse+1
.1630	8d 97 7f	norep   sta reponse
.1633	ac 98 7f	        ldy reponse+1
.1636	ae 97 7f	        ldx reponse
.1639	68		        pla
.163a	28		        plp
.163b	60		        rts
.163c			subtoword
.163c			subatoyx
.163c	08		        php
.163d	48		        pha
.163e	8c 98 7f	        sty reponse+1
.1641	8e 97 7f	        stx reponse
.1644	38		        sec
.1645	ed 97 7f	        sbc reponse
.1648	b0 03		        bcs noemp
.164a	ce 98 7f	        dec reponse+1
.164d	8d 97 7f	noemp   sta reponse
.1650	ac 98 7f	        ldy reponse+1
.1653	ae 97 7f	        ldx reponse
.1656	68		        pla
.1657	28		        plp
.1658	60		        rts

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.1659			putyxhex
.1659	20 4d 13	        jsr pushall
.165c	98		        tya
.165d	48		        pha
.165e	20 dc 16	        jsr lsr4bits
.1661	20 ef 16	        jsr nibtohex
.1664	8d ec 7f	        sta hexstr+0
.1667	68		        pla
.1668	20 ef 16	        jsr nibtohex
.166b	8d ed 7f	        sta hexstr+1
.166e	8a		        txa
.166f	20 8e 16	        jsr atohex
.1672	a2 ec		        ldx #<hexstr+0
.1674	a0 7f		        ldy #>hexstr+0
.1676	20 2f 14	        jsr putsyx
.1679	20 86 13	        jsr popall
.167c	60		        rts
.167d			putahex
.167d	20 bf 13	        jsr pushregs
.1680	20 8e 16	        jsr atohex
.1683	a2 ee		        ldx #<hexstr+2
.1685	a0 7f		        ldy #>hexstr+2
.1687	20 2f 14	        jsr putsyx
.168a	20 ec 13	        jsr popregs
.168d	60		        rts
.168e			atohex
.168e	08		        php
.168f	48		        pha
.1690	48		        pha
.1691	20 dc 16	        jsr lsr4bits
.1694	20 ef 16	        jsr nibtohex
.1697	8d ee 7f	        sta hexstr+2
.169a	68		        pla
.169b	20 ef 16	        jsr nibtohex
.169e	8d ef 7f	        sta hexstr+3
.16a1	a9 00		        lda #$00
.16a3	8d f0 7f	        sta hexstr+4
.16a6	68		        pla
.16a7	28		        plp
.16a8	60		        rts
.16a9			putabin
.16a9	20 bf 13	          jsr     pushregs
.16ac	20 ba 16	          jsr     atobin
.16af	a2 df		          ldx     #<binstr
.16b1	a0 7f		          ldy     #>binstr
.16b3	20 2f 14	          jsr     putsyx
.16b6	20 ec 13	          jsr     popregs
.16b9	60		          rts
.16ba			atobin
.16ba	20 bf 13	          jsr  pushregs
.16bd	a2 08		          ldx  #8
.16bf	a0 00		          ldy  #0
.16c1	18		          clc
.16c2	2a		nextbit   rol
.16c3	48		          pha
.16c4	69 00		          adc  #$00
.16c6	29 01		          and  #$01
.16c8	20 ef 16	          jsr  nibtohex
.16cb	99 df 7f	          sta  binstr,y
.16ce	68		          pla
.16cf	c8		          iny
.16d0	ca		          dex
.16d1	d0 ef		          bne  nextbit
.16d3	a9 00		          lda  #0
.16d5	99 df 7f	          sta  binstr,y
.16d8	20 ec 13	          jsr  popregs
.16db	60		          rts
.16dc			lsr4bits
.16dc	08		          php
.16dd	4a		          lsr a
.16de	4a		          lsr a
.16df	4a		          lsr a
.16e0	4a		          lsr a
.16e1	28		          plp
.16e2	60		          rts
.16e3			nibtohexb
.16e3	08		        php
.16e4	29 0f		        and #$0f
.16e6	f8		        sed
.16e7	18		        clc
.16e8	69 90		        adc #$90
.16ea	69 40		        adc #$40
.16ec	d8		        cld
.16ed	28		        plp
.16ee	60		        rts
.16ef			nibtohex
.16ef	08		        php
.16f0	8c 0e 17	        sty myy
.16f3	29 0f		        and #$0f
.16f5	a8		        tay
.16f6	b9 fe 16	        lda hextbl,y
.16f9	ac 0e 17	        ldy myy
.16fc	28		        plp
.16fd	60		        rts
>16fe	30 31 32 33	hextbl  .byte $30,$31,$32,$33,$34
>1702	34
>1703	35 36 37 38	        .byte $35,$36,$37,$38,$39
>1707	39
>1708	41 42 43 44	        .byte $41,$42,$43,$44,$45
>170c	45
>170d	46		        .byte $46
>170e	00		myy     .byte $00
.170f			bytestohex
.170f	20 4d 13	        jsr pushall
.1712	84 fc		        sty zp1+1
.1714	86 fb		        stx zp1
.1716	08		            php
.1717	48		            pha
.1718	a9 20		            lda #32
.171a	20 7a f2	            jsr chrout
.171d	68		            pla
.171e	28		            plp
.171f	08		            php
.1720	48		            pha
.1721	a9 05		            lda #5
.1723	20 7a f2	            jsr chrout
.1726	68		            pla
.1727	28		            plp
.1728	08		            php
.1729	48		            pha
.172a	a9 24		            lda #36
.172c	20 7a f2	            jsr chrout
.172f	68		            pla
.1730	28		            plp
.1731	20 59 16	        jsr putyxhex   ; prn adreponsese
.1734	08		            php
.1735	48		            pha
.1736	a9 20		            lda #$20
.1738	20 7a f2	            jsr chrout
.173b	68		            pla
.173c	28		            plp
.173d	08		            php
.173e	48		            pha
.173f	a9 9f		            lda #159
.1741	20 7a f2	            jsr chrout
.1744	68		            pla
.1745	28		            plp
.1746	a0 00		        ldy #$00
.1748	aa		        tax
.1749	8c d0 7f	another sty offset
.174c	b1 fb		        lda (zp1),y
.174e	20 7d 16	        jsr putahex
.1751	48		        pha
.1752	20 71 17	        jsr petsciiaddr
.1755	68		        pla
.1756	8d 00 04	petscii sta $0400
.1759	48		        pha
.175a	a9 0d		        lda #$0d
.175c	8d 00 d8	petcol  sta $d800
.175f	68		        pla
.1760	08		            php
.1761	48		            pha
.1762	a9 20		            lda #$20
.1764	20 7a f2	            jsr chrout
.1767	68		            pla
.1768	28		            plp
.1769	c8		        iny
.176a	ca		        dex
.176b	d0 dc		        bne another
.176d	20 86 13	        jsr popall
.1770	60		        rts
.1771			petsciiaddr
.1771	20 bf 13	        jsr pushregs
.1774	a9 1f		        lda #31
.1776	18		        clc
.1777	6d d0 7f	        adc offset
.177a	20 1f 16	        jsr addatoyx
.177d	8c 58 17	        sty petscii+2
.1780	8e 57 17	        stx petscii+1
.1783	8e 5d 17	        stx petcol+1
.1786	98		        tya
.1787	29 fb		        and #%11111011 ;#%00000100
.1789	09 d8		        ora #$d8
.178b	8d 5e 17	        sta petcol+2
.178e	a8		        tay
.178f	20 ec 13	        jsr popregs
.1792	60		        rts
.1793			strhexval
.1793	20 4d 13	        jsr pushall ; sauve registre
.1796	84 fc		        sty zp1+1   ; ptr dans zp1
.1798	86 fb		        stx zp1
.179a	20 dd 14	        jsr strlen  ;len de $(yyxx)->a
.179d	f0 3d		        beq oute    ; si 0 erreur C=1
.179f	a0 00		        ldy #$00    ; offset a 0
.17a1	8c 98 7f	        sty reponse+1; reponse a zero
.17a4	8c 97 7f	        sty reponse ;    ...
.17a7	b1 fb		nextc   lda (zp1),y ;charge un caractere
.17a9	f0 26		        beq out     ;On  a fini
.17ab	c0 00		        cpy #$00    ;si c'est le premier
.17ad	f0 07		        beq norol   ; pas de rol
.17af	48		        pha         ;
.17b0	a9 04		        lda #$04    ;rol de 4 pos
.17b2	20 9c 18	        jsr rolword ;
.17b5	68		        pla         ;
.17b6	09 20		norol   ora #%00100000
.17b8	38		        sec
.17b9	e9 30		        sbc #$30
.17bb	c9 0a		        cmp #$0a
.17bd	90 07		        bcc lt10
.17bf	38		        sec
.17c0	e9 27		        sbc #$27
.17c2	c9 10		        cmp #$10
.17c4	b0 16		        bcs oute
.17c6	0d 97 7f	lt10    ora reponse
.17c9	8d 97 7f	        sta reponse
.17cc	c8		        iny
.17cd	c0 04		        cpy #$04
.17cf	d0 d6		        bne nextc
.17d1	20 86 13	out     jsr popall
.17d4	18		        clc          ;Carry 0 = good
.17d5	ac 98 7f	        ldy reponse+1
.17d8	ae 97 7f	        ldx reponse
.17db	60		        rts
.17dc	20 86 13	oute    jsr popall
.17df	38		        sec
.17e0	60		        rts
.17e1			showra
.17e1	20 bf 13	          jsr  pushregs
.17e4	ac 86 02	          ldy  kcol
.17e7	08		            php
.17e8	48		            pha
.17e9	a9 90		            lda #snoir
.17eb	20 7a f2	            jsr chrout
.17ee	68		            pla
.17ef	28		            plp
.17f0	20 33 15	          jsr  isprnable
.17f3	b0 13		          bcs  okprn
.17f5	48		          pha
.17f6	08		            php
.17f7	48		            pha
.17f8	a9 1c		            lda #srouge
.17fa	20 7a f2	            jsr chrout
.17fd	68		            pla
.17fe	28		            plp
.17ff	a9 2e		          lda  #'.'
.1801	20 7a f2	          jsr  chrout
.1804	68		          pla
.1805	4c 0b 18	          jmp  noprn
.1808	20 7a f2	okprn     jsr  chrout
.180b			noprn
.180b	08		            php
.180c	48		            pha
.180d	a9 20		            lda #32
.180f	20 7a f2	            jsr chrout
.1812	68		            pla
.1813	28		            plp
.1814	08		            php
.1815	48		            pha
.1816	a9 1f		            lda #sbleu
.1818	20 7a f2	            jsr chrout
.181b	68		            pla
.181c	28		            plp
.181d	08		            php
.181e	48		            pha
.181f	a9 24		            lda #36
.1821	20 7a f2	            jsr chrout
.1824	68		            pla
.1825	28		            plp
.1826	20 7d 16	          jsr putahex
.1829	08		            php
.182a	48		            pha
.182b	a9 20		            lda #32
.182d	20 7a f2	            jsr chrout
.1830	68		            pla
.1831	28		            plp
.1832	08		            php
.1833	48		            pha
.1834	a9 1c		            lda #srouge
.1836	20 7a f2	            jsr chrout
.1839	68		            pla
.183a	28		            plp
.183b	08		            php
.183c	48		            pha
.183d	a9 25		            lda #37
.183f	20 7a f2	            jsr chrout
.1842	68		            pla
.1843	28		            plp
.1844	20 a9 16	          jsr putabin
.1847	08		            php
.1848	48		            pha
.1849	a9 20		            lda #32
.184b	20 7a f2	            jsr chrout
.184e	68		            pla
.184f	28		            plp
.1850	08		            php
.1851	48		            pha
.1852	a9 9c		            lda #smauve
.1854	20 7a f2	            jsr chrout
.1857	68		            pla
.1858	28		            plp
.1859	48		          pha
.185a	aa		          tax
.185b	a9 00		          lda #$00
.185d	20 cd dd	          jsr fiaxtf1
.1860	68		          pla
.1861	8c 86 02	          sty kcol
.1864	20 ec 13	          jsr popregs
.1867	60		          rts
.1868			putahexdec
.1868	20 bf 13	          jsr pushregs
.186b	20 25 15	          jsr  curget    ; Sauvegarde la position du curseur.
.186e	20 bf 13	        jsr pushregs
.1871	a0 01		        ldy #1
.1873	a2 16		        ldx #22
.1875	18		        clc
.1876	20 0a e5	        jsr plot
.1879	20 ec 13	        jsr popregs
.187c	08		            php
.187d	48		            pha
.187e	a9 20		            lda #32
.1880	20 7a f2	            jsr chrout
.1883	68		            pla
.1884	28		            plp
.1885	20 e1 17	          jsr  showra    ; Affiche .a en ascii, hexa, bin et dec.
.1888	c9 63		          cmp  #99       ; Estce que le code ascii est > 99 dec.
.188a	10 09		          bpl  nospc     ; Non, on saute.
.188c	08		            php
.188d	48		            pha
.188e	a9 20		            lda #32
.1890	20 7a f2	            jsr chrout
.1893	68		            pla
.1894	28		            plp
.1895	20 2c 15	nospc     jsr  curput    ; Replkace le curseur à sa position initiale.
.1898	20 ec 13	          jsr popregs
.189b	60		          rts
.189c			rolword
.189c	20 bf 13	        jsr pushregs
.189f	a8		        tay
.18a0	18		again   clc
.18a1	2e 97 7f	        rol reponse
.18a4	2e 98 7f	        rol reponse+1
.18a7	88		        dey
.18a8	d0 f6		        bne again
.18aa	20 ec 13	        jsr popregs
.18ad	60		        rts

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.18ae			clrkbbuf
.18ae	08		          php
.18af	48		          pha
.18b0	a9 00		          lda #0
.18b2	85 c6		          sta 198
.18b4	20 e1 ff	          jsr $ffe1
.18b7	68		          pla
.18b8	28		          plp
.18b9	60		          rts
.18ba			waitstop
.18ba	08		          php    ;\ sauve les flags
.18bb	48		          pha    ;/  et l'acc.
.18bc	20 ae 18	          jsr clrkbbuf
.18bf	20 70 f7	wait      jsr stop ; Veri [run/stop]
.18c2	d0 fb		          bne wait ;loop pas pesee.
.18c4	68		          pla    ;\ recup. acc et
.18c5	28		          plp    ;/  les flags.
.18c6	60		          rts
.18c7			anykey
.18c7	08		          php
.18c8	48		          pha
.18c9	20 ae 18	          jsr clrkbbuf
.18cc	a5 cb		wait      lda 203    ;lit la matrice de
.18ce	c9 40		          cmp #64    ; 64 = aucune clef
.18d0	f0 fa		          beq wait   ; on en attend une.
.18d2	20 db 18	          jsr kbfree ; Clavier relache.
.18d5	20 ae 18	          jsr clrkbbuf
.18d8	68		          pla
.18d9	28		          plp
.18da	60		          rts
.18db			kbfree
.18db	08		        php
.18dc	48		        pha
.18dd	a5 cb		wait    lda 203    ; lit la matrice
.18df	c9 40		        cmp #64    ; 64 = aucune clef
.18e1	d0 fa		        bne wait   ; attend la relache
.18e3	68		        pla
.18e4	28		        plp
.18e5	60		        rts
.18e6			getkey
.18e6	08		        php
.18e7	20 e1 ff	        jsr $ffe1
.18ea	20 f5 f1	try     jsr getin  ;tente de lire
.18ed	c9 00		        cmp #0     ; 0 si aucune.
.18ef	f0 f9		        beq try    ; on reessaye
.18f1	28		        plp
.18f2	60		        rts
.18f3			waitkey
.18f3	08		        php
.18f4	48		        pha
.18f5	8d 8b 7f	        sta clef   ;Sauve clef voulue
.18f8	20 ae 18	        jsr clrkbbuf
.18fb	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.18fe	cd 8b 7f	        cmp clef   ;Compare avec clef
.1901	d0 f8		        bne wait   ;Pas la bonne.
.1903	68		        pla
.1904	28		        plp
.1905	60		        rts
.1906			waitspace
.1906	a9 20		          lda #$20
.1908	20 f3 18	          jsr waitkey
.190b	20 ae 18	          jsr clrkbbuf
.190e	60		          rts
.190f			showkey
.190f	20 bf 13	        jsr pushregs
.1912	38		        sec
.1913	20 0a e5	        jsr plot
.1916	8e 8d 7f	        stx curx
.1919	8c 8c 7f	        sty cury
.191c	20 bf 13	        jsr pushregs
.191f	a0 00		        ldy #0
.1921	a2 16		        ldx #22
.1923	18		        clc
.1924	20 0a e5	        jsr plot
.1927	20 ec 13	        jsr popregs
.192a	20 7a f2	        jsr chrout
.192d	20 e1 17	        jsr showra
.1930	18		        clc
.1931	ac 8c 7f	        ldy cury
.1934	ae 8d 7f	        ldx curx
.1937	20 0a e5	        jsr plot
.193a	20 ec 13	        jsr popregs
.193d	60		        rts

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-screen.asm

.193e			scrnsave
.193e	20 4d 13	        jsr pushall
.1941	20 96 19	        jsr setcarptr
.1944	20 64 19	        jsr zp1tozp2
.1947	20 ad 19	        jsr setcolptr
.194a	20 64 19	        jsr zp1tozp2
.194d	20 86 13	        jsr popall
.1950	60		        rts
.1951			scrnrest
.1951	20 4d 13	        jsr pushall
.1954	20 96 19	        jsr setcarptr
.1957	20 7d 19	        jsr zp2tozp1
.195a	20 ad 19	        jsr setcolptr
.195d	20 7d 19	        jsr zp2tozp1
.1960	20 86 13	        jsr popall
.1963	60		        rts
.1964			zp1tozp2
.1964	20 4d 13	        jsr pushall
.1967	a2 02		        ldx #>scrlen
.1969	a0 00		        ldy #<scrlen
.196b	b1 fb		nextcar lda (zp1),y
.196d	91 fd		        sta (zp2),y
.196f	c8		        iny
.1970	d0 f9		        bne nextcar
.1972	e6 fc		        inc zp1+1
.1974	e6 fe		        inc zp2+1
.1976	ca		        dex
.1977	d0 f2		        bne nextcar
.1979	20 86 13	        jsr popall
.197c	60		        rts
.197d			zp2tozp1
.197d	20 4d 13	        jsr pushall
.1980	a2 02		        ldx #>scrlen
.1982	a0 00		        ldy #<scrlen
.1984	b1 fd		nextcar lda (zp2),y
.1986	91 fb		        sta (zp1),y
.1988	c8		        iny
.1989	d0 f9		        bne nextcar
.198b	e6 fc		        inc zp1+1
.198d	e6 fe		        inc zp2+1
.198f	ca		        dex
.1990	d0 f2		        bne nextcar
.1992	20 86 13	        jsr popall
.1995	60		        rts
.1996			setcarptr
.1996	20 bf 13	        jsr pushregs
.1999	a9 00		        lda #<scrtxt
.199b	85 fb		        sta zp1
.199d	a9 10		        lda #>scrtxt
.199f	85 fc		        sta zp1+1
.19a1	a9 84		        lda #<scrncar
.19a3	85 fd		        sta zp2
.19a5	a9 7d		        lda #>scrncar
.19a7	85 fe		        sta zp2+1
.19a9	20 ec 13	        jsr popregs
.19ac	60		        rts
.19ad			setcolptr
.19ad	20 bf 13	        jsr pushregs
.19b0	a9 00		        lda #<scrcol
.19b2	85 fb		        sta zp1
.19b4	a9 94		        lda #>scrcol
.19b6	85 fc		        sta zp1+1
.19b8	a9 84		        lda #<scrncol
.19ba	85 fd		        sta zp2
.19bc	a9 7b		        lda #>scrncol
.19be	85 fe		        sta zp2+1
.19c0	20 ec 13	        jsr popregs
.19c3	60		        rts
.19c4			fillscreen
.19c4	20 4d 13	          jsr pushall
.19c7	a2 03		          ldx #$03
.19c9	a0 00		          ldy #$00
.19cb	a9 66		          lda #102
.19cd	99 00 10	again     sta scrtxt,y
.19d0	99 00 11	          sta scrtxt+256,y
.19d3	48		          pha
.19d4	8a		          txa
.19d5	99 00 94	          sta scrcol,y
.19d8	99 00 95	          sta scrcol+256,y
.19db	68		          pla
.19dc	c8		          iny
.19dd	d0 ee		          bne again
.19df	20 86 13	          jsr popall
.19e2	60		          rts

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=$8000			libre    = $8000   ; *+3085
=32767			rp       = libre-$01;1 byte $cfff
=32766			ra       = rp-1     ;1 byte $cffe
=32765			rx       = ra-1     ;1 byte $cffd
=32764			ry       = rx-1     ;1 byte $cffc
=32763			rs       = ry-1     ;1 byte $cffb
=32761			pc       = rs-2     ;2 byte $cff9-$cffa
=32760			curcol   = pc-1     ;1 byte $cff6
=32759			memptr   = curcol-1;1 word $cff7-$cff8
=32757			src      = memptr-2
=32755			dst      = memptr-4
=32753			loopcount = memptr-6
=32753			hexv     = loopcount
.19e3			a2hexstr
=32748			hexstr   = hexv-$05 ;5 byte
=32747			a2hexpfx = hexv-$06 ;1 byte
=32746			a2hexpy  = hexv-$07 ;1 byte
=32745			a2hexpx  = hexv-$08 ;1 byte
=32745			a2hexpos = hexv-$08 ;0 byte
=32744			a2hexcol = hexv-$09 ;1 byte
=32744			binv     = a2hexcol
=32735			binstr   = binv-$09 ;9 byte
=32734			a2binpfx = binv-$0a ;1 byte
=32733			a2binpy  = binv-$0b ;1 byte
=32732			a2binpx  = binv-$0c ;1 byte
=32732			a2binpos = binv-$0c ;0 byte
=32731			a2bincol = binv-$0d ;1 byte
=32731			decv     = a2bincol
=32725			decstr   = decv-$06 ;6 byte
=32724			a2decpfx = decv-$07 ;1 byte
=32723			a2decpy  = decv-$08 ;1 byte
=32722			a2decpx  = decv-$09 ;1 byte
=32722			a2decpos = decv-$09 ;0 byte
=32721			a2deccol = decv-$0a ;1 byte
=32720			offset   = decv-$0b ;1 byte
=32720			fltv     = offset
=32714			fvar1    = fltv-6  ; 6 byte
=32708			fvar2    = fltv-12 ; 6 byte
=32688			float1   = fltv-32 ;20 byte
=32668			float2   = fltv-52 ;20 byte
=32667			tval1    = fltv-53 ; 1 byte
=32665			tval2    = fltv-55 ; 2 byte
=32663			reponse  = tval2-2 ; 2 byte
=32663			edbox    = reponse
=32662			cleft    = edbox-1 ;1 byte
=32661			cright   = edbox-2 ;1 byte
=32660			cmid     = edbox-3 ;1 byte
=32659			dbtop    = edbox-4 ;1 byte
=32658			dbleft   = edbox-5 ;1 byte
=32657			dbwdth   = edbox-6 ;1 byte
=32656			dbhght   = edbox-7 ;1 byte
=32655			dbcoul   = edbox-8 ;1 byte
=32654			dbclin   = edbox-9 ;1 byte
=32654			ekeyb    = dbclin
=32653			curx     = ekeyb-1 ;1 byte
=32652			cury     = ekeyb-2 ;1 byte
=32651			clef     = ekeyb-3 ;1 byte
=32650			len      = clef-1  ;1 byte
=32649			cx       = clef-2  ;1 byte
=32648			cy       = clef-3  ;1 byte
=32647			bcol     = clef-4  ;1 byte
=32647			escr     = bcol         ;2051 bytes
=32646			loops    = escr-1       ;   1 byte
=32644			loop16   = loops-2      ;   2 byte
=32132			scrncar  = loop16-$200  ;  1k byte
=31620			scrncol  = scrncar-$200 ;  1k byte
=31620			diskvar = scrncol
=31618			ddatas  = diskvar-2 ;2 byte Data start
=31616			ddatae  = diskvar-4 ;2 byte Data end
=31615			ddev    = diskvar-5 ;1 byte Dev number
=31614			dlfsno  = diskvar-6 ;1 byte Lfs
=31612			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=31611			dfnlen  = diskvar-9 ;1 byte lenfilename
=31610			genbyte1 = dfnlen-1 ; 1 byte
=31608			genword1 = dfnlen-3 ; 2 byte
=31607			endofvars = genword1-1

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm

.19e3			R

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			ffac1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			ffac1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; f1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; f1=atn(f1).

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.19e3	4c 46 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: soundtest.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vic.asm

=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vicbas    = $900a;NRRRRRRR
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vicalt    = $900b;OSSSSSSS
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vicsop    = $900c;PTTTTTTT
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vicnoi    = $900d;QUUUUUUU
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vicvol    = $900e;WWWWVVVV
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$08			vinv      = vorange
=133			v1do1     =    133  ; 32.703-  32.746- 0.131 %
=140			v1dod1    =    140  ; 34.648-  34.739- 0.264 %
=146			v1re1     =    146  ; 36.708-  36.651- 0.155 %
=152			v1red1    =    152  ; 38.891-  38.786- 0.269 %
=158			v1mi1     =    158  ; 41.203-  41.186- 0.043 %
=163			v1fa1     =    163  ; 43.654-  43.424- 0.526 %
=169			v1fad1    =    169  ; 46.249-  46.453- 0.442 %
=173			v1so1     =    173  ; 48.999-  48.720- 0.571 %
=178			v1so1d    =    178  ; 51.913-  51.883- 0.058 %
=182			v1la1     =    182  ; 55.000-  54.726- 0.498 %
=186			v1lad1    =    186  ; 58.270-  57.899- 0.638 %
=190			v1si1     =    190  ; 61.735-  61.462- 0.444 %
=194			v1do2     =    194  ; 65.406-  65.492- 0.131 %
=197			v1dod2    =    197  ; 69.296-  69.478- 0.264 %
=201			v1re2     =    201  ; 73.416-  73.303- 0.155 %
=204			v1red2    =    204  ; 77.782-  77.573- 0.269 %
=207			v1mi2     =    207  ; 82.407-  82.371- 0.043 %
=209			v1fa2     =    209  ; 87.307-  86.848- 0.526 %
=212			v1fad2    =    212  ; 92.499-  92.907- 0.442 %
=214			v1so2     =    214  ; 97.999-  97.439- 0.571 %
=217			v1so2d    =    217  ;103.826- 103.766- 0.058 %
=219			v1la2     =    219  ;110.000- 109.452- 0.498 %
=221			v1lad2    =    221  ;116.541- 115.797- 0.638 %
=223			v1si2     =    223  ;123.471- 122.923- 0.444 %
=224			v1do3     =    224  ;130.813- 130.984- 0.131 %
=226			v1dod3    =    226  ;138.591- 138.957- 0.264 %
=228			v1re3     =    228  ;146.832- 146.606- 0.155 %
=229			v1red3    =    229  ;155.563- 155.146- 0.269 %
=231			v1mi3     =    231  ;164.814- 164.742- 0.043 %
=232			v1fa3     =    232  ;174.614- 173.696- 0.526 %
=233			v1fad3    =    233  ;184.997- 185.814- 0.442 %
=235			v1so3     =    235  ;195.998- 194.878- 0.571 %
=236			v1sod3    =    236  ;207.652- 207.532- 0.058 %
=237			v1la3     =    237  ;220.000- 218.904- 0.498 %
=238			v1lad3    =    238  ;233.082- 231.594- 0.638 %
=239			v1si3     =    239  ;246.942- 245.846- 0.444 %
=240			v1do4     =    240  ;261.626- 261.967- 0.131 %
=0			v1dod4    =      0  ;277.183- 275.517- 0.601 %
=0			v1re4     =      0  ;293.665- 295.926- 0.770 %
=242			v1red4    =    242  ;311.127- 313.333- 0.709 %
=243			v1mi4     =    243  ;329.628- 332.917- 0.998 %
=0			v1fa4     =      0  ;349.228- 347.391- 0.526 %
=244			v1fad4    =    244  ;369.994- 371.628- 0.442 %
=245			v1so4     =    245  ;391.995- 389.756- 0.571 %
=0			v1sod4    =      0  ;415.305- 420.526- 1.257 %
=246			v1la4     =    246  ;440.000- 443.889- 0.884 %
=0			v1lad4    =      0  ;466.164- 470.000- 0.823 %
=247			v1si4     =    247  ;493.883- 499.375- 1.112 %
=0			v1do5     =      0  ;523.251- 515.484- 1.484 %
=0			v1dod5    =      0  ;554.365- 551.034- 0.601 %
=0			v1re5     =      0  ;587.329- 591.852- 0.770 %
=0			v1red5    =      0  ;622.254- 614.615- 1.228 %
=249			v1mi5     =    249  ;659.255- 665.833- 0.998 %
=0			v1fa5     =      0  ;698.456- 694.783- 0.526 %
=0			v1fad5    =      0  ;739.989- 726.364- 1.841 %
=250			v1so5     =    250  ;783.991- 799.000- 1.914 %
=0			v1sod5    =      0  ;830.609- 841.053- 1.257 %
=0			v1la5     =      0  ;880.000- 887.778- 0.884 %
=0			v1lad5    =      0  ;932.327- 940.000- 0.823 %
=133			v2do2     =    133  ; 65.406-  65.492- 0.131 %
=140			v2dod2    =    140  ; 69.296-  69.478- 0.264 %
=146			v2re2     =    146  ; 73.416-  73.303- 0.155 %
=152			v2red2    =    152  ; 77.782-  77.573- 0.269 %
=158			v2mi2     =    158  ; 82.407-  82.371- 0.043 %
=163			v2fa2     =    163  ; 87.307-  86.848- 0.526 %
=169			v2fad2    =    169  ; 92.499-  92.907- 0.442 %
=173			v2so2     =    173  ; 97.999-  97.439- 0.571 %
=178			v2sod2    =    178  ;103.826- 103.766- 0.058 %
=182			v2la2     =    182  ;110.000- 109.452- 0.498 %
=186			v2lad2    =    186  ;116.541- 115.797- 0.638 %
=190			v2si2     =    190  ;123.471- 122.923- 0.444 %
=194			v2do3     =    194  ;130.813- 130.984- 0.131 %
=197			v2dod3    =    197  ;138.591- 138.957- 0.264 %
=201			v2re3     =    201  ;146.832- 146.606- 0.155 %
=204			v2red3    =    204  ;155.563- 155.146- 0.269 %
=207			v2mi3     =    207  ;164.814- 164.742- 0.043 %
=209			v2fa3     =    209  ;174.614- 173.696- 0.526 %
=212			v2fad3    =    212  ;184.997- 185.814- 0.442 %
=214			v2so3     =    214  ;195.998- 194.878- 0.571 %
=217			v2sod3    =    217  ;207.652- 207.532- 0.058 %
=219			v2la3     =    219  ;220.000- 218.904- 0.498 %
=221			v2lad3    =    221  ;233.082- 231.594- 0.638 %
=223			v2si3     =    223  ;246.942- 245.846- 0.444 %
=225			v2do4     =    225  ;261.626- 261.967- 0.131 %
=226			v2dod4    =    226  ;277.183- 275.517- 0.601 %
=228			v2re4     =    228  ;293.665- 295.926- 0.770 %
=229			v2red4    =    229  ;311.127- 313.333- 0.709 %
=231			v2mi4     =    231  ;329.628- 332.917- 0.998 %
=232			v2fa4     =    232  ;349.228- 347.391- 0.526 %
=233			v2fad4    =    233  ;369.994- 371.628- 0.442 %
=235			v2so4     =    235  ;391.995- 389.756- 0.571 %
=236			v2sod4    =    236  ;415.305- 420.526- 1.257 %
=237			v2la4     =    237  ;440.000- 443.889- 0.884 %
=238			v2lad4    =    238  ;466.164- 470.000- 0.823 %
=239			v2si4     =    239  ;493.883- 499.375- 1.112 %
=240			v2do5     =    240  ;523.251- 515.484- 1.484 %
=0			v2dod5    =      0  ;554.365- 551.034- 0.601 %
=0			v2re5     =      0  ;587.329- 591.852- 0.770 %
=242			v2red5    =    242  ;622.254- 614.615- 1.228 %
=243			v2mi5     =    243  ;659.255- 665.833- 0.998 %
=0			v2fa5     =      0  ;698.456- 694.783- 0.526 %
=244			v2fad5    =    244  ;739.989- 726.364- 1.841 %
=245			v2so5     =    245  ;783.991- 799.000- 1.914 %
=0			v2sod5    =      0  ;830.609- 841.053- 1.257 %
=246			v2la5     =    246  ;880.000- 887.778- 0.884 %
=0			v2lad5    =      0  ;932.327- 940.000- 0.823 %
=133			v3do3     =    133  ;130.813- 130.984- 0.131 %
=140			v3dod3    =    140  ;138.591- 138.957- 0.264 %
=146			v3re3     =    146  ;146.832- 146.606- 0.155 %
=152			v3red3    =    152  ;155.563- 155.146- 0.269 %
=158			v3mi3     =    158  ;164.814- 164.742- 0.043 %
=163			v3fa3     =    163  ;174.614- 173.696- 0.526 %
=169			v3fad3    =    169  ;184.997- 185.814- 0.442 %
=173			v3so3     =    173  ;195.998- 194.878- 0.571 %
=178			v3sod3    =    178  ;207.652- 207.532- 0.058 %
=182			v3la3     =    182  ;220.000- 218.904- 0.498 %
=186			v3lad3    =    186  ;233.082- 231.594- 0.638 %
=190			v3si3     =    190  ;246.942- 245.846- 0.444 %
=194			v3do4     =    194  ;261.626- 261.967- 0.131 %
=197			v3dod4    =    197  ;277.183- 275.517- 0.601 %
=201			v3re4     =    201  ;293.665- 295.926- 0.770 %
=204			v3red4    =    204  ;311.127- 313.333- 0.709 %
=207			v3mi4     =    207  ;329.628- 332.917- 0.998 %
=209			v3fa4     =    209  ;349.228- 347.391- 0.526 %
=212			v3fad4    =    212  ;369.994- 371.628- 0.442 %
=214			v3so4     =    214  ;391.995- 389.756- 0.571 %
=217			v3sod4    =    217  ;415.305- 420.526- 1.257 %
=219			v3la4     =    219  ;440.000- 443.889- 0.884 %
=221			v3lad4    =    221  ;466.164- 470.000- 0.823 %
=223			v3si4     =    223  ;493.883- 499.375- 1.112 %
=224			v3do5     =    224  ;523.251- 515.484- 1.484 %
=226			v3dod5    =    226  ;554.365- 551.034- 0.601 %
=228			v3re5     =    228  ;587.329- 591.852- 0.770 %
=229			v3red5    =    229  ;622.254- 614.615- 1.228 %
=231			v3mi5     =    231  ;659.255- 665.833- 0.998 %
=232			v3fa5     =    232  ;698.456- 694.783- 0.526 %
=233			v3fad5    =    233  ;739.989- 726.364- 1.841 %
=235			v3so5     =    235  ;783.991- 799.000- 1.914 %
=236			v3sod5    =    236  ;830.609- 841.053- 1.257 %
=237			v3la5     =    237  ;880.000- 887.778- 0.884 %
=238			v3lad5    =    238  ;932.327- 940.000- 0.823 %

;******  Return to file: soundtest.asm


;******  End of listing
