
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib -i -L keyfinder.txt -o keyfinder.prg keyfinder.asm
; Wed Jan 28 12:58:06 2026

;Offset	;Hex		;Source

;******  Processing input file: keyfinder.asm

="20260127-161114"	version  = "20260127-161114"

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-bashead-ex.asm

=$1000			scrtxt    = $1000
=$9400			scrcol    = $9400
=$0200			scrlen    = $0200
>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	20 34 36 32	         .text format("%5d", bhstart)
>120a	32
>120b	00		         .byte $00   ;fin de cmd basic.
>120c	00 00		bcmd2    .word $00   ;adresse de la pro-
.120e	20 14 12	bhstart   jsr bhscrini
.1211	4c ac 12	basnold   jmp main
.1214			bhscrini
.1214	08		        php
.1215	48		        pha
.1216	a9 84		        lda #(128+4)
.1218	8d 00 90	        sta vic0
.121b	ad 0f 90	bord    lda $900f    ;place la couleur
.121e	29 08		        and #%00001000
.1220	09 e3		        ora #%11100011
.1222	8d 0f 90	        sta $900f
.1225	a9 00		text    lda #$00    ;place la couleur
.1227	8d 86 02	        sta $0286   ; du texte.
.122a	a9 93		        lda #$93    ;efface l'ecran par
.122c	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.122f	68		        pla
.1230	28		        plp
.1231	60		        rts
.1232			bhprint
.1232	a0 00		        ldy #$00
.1234	b1 fb		nextc   lda ($fb),y
.1236	f0 07		        beq end
.1238	c8		        iny
.1239	20 d2 ff	        jsr $ffd2
.123c	4c 34 12	        jmp nextc
.123f	60		end     rts

;******  Return to file: keyfinder.asm


;******  Processing file: string-fr.asm

>1240	20 00		spaces         .null " "
>1242	0d 0d 20 20	bonjour        .byte $0d,$0d,32,32,revson
>1246	12
>1247	20 42 4f 4e	               .text " bonjour & merci! "
>124b	4a 4f 55 52 20 26 20 4d 45 52 43 49 21 20
>1259	92 0d 00	               .byte revsoff,$0d,0
>125c	20 90 12	texte0         .byte 32,snoir,revson        ;0-2
>125f	43 48 45 52	               .text "chercheur code clef" ;3-23
>1263	43 48 45 55 52 20 43 4f 44 45 20 43 4c 45 46
>1272	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1276	00		               .byte 0
>1277	20 1f 92	texte1         .byte 32,sbleu,revsoff
>127a	20 5b 45 53	               .text " [esc] pour sortir "
>127e	43 5d 20 50 4f 55 52 20 53 4f 52 54 49 52 20
>128d	90 92 20 0d	               .byte snoir,revsoff,32,$0d
>1291	00		               .byte 0
>1292	20 90 92	ligne          .byte 32,snoir,revsoff        ;0-2
>1295	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;3-8   ;1
>1299	c0
>129a	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;9-13
>129e	c0
>129f	c0 c0 c0 c0	               .byte 192,192,192,192,192     ;14-18
>12a3	c0
>12a4	c0 c0 c0 c0	               .byte 192,192,192,192         ;19-23
>12a8	90 92 20	               .byte snoir,revsoff,32    ;24-27
>12ab	00		               .byte 0

;******  Return to file: keyfinder.asm

.12ac			main
.12ac	08		            php
.12ad	48		            pha
.12ae	a9 1b		            lda #(vblanc*16+(vocean|8))
.12b0	8d 0f 90	            sta  vic15
.12b3	a9 06		            lda #vbleu
.12b5	8d 86 02	            sta kcol
.12b8	a9 93		            lda #147
.12ba	20 d2 ff	            jsr $ffd2
.12bd	68		            pla
.12be	28		            plp
.12bf	20 4e 19	          jsr scrnsave
.12c2	08		            php
.12c3	48		            pha
.12c4	a9 8e		            lda #upcase
.12c6	20 7a f2	            jsr chrout
.12c9	68		            pla
.12ca	28		            plp
.12cb	08		            php
.12cc	48		            pha
.12cd	a9 90		            lda #snoir
.12cf	20 7a f2	            jsr chrout
.12d2	68		            pla
.12d3	28		            plp
.12d4	20 da 13	          jsr  pushregs
.12d7	a9 b0		          lda #176
.12d9	8d 5c 12	          sta texte0+0
.12dc	a9 ae		          lda #174
.12de	8d 74 12	          sta texte0+24
.12e1	a2 5c		          ldx  #<texte0
.12e3	a0 12		          ldy  #>texte0
.12e5	20 4a 14	          jsr  putsyx
.12e8	20 07 14	          jsr  popregs
.12eb	20 da 13	          jsr  pushregs
.12ee	a9 dd		          lda #221
.12f0	8d 77 12	          sta texte1+0
.12f3	a9 dd		          lda #221
.12f5	8d 8f 12	          sta texte1+24
.12f8	a2 77		          ldx  #<texte1
.12fa	a0 12		          ldy  #>texte1
.12fc	20 4a 14	          jsr  putsyx
.12ff	20 07 14	          jsr  popregs
.1302	20 da 13	          jsr  pushregs
.1305	a9 ad		          lda #173
.1307	8d 92 12	          sta ligne+0
.130a	a9 bd		          lda #189
.130c	8d aa 12	          sta ligne+24
.130f	a2 92		          ldx  #<ligne
.1311	a0 12		          ldy  #>ligne
.1313	20 4a 14	          jsr  putsyx
.1316	20 07 14	          jsr  popregs
.1319	20 68 13	            jsr  pushall
.131c	a2 52		            ldx  #<revision
.131e	86 fb		            stx  $fb
.1320	a0 13		            ldy  #>revision
.1322	84 fc		            sty  $fc
.1324	20 34 14	            jsr  puts
.1327	20 a1 13	            jsr  popall
.132a	20 e4 18	morekey   jsr getkey
.132d	20 e9 17	          jsr showra
.1330	c9 5f		          cmp #95
.1332	f0 03		          beq out
.1334	4c 2a 13	          jmp morekey
.1337			out
.1337	08		            php
.1338	48		            pha
.1339	a9 1f		            lda #sbleu
.133b	20 7a f2	            jsr chrout
.133e	68		            pla
.133f	28		            plp
.1340	20 68 13	            jsr  pushall
.1343	a2 42		            ldx  #<bonjour
.1345	86 fb		            stx  $fb
.1347	a0 12		            ldy  #>bonjour
.1349	84 fc		            sty  $fc
.134b	20 34 14	            jsr  puts
.134e	20 a1 13	            jsr  popall
.1351	60		          rts
>1352	0d		revision  .byte $0d
>1353	20 56 45 52	          .null format(" ver:%15s",version)
>1357	3a 32 30 32 36 30 31 32 37 2d 31 36 31 31 31 34
>1367	00

;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-push.asm

.1368			pushall
.1368	08		         php     ;s;rp,pcl,pch
.1369	8d f0 25	         sta ra  ;sauve a
.136c	68		         pla     ;s:pcl,pch
.136d	8d f1 25	         sta rp  ;sauve rp
.1370	68		         pla     ;s:pch
.1371	8d eb 25	         sta pc  ;sauve pcl
.1374	68		         pla     ;s:
.1375	8d ec 25	         sta pc+1;sauve pch
.1378	a5 fb		         lda $fb ;sauve fb
.137a	48		         pha     ;s:fb
.137b	a5 fc		         lda $fc ;sauve fc
.137d	48		         pha     ;s:fc,fb
.137e	a5 fd		         lda $fd ;sauve fd
.1380	48		         pha     ;s:fd,fc,fb
.1381	a5 fe		         lda $fe ;sauve fe
.1383	48		         pha     ;s:fe,fd,fc,fb
.1384	ad f1 25	         lda rp  ;sauve rp
.1387	48		         pha     ;s:rp,fe,fd,fc,fb
.1388	ad f0 25	         lda ra  ;sauve ra
.138b	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.138c	8a		         txa     ;sauve rx
.138d	48		         pha     ;s:rx,ra,rp,fe-fb
.138e	98		         tya     ;sauve y
.138f	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.1390	ad ec 25	         lda pc+1;replace l'adresse
.1393	48		         pha     ;s:pch,ry,rx,ra,...
.1394	ad eb 25	         lda pc  ; de retour.
.1397	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.1398	ad f1 25	         lda rp  ;place les flags
.139b	48		         pha     ; sur le stack.
.139c	ad f0 25	         lda ra  ;recupere ra
.139f	28		         plp     ;recupere les flags.
.13a0	60		         rts
.13a1			popall
.13a1	08		         php     ;s:rp,pcl,pch,ry,rx,...
.13a2	8d f0 25	         sta ra
.13a5	68		         pla     ;s:pcl,pch,ry,rx,...
.13a6	8d f1 25	         sta rp  ;s:pch,ry,rx,ra,rp,...
.13a9	68		         pla
.13aa	8d eb 25	         sta pc  ;sauve pcl
.13ad	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.13ae	8d ec 25	         sta pc+1;sauve pch
.13b1	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.13b2	a8		         tay     ;recupere ry
.13b3	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.13b4	aa		         tax     ;recupere rx
.13b5	68		         pla     ;s:rp,fe,fd,fc,fb
.13b6	8d f0 25	         sta ra  ;recupere ra
.13b9	68		         pla     ;s:fe,fd,fc,fb
.13ba	8d f1 25	         sta rp  ;recupere les flags.
.13bd	68		         pla     ;s:fd,fc,fb
.13be	85 fe		         sta $fe ;reccupere fe
.13c0	68		         pla     ;s:fc,fb
.13c1	85 fd		         sta $fd ;recupere fd
.13c3	68		         pla     ;s:fb
.13c4	85 fc		         sta $fc ;recupere fc
.13c6	68		         pla     ;s:
.13c7	85 fb		         sta $fb ;recupere fb
.13c9	ad ec 25	         lda pc+1;replaace l'adresse de
.13cc	48		         pha     ;s:pch
.13cd	ad eb 25	         lda pc  ;retour sur la pile
.13d0	48		         pha     ;s:pcl,pch
.13d1	ad f1 25	         lda rp  ;recupere les flags
.13d4	48		         pha     ;s:rp,pcl,pch
.13d5	ad f0 25	         lda ra  ;recupere ra
.13d8	28		         plp     ;s:pcl,pch
.13d9	60		         rts
.13da			pushregs
.13da	08		         php     ;s;rp,pcl,pch
.13db	8d f0 25	         sta ra  ; -- sauve a
.13de	68		         pla     ;s:pcl,pch
.13df	8d f1 25	         sta rp  ; -- sauve rp
.13e2	68		         pla     ;s:pch
.13e3	8d eb 25	         sta pc  ; -- sauve pcl
.13e6	68		         pla     ;s:
.13e7	8d ec 25	         sta pc+1; -- sauve pch
.13ea	ad f1 25	         lda rp  ; -- sauve rp
.13ed	48		         pha     ;s:rp
.13ee	ad f0 25	         lda ra  ; -- sauve ra
.13f1	48		         pha     ;s:ra,rp
.13f2	8a		         txa     ; -- tfr rx
.13f3	48		         pha     ;s:rx,ra,rp
.13f4	98		         tya     ; -- tfr ry
.13f5	48		         pha     ;s:ry,rx,ra,rp
.13f6	ad ec 25	         lda pc+1; -- replace l'adresse
.13f9	48		         pha     ;s:pch,ry,rx,ra,rp
.13fa	ad eb 25	         lda pc  ; -- de retour.
.13fd	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.13fe	ad f1 25	         lda rp  ; -- place les flags
.1401	48		         pha     ;    sur le stack.
.1402	ad f0 25	         lda ra  ; -- recupere ra
.1405	28		         plp     ; -- recupere flags.
.1406	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1407			popregs
.1407	08		         php
.1408	8d f0 25	         sta ra
.140b	68		         pla
.140c	8d f1 25	         sta rp
.140f	68		         pla     ;s:pch,ry,rx,ra,rp
.1410	8d eb 25	         sta pc  ; -- sauve pcl
.1413	68		         pla     ;s:ry,rx,ra,rp
.1414	8d ec 25	         sta pc+1; -- sauve pch
.1417	68		         pla     ;s:rx,ra,rp
.1418	a8		         tay     ;recupere ry
.1419	68		         pla     ;s:ra,rp
.141a	aa		         tax     ;recupere rx
.141b	68		         pla     ;s:rp
.141c	8d f0 25	         sta ra  ;recupere ra
.141f	68		         pla     ;s:
.1420	8d f1 25	         sta rp  ;recupere les flags.
.1423	ad ec 25	         lda pc+1;replace l'adresse de
.1426	48		         pha     ;s:pch
.1427	ad eb 25	         lda pc  ;retour sur la pile
.142a	48		         pha     ;s:pcl,pch
.142b	ad f1 25	         lda rp  ;recupere les flags
.142e	48		         pha     ;s:rp,pcl,pch
.142f	ad f0 25	         lda ra  ;recupere ra
.1432	28		         plp     ;s:pcl,pch
.1433	60		         rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-string.asm

.1434			puts
.1434	20 68 13	        jsr pushall
.1437	a0 00		        ldy #$00   ; y = offset
.1439	b1 fb		nextc   lda ($fb),y;lit un caractere
.143b	f0 09		        beq out    ;si 0 on sort
.143d	20 7a f2	        jsr chrout ;on l'affiche
.1440	20 6e 15	        jsr inczp1 ;pointe le prochain
.1443	4c 39 14	        jmp nextc  ; et l'affiche
.1446	20 a1 13	out     jsr popall
.1449	60		        rts
.144a			putsyx
.144a	20 68 13	        jsr pushall;sauve reg + zps
.144d	86 fb		        stx $fb    ;$yyxx dans
.144f	84 fc		        sty $fb+1  ; zp1
.1451	20 34 14	        jsr puts
.1454	20 a1 13	        jsr popall ;recup reg + zps
.1457	60		        rts
.1458			putsxy
.1458	20 68 13	        jsr pushall;sauve reg + zps
.145b	86 fb		        stx $fb    ;$yyxx dans
.145d	84 fc		        sty $fb+1  ; zp1
.145f	a0 00		        ldy #$00
.1461	b1 fb		        lda ($fb),y
.1463	aa		        tax
.1464	20 6e 15	        jsr inczp1
.1467	b1 fb		        lda ($fb),y
.1469	20 6e 15	        jsr inczp1
.146c	a8		        tay
.146d	20 c2 14	        jsr gotoxy
.1470	20 34 14	        jsr puts
.1473	20 a1 13	        jsr popall ;recup reg + zps
.1476	60		        rts
.1477			putsc
.1477	08		        php        ;flag sur stack
.1478	48		        pha        ;acc sur stack
.1479	48		        pha        ;sauvegarde acc
.147a	ad 86 02	        lda kcol   ;recup coul. carac.
.147d	8d ea 25	        sta curcol ; et la sauvegarde
.1480	68		        pla        ;recup. acc
.1481	8d 86 02	        sta kcol   ;place coul. voulue
.1484	20 34 14	        jsr puts   ;affiche la chaine
.1487	ad ea 25	        lda curcol ;recup coul. carac.
.148a	8d 86 02	        sta kcol   ; et la replace
.148d	68		        pla        ;recup acc
.148e	28		        plp        ;recup flag
.148f	60		        rts
.1490			putscyx
.1490	08		        php       ;sauve registres
.1491	48		        pha       ; ...
.1492	48		        pha       ;sauve acc
.1493	ad 86 02	        lda kcol  ;recup couleur carac.
.1496	8d ea 25	        sta curcol; et sauvegarde
.1499	68		        pla       ;recup acc
.149a	8d 86 02	        sta kcol  ;place couleur carac.
.149d	20 4a 14	        jsr putsyx;affiche la chaine
.14a0	ad ea 25	        lda curcol
.14a3	8d 86 02	        sta kcol
.14a6	68		        pla
.14a7	28		        plp
.14a8	60		        rts
.14a9			putscxy
.14a9	08		        php       ;sauve registres
.14aa	48		        pha       ; ...
.14ab	48		        pha       ;sauve acc
.14ac	ad 86 02	        lda kcol  ;recup couleur carac.
.14af	8d ea 25	        sta curcol; et sauvegarde
.14b2	68		        pla       ;recup acc
.14b3	8d 86 02	        sta kcol   ;place couleur carac.
.14b6	20 4a 14	        jsr putsyx ;affiche la chaine
.14b9	ad ea 25	        lda curcol
.14bc	8d 86 02	        sta kcol
.14bf	68		        pla
.14c0	28		        plp
.14c1	60		        rts
.14c2			gotoxy
.14c2	20 da 13	        jsr pushregs
.14c5	8a		        txa ; interchange x et y
.14c6	48		        pha ; ...
.14c7	98		        tya ; ...
.14c8	aa		        tax ; ...
.14c9	68		        pla ; ...
.14ca	a8		        tay ; ...
.14cb	c0 00		txlow   cpy #0
.14cd	10 02		        bpl txhigh
.14cf	a2 00		        ldx #0
.14d1	e0 19		txhigh  cpx #25
.14d3	30 02		        bmi tylow
.14d5	a2 18		        ldx #24
.14d7	c0 00		tylow   cpy #0
.14d9	10 02		        bpl tyhigh
.14db	a0 00		        ldy #0
.14dd	c0 28		tyhigh  cpy #40
.14df	30 02		        bmi allok
.14e1	a0 27		        ldy #39
.14e3	18		allok   clc
.14e4	20 0a e5	        jsr plot
.14e7	20 07 14	        jsr popregs
.14ea	60		        rts
.14eb			putnch
.14eb	20 da 13	        jsr pushregs
.14ee	20 7a f2	again   jsr chrout
.14f1	ca		        dex
.14f2	d0 fa		        bne again
.14f4	20 07 14	        jsr popregs
.14f7	60		        rts
.14f8			strlen
.14f8	20 68 13	        jsr pushall
.14fb	84 fc		        sty zp1+1
.14fd	86 fb		        stx zp1
.14ff	a0 00		        ldy #$00
.1501	8c 7c 25	        sty len
.1504	b1 fb		next    lda (zp1),y
.1506	f0 07		        beq out
.1508	ee 7c 25	        inc len
.150b	c8		        iny
.150c	4c 04 15	        jmp next
.150f	20 a1 13	out     jsr popall
.1512	ad 7c 25	        lda len
.1515	60		        rts
.1516			cursor
.1516	20 da 13	        jsr  pushregs
.1519	90 12		        bcc  get    ;C=0 récupération.
.151b	20 0a e5	        jsr  plot  ;récupère position
.151e	8c 7b 25	        sty  cx     ;curseur et sauve
.1521	8e 7a 25	        stx  cy     ;dans vars locales.
.1524	ad 86 02	        lda  kcol   ;Sauve couleur
.1527	8d 79 25	        sta  bcol   ; BASIC du texte.
.152a	4c 3c 15	        jmp  out    ;Fini on sort.
.152d	ae 7a 25	get     ldx  cy     ;C=1, charge x
.1530	ac 7b 25	        ldy  cx     ; ligne, y col.
.1533	20 0a e5	        jsr  plot  ;Position curseur.
.1536	ad 79 25	        lda  bcol   ;replace couleur
.1539	8d 86 02	        sta  kcol ; basic sauvegardé.
.153c	20 07 14	out     jsr  popregs
.153f	60		        rts
.1540			cursave
.1540	08		        php
.1541	38		        sec
.1542	20 16 15	        jsr  cursor
.1545	28		        plp
.1546	60		        rts
.1547			curput
.1547	08		        php
.1548	18		        clc
.1549	20 16 15	        jsr  cursor
.154c	28		        plp
.154d	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-mem.asm

.154e			blkfill
.154e	20 68 13	bf0     jsr pushall
.1551	84 fc		        sty zp1+1
.1553	a0 00		        ldy #$00
.1555	84 fb		        sty zp1
.1557	91 fb		bf1     sta (zp1),y
.1559	c8		        iny
.155a	d0 fb		        bne bf1
.155c	20 a1 13	        jsr popall
.155f	60		        rts
.1560			memfill
.1560	20 da 13	        jsr pushregs
.1563	20 4e 15	mf1     jsr blkfill
.1566	c8		        iny
.1567	ca		        dex
.1568	d0 f9		        bne mf1
.156a	20 07 14	        jsr popregs
.156d	60		        rts
.156e			inczp1
.156e	08		         php
.156f	e6 fb		         inc zp1
.1571	d0 02		         bne repzp1
.1573	e6 fc		         inc zp1+1
.1575	28		repzp1   plp
.1576	60		         rts
.1577			inczp2
.1577	08		         php
.1578	e6 fd		         inc zp2
.157a	d0 02		         bne repzp2
.157c	e6 fe		         inc zp2+1
.157e	28		repzp2   plp
.157f	60		         rts
.1580			deczp1
.1580	08		         php
.1581	48		         pha
.1582	a5 fb		         lda zp1
.1584	d0 02		         bne noemp
.1586	c6 fc		         dec zp1+1
.1588	c6 fb		noemp    dec zp1
.158a	68		         pla
.158b	28		         plp
.158c	60		         rts
.158d			deczp2
.158d	08		         php
.158e	48		         pha
.158f	a5 fd		         lda zp2
.1591	d0 02		         bne noemp
.1593	c6 fe		         dec zp2+1
.1595	c6 fd		noemp    dec zp2
.1597	68		         pla
.1598	28		         plp
.1599	60		         rts
.159a			rolzp1
.159a	08		        php
.159b	48		        pha
.159c	18		        clc
.159d	a5 fb		        lda zp1
.159f	2a		        rol
.15a0	85 fb		        sta zp1
.15a2	a5 fc		        lda zp1+1
.15a4	2a		        rol
.15a5	85 fc		        sta zp1+1
.15a7	68		        pla
.15a8	28		        plp
.15a9			rorzp1
.15a9	08		        php
.15aa	48		        pha
.15ab	18		        clc
.15ac	a5 fc		        lda zp1+1
.15ae	6a		        ror
.15af	85 fc		        sta zp1+1
.15b1	a5 fb		        lda zp1
.15b3	6a		        ror
.15b4	85 fb		        sta zp1
.15b6	68		        pla
.15b7	28		        plp
.15b8			rolzp2
.15b8	08		        php
.15b9	48		        pha
.15ba	18		        clc
.15bb	a5 fd		        lda zp2
.15bd	2a		        rol
.15be	85 fd		        sta zp2
.15c0	a5 fe		        lda zp2+1
.15c2	2a		        rol
.15c3	85 fe		        sta zp2+1
.15c5	68		        pla
.15c6	28		        plp
.15c7			rorzp2
.15c7	08		        php
.15c8	48		        pha
.15c9	18		        clc
.15ca	a5 fe		        lda zp2+1
.15cc	6a		        ror
.15cd	85 fe		        sta zp2+1
.15cf	a5 fd		        lda zp2
.15d1	6a		        ror
.15d2	85 fd		        sta zp2
.15d4	68		        pla
.15d5	28		        plp
.15d6			yxtoptr
.15d6	8c ea 25	        sty memptr+1
.15d9	8e e9 25	        stx memptr
.15dc	60		        rts
.15dd			ptrtoyx
.15dd	08		        php
.15de	ac ea 25	        ldy memptr+1
.15e1	ae e9 25	        ldx memptr
.15e4	28		        plp
.15e5	60		        rts
.15e6			incptr
.15e6	08		        php
.15e7	ee e9 25	        inc memptr
.15ea	d0 03		        bne norep
.15ec	ee ea 25	        inc memptr+1
.15ef	28		norep   plp
.15f0	60		        rts
.15f1			decptr
.15f1	08		        php
.15f2	48		        pha
.15f3	ad e9 25	        lda memptr
.15f6	d0 03		        bne noemp
.15f8	ee ea 25	        inc memptr+1
.15fb	ee e9 25	noemp   inc memptr
.15fe	68		        pla
.15ff	28		        plp
.1600	60		        rts
.1601			incptr8
.1601	08		        php
.1602	48		        pha
.1603	98		        tya
.1604	48		        pha
.1605	a0 08		        ldy #8
.1607	20 e6 15	again   jsr incptr
.160a	88		        dey
.160b	d0 fa		        bne again
.160d	68		        pla
.160e	a8		        tay
.160f	68		        pla
.1610	28		        plp
.1611	60		        rts
.1612			loop
.1612	ce e3 25	               dec  loopcount
.1615	d0 03		               bne  norep
.1617	ce e4 25	               dec  loopcount+1
.161a	ad e3 25	norep          lda  loopcount
.161d	c9 00		               cmp  #$00
.161f	d0 05		               bne  out
.1621	4d e4 25	               eor  loopcount+1
.1624	c9 ff		               cmp  #$ff
.1626	60		out            rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-math.asm

.1627			addtoword
.1627			addatoyx
.1627	08		        php
.1628	48		        pha
.1629	8c 8a 25	        sty reponse+1
.162c	8e 89 25	        stx reponse
.162f	18		        clc
.1630	6d 89 25	        adc reponse
.1633	90 03		        bcc norep
.1635	ee 8a 25	        inc reponse+1
.1638	8d 89 25	norep   sta reponse
.163b	ac 8a 25	        ldy reponse+1
.163e	ae 89 25	        ldx reponse
.1641	68		        pla
.1642	28		        plp
.1643	60		        rts
.1644			subtoword
.1644			subatoyx
.1644	08		        php
.1645	48		        pha
.1646	8c 8a 25	        sty reponse+1
.1649	8e 89 25	        stx reponse
.164c	38		        sec
.164d	ed 89 25	        sbc reponse
.1650	b0 03		        bcs noemp
.1652	ce 8a 25	        dec reponse+1
.1655	8d 89 25	noemp   sta reponse
.1658	ac 8a 25	        ldy reponse+1
.165b	ae 89 25	        ldx reponse
.165e	68		        pla
.165f	28		        plp
.1660	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-conv.asm

.1661			putyxhex
.1661	20 68 13	        jsr pushall
.1664	98		        tya
.1665	48		        pha
.1666	20 e4 16	        jsr lsr4bits
.1669	20 f7 16	        jsr nibtohex
.166c	8d de 25	        sta hexstr+0
.166f	68		        pla
.1670	20 f7 16	        jsr nibtohex
.1673	8d df 25	        sta hexstr+1
.1676	8a		        txa
.1677	20 96 16	        jsr atohex
.167a	a2 de		        ldx #<hexstr+0
.167c	a0 25		        ldy #>hexstr+0
.167e	20 4a 14	        jsr putsyx
.1681	20 a1 13	        jsr popall
.1684	60		        rts
.1685			putahex
.1685	20 da 13	        jsr pushregs
.1688	20 96 16	        jsr atohex
.168b	a2 de		        ldx #<hexstr; +2
.168d	a0 25		        ldy #>hexstr; +2
.168f	20 4a 14	        jsr putsyx
.1692	20 07 14	        jsr popregs
.1695	60		        rts
.1696			atohex
.1696	08		        php
.1697	48		        pha
.1698	48		        pha
.1699	20 e4 16	        jsr lsr4bits
.169c	20 f7 16	        jsr nibtohex
.169f	8d de 25	        sta hexstr
.16a2	68		        pla
.16a3	20 f7 16	        jsr nibtohex
.16a6	8d df 25	        sta hexstr+1
.16a9	a9 00		        lda #$00
.16ab	8d e0 25	        sta hexstr+2
.16ae	68		        pla
.16af	28		        plp
.16b0	60		        rts
.16b1			putabin
.16b1	20 da 13	          jsr     pushregs
.16b4	20 c2 16	          jsr     atobin
.16b7	a2 d1		          ldx     #<binstr
.16b9	a0 25		          ldy     #>binstr
.16bb	20 4a 14	          jsr     putsyx
.16be	20 07 14	          jsr     popregs
.16c1	60		          rts
.16c2			atobin
.16c2	20 da 13	          jsr  pushregs
.16c5	a2 08		          ldx  #8
.16c7	a0 00		          ldy  #0
.16c9	18		          clc
.16ca	2a		nextbit   rol
.16cb	48		          pha
.16cc	69 00		          adc  #$00
.16ce	29 01		          and  #$01
.16d0	20 f7 16	          jsr  nibtohex
.16d3	99 d1 25	          sta  binstr,y
.16d6	68		          pla
.16d7	c8		          iny
.16d8	ca		          dex
.16d9	d0 ef		          bne  nextbit
.16db	a9 00		          lda  #0
.16dd	99 d1 25	          sta  binstr,y
.16e0	20 07 14	          jsr  popregs
.16e3	60		          rts
.16e4			lsr4bits
.16e4	08		          php
.16e5	4a		          lsr a
.16e6	4a		          lsr a
.16e7	4a		          lsr a
.16e8	4a		          lsr a
.16e9	28		          plp
.16ea	60		          rts
.16eb			nibtohexb
.16eb	08		        php
.16ec	29 0f		        and #$0f
.16ee	f8		        sed
.16ef	18		        clc
.16f0	69 90		        adc #$90
.16f2	69 40		        adc #$40
.16f4	d8		        cld
.16f5	28		        plp
.16f6	60		        rts
.16f7			nibtohex
.16f7	08		        php
.16f8	8c 16 17	        sty myy
.16fb	29 0f		        and #$0f
.16fd	a8		        tay
.16fe	b9 06 17	        lda hextbl,y
.1701	ac 16 17	        ldy myy
.1704	28		        plp
.1705	60		        rts
>1706	30 31 32 33	hextbl  .byte $30,$31,$32,$33,$34
>170a	34
>170b	35 36 37 38	        .byte $35,$36,$37,$38,$39
>170f	39
>1710	41 42 43 44	        .byte $41,$42,$43,$44,$45
>1714	45
>1715	46		        .byte $46
>1716	00		myy     .byte $00
.1717			bytestohex
.1717	20 68 13	        jsr pushall
.171a	84 fc		        sty zp1+1
.171c	86 fb		        stx zp1
.171e	08		            php
.171f	48		            pha
.1720	a9 20		            lda #32
.1722	20 7a f2	            jsr chrout
.1725	68		            pla
.1726	28		            plp
.1727	08		            php
.1728	48		            pha
.1729	a9 05		            lda #5
.172b	20 7a f2	            jsr chrout
.172e	68		            pla
.172f	28		            plp
.1730	08		            php
.1731	48		            pha
.1732	a9 24		            lda #36
.1734	20 7a f2	            jsr chrout
.1737	68		            pla
.1738	28		            plp
.1739	20 61 16	        jsr putyxhex   ; prn adreponsese
.173c	08		            php
.173d	48		            pha
.173e	a9 20		            lda #$20
.1740	20 7a f2	            jsr chrout
.1743	68		            pla
.1744	28		            plp
.1745	08		            php
.1746	48		            pha
.1747	a9 9f		            lda #159
.1749	20 7a f2	            jsr chrout
.174c	68		            pla
.174d	28		            plp
.174e	a0 00		        ldy #$00
.1750	aa		        tax
.1751	8c c2 25	another sty offset
.1754	b1 fb		        lda (zp1),y
.1756	20 85 16	        jsr putahex
.1759	48		        pha
.175a	20 79 17	        jsr petsciiaddr
.175d	68		        pla
.175e	8d 00 04	petscii sta $0400
.1761	48		        pha
.1762	a9 0d		        lda #$0d
.1764	8d 00 d8	petcol  sta $d800
.1767	68		        pla
.1768	08		            php
.1769	48		            pha
.176a	a9 20		            lda #$20
.176c	20 7a f2	            jsr chrout
.176f	68		            pla
.1770	28		            plp
.1771	c8		        iny
.1772	ca		        dex
.1773	d0 dc		        bne another
.1775	20 a1 13	        jsr popall
.1778	60		        rts
.1779			petsciiaddr
.1779	20 da 13	        jsr pushregs
.177c	a9 1f		        lda #31
.177e	18		        clc
.177f	6d c2 25	        adc offset
.1782	20 27 16	        jsr addatoyx
.1785	8c 60 17	        sty petscii+2
.1788	8e 5f 17	        stx petscii+1
.178b	8e 65 17	        stx petcol+1
.178e	98		        tya
.178f	29 fb		        and #%11111011 ;#%00000100
.1791	09 d8		        ora #$d8
.1793	8d 66 17	        sta petcol+2
.1796	a8		        tay
.1797	20 07 14	        jsr popregs
.179a	60		        rts
.179b			strhexval
.179b	20 68 13	        jsr pushall ; sauve registre
.179e	84 fc		        sty zp1+1   ; ptr dans zp1
.17a0	86 fb		        stx zp1
.17a2	20 f8 14	        jsr strlen  ;len de $(yyxx)->a
.17a5	f0 3d		        beq oute    ; si 0 erreur C=1
.17a7	a0 00		        ldy #$00    ; offset a 0
.17a9	8c 8a 25	        sty reponse+1; reponse a zero
.17ac	8c 89 25	        sty reponse ;    ...
.17af	b1 fb		nextc   lda (zp1),y ;charge un caractere
.17b1	f0 26		        beq out     ;On  a fini
.17b3	c0 00		        cpy #$00    ;si c'est le premier
.17b5	f0 07		        beq norol   ; pas de rol
.17b7	48		        pha         ;
.17b8	a9 04		        lda #$04    ;rol de 4 pos
.17ba	20 9a 18	        jsr rolword ;
.17bd	68		        pla         ;
.17be	09 20		norol   ora #%00100000
.17c0	38		        sec
.17c1	e9 30		        sbc #$30
.17c3	c9 0a		        cmp #$0a
.17c5	90 07		        bcc lt10
.17c7	38		        sec
.17c8	e9 27		        sbc #$27
.17ca	c9 10		        cmp #$10
.17cc	b0 16		        bcs oute
.17ce	0d 89 25	lt10    ora reponse
.17d1	8d 89 25	        sta reponse
.17d4	c8		        iny
.17d5	c0 04		        cpy #$04
.17d7	d0 d6		        bne nextc
.17d9	20 a1 13	out     jsr popall
.17dc	18		        clc          ;Carry 0 = good
.17dd	ac 8a 25	        ldy reponse+1
.17e0	ae 89 25	        ldx reponse
.17e3	60		        rts
.17e4	20 a1 13	oute    jsr popall
.17e7	38		        sec
.17e8	60		        rts
.17e9			showra
.17e9	08		            php
.17ea	48		            pha
.17eb	a9 90		            lda #snoir
.17ed	20 7a f2	            jsr chrout
.17f0	68		            pla
.17f1	28		            plp
.17f2	08		            php
.17f3	48		            pha
.17f4	a9 0d		            lda #13
.17f6	20 7a f2	            jsr chrout
.17f9	68		            pla
.17fa	28		            plp
.17fb	20 68 13	            jsr  pushall
.17fe	a2 40		            ldx  #<spaces
.1800	86 fb		            stx  $fb
.1802	a0 12		            ldy  #>spaces
.1804	84 fc		            sty  $fc
.1806	20 34 14	            jsr  puts
.1809	20 a1 13	            jsr  popall
.180c	20 7a f2	          jsr chrout
.180f	08		            php
.1810	48		            pha
.1811	a9 20		            lda #32
.1813	20 7a f2	            jsr chrout
.1816	68		            pla
.1817	28		            plp
.1818	08		            php
.1819	48		            pha
.181a	a9 1f		            lda #sbleu
.181c	20 7a f2	            jsr chrout
.181f	68		            pla
.1820	28		            plp
.1821	08		            php
.1822	48		            pha
.1823	a9 24		            lda #36
.1825	20 7a f2	            jsr chrout
.1828	68		            pla
.1829	28		            plp
.182a	20 85 16	          jsr putahex
.182d	08		            php
.182e	48		            pha
.182f	a9 20		            lda #32
.1831	20 7a f2	            jsr chrout
.1834	68		            pla
.1835	28		            plp
.1836	08		            php
.1837	48		            pha
.1838	a9 1c		            lda #srouge
.183a	20 7a f2	            jsr chrout
.183d	68		            pla
.183e	28		            plp
.183f	08		            php
.1840	48		            pha
.1841	a9 25		            lda #37
.1843	20 7a f2	            jsr chrout
.1846	68		            pla
.1847	28		            plp
.1848	20 b1 16	          jsr putabin
.184b	08		            php
.184c	48		            pha
.184d	a9 20		            lda #32
.184f	20 7a f2	            jsr chrout
.1852	68		            pla
.1853	28		            plp
.1854	08		            php
.1855	48		            pha
.1856	a9 9c		            lda #smauve
.1858	20 7a f2	            jsr chrout
.185b	68		            pla
.185c	28		            plp
.185d	48		          pha
.185e	aa		          tax
.185f	a9 00		          lda #$00
.1861	20 cd dd	          jsr fiaxtf1
.1864	68		          pla
.1865	08		            php
.1866	48		            pha
.1867	a9 20		            lda #32
.1869	20 7a f2	            jsr chrout
.186c	68		            pla
.186d	28		            plp
.186e	60		          rts
.186f			putahexdec
.186f	20 da 13	        jsr pushregs
.1872	08		            php
.1873	48		            pha
.1874	a9 9e		            lda #sjaune
.1876	20 7a f2	            jsr chrout
.1879	68		            pla
.187a	28		            plp
.187b	20 85 16	        jsr putahex
.187e	08		            php
.187f	48		            pha
.1880	a9 20		            lda #$20
.1882	20 7a f2	            jsr chrout
.1885	68		            pla
.1886	28		            plp
.1887	08		            php
.1888	48		            pha
.1889	a9 9f		            lda #socean
.188b	20 7a f2	            jsr chrout
.188e	68		            pla
.188f	28		            plp
.1890	aa		        tax
.1891	a9 00		        lda #$00
.1893	20 cd dd	        jsr fiaxtf1
.1896	20 07 14	        jsr popregs
.1899	60		        rts
.189a			rolword
.189a	20 da 13	        jsr pushregs
.189d	a8		        tay
.189e	18		again   clc
.189f	2e 89 25	        rol reponse
.18a2	2e 8a 25	        rol reponse+1
.18a5	88		        dey
.18a6	d0 f6		        bne again
.18a8	20 07 14	        jsr popregs
.18ab	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-keyb.asm

.18ac			clrkbbuf
.18ac	08		          php
.18ad	48		          pha
.18ae	a9 00		          lda #0
.18b0	85 c6		          sta 198
.18b2	20 e1 ff	          jsr $ffe1
.18b5	68		          pla
.18b6	28		          plp
.18b7	60		          rts
.18b8			waitstop
.18b8	08		          php    ;\ sauve les flags
.18b9	48		          pha    ;/  et l'acc.
.18ba	20 ac 18	          jsr clrkbbuf
.18bd	20 70 f7	wait      jsr stop ; Veri [run/stop]
.18c0	d0 fb		          bne wait ;loop pas pesee.
.18c2	68		          pla    ;\ recup. acc et
.18c3	28		          plp    ;/  les flags.
.18c4	60		          rts
.18c5			anykey
.18c5	08		          php
.18c6	48		          pha
.18c7	20 ac 18	          jsr clrkbbuf
.18ca	a5 cb		wait      lda 203    ;lit la matrice de
.18cc	c9 40		          cmp #64    ; 64 = aucune clef
.18ce	f0 fa		          beq wait   ; on en attend une.
.18d0	20 d9 18	          jsr kbfree ; Clavier relache.
.18d3	20 ac 18	          jsr clrkbbuf
.18d6	68		          pla
.18d7	28		          plp
.18d8	60		          rts
.18d9			kbfree
.18d9	08		        php
.18da	48		        pha
.18db	a5 cb		wait    lda 203    ; lit la matrice
.18dd	c9 40		        cmp #64    ; 64 = aucune clef
.18df	d0 fa		        bne wait   ; attend la relache
.18e1	68		        pla
.18e2	28		        plp
.18e3	60		        rts
.18e4			getkey
.18e4	08		        php
.18e5	20 e1 ff	        jsr $ffe1
.18e8	20 f5 f1	try     jsr getin  ;tente de lire
.18eb	c9 00		        cmp #0     ; 0 si aucune.
.18ed	f0 f9		        beq try    ; on reessaye
.18ef	28		        plp
.18f0	60		        rts
.18f1			waitkey
.18f1	08		        php
.18f2	48		        pha
.18f3	8d 7d 25	        sta clef   ;Sauve clef voulue
.18f6	20 ac 18	        jsr clrkbbuf
.18f9	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.18fc	cd 7d 25	        cmp clef   ;Compare avec clef
.18ff	d0 f8		        bne wait   ;Pas la bonne.
.1901	68		        pla
.1902	28		        plp
.1903	60		        rts
.1904			waitspace
.1904	a9 20		          lda #$20
.1906	20 f1 18	          jsr waitkey
.1909	20 ac 18	          jsr clrkbbuf
.190c	60		          rts
.190d			showkey
.190d	20 da 13	        jsr pushregs
.1910	38		        sec
.1911	20 0a e5	        jsr plot
.1914	8e 7f 25	        stx curx
.1917	8c 7e 25	        sty cury
.191a	20 da 13	        jsr pushregs
.191d	a0 08		        ldy #8
.191f	a2 16		        ldx #22
.1921	18		        clc
.1922	20 0a e5	        jsr plot
.1925	20 07 14	        jsr popregs
.1928	20 7a f2	        jsr chrout
.192b	08		            php
.192c	48		            pha
.192d	a9 20		            lda #32
.192f	20 7a f2	            jsr chrout
.1932	68		            pla
.1933	28		            plp
.1934	08		            php
.1935	48		            pha
.1936	a9 24		            lda #36
.1938	20 7a f2	            jsr chrout
.193b	68		            pla
.193c	28		            plp
.193d	20 6f 18	        jsr putahexdec
.1940	18		        clc
.1941	ac 7e 25	        ldy cury
.1944	ae 7f 25	        ldx curx
.1947	20 0a e5	        jsr plot
.194a	20 07 14	        jsr popregs
.194d	60		        rts

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/l-v20-screen.asm

.194e			scrnsave
.194e	20 68 13	        jsr pushall
.1951	20 9a 19	        jsr setcarptr
.1954	20 74 19	        jsr zp1tozp2
.1957	20 ab 19	        jsr setcolptr
.195a	20 74 19	        jsr zp1tozp2
.195d	20 a1 13	        jsr popall
.1960	60		        rts
.1961			scrnrest
.1961	20 68 13	        jsr pushall
.1964	20 9a 19	        jsr setcarptr
.1967	20 87 19	        jsr zp2tozp1
.196a	20 ab 19	        jsr setcolptr
.196d	20 87 19	        jsr zp2tozp1
.1970	20 a1 13	        jsr popall
.1973	60		        rts
.1974			zp1tozp2
.1974	a2 02		        ldx #>scrlen
.1976	a0 00		        ldy #<scrlen
.1978	b1 fb		nextcar lda (zp1),y
.197a	91 fd		        sta (zp2),y
.197c	c8		        iny
.197d	d0 f9		        bne nextcar
.197f	e6 fc		        inc zp1+1
.1981	e6 fe		        inc zp2+1
.1983	ca		        dex
.1984	d0 f2		        bne nextcar
.1986	60		        rts
.1987			zp2tozp1
.1987	a2 02		        ldx #>scrlen
.1989	a0 00		        ldy #<scrlen
.198b	b1 fd		nextcar lda (zp2),y
.198d	91 fb		        sta (zp1),y
.198f	c8		        iny
.1990	d0 f9		        bne nextcar
.1992	e6 fc		        inc zp1+1
.1994	e6 fe		        inc zp2+1
.1996	ca		        dex
.1997	d0 f2		        bne nextcar
.1999	60		        rts
.199a			setcarptr
.199a	a9 00		        lda #<scrtxt
.199c	85 fb		        sta zp1
.199e	a9 10		        lda #>scrtxt
.19a0	85 fc		        sta zp1+1
.19a2	a9 76		        lda #<scrncar
.19a4	85 fd		        sta zp2
.19a6	a9 23		        lda #>scrncar
.19a8	85 fe		        sta zp2+1
.19aa	60		        rts
.19ab			setcolptr
.19ab	a9 00		        lda #<scrcol
.19ad	85 fb		        sta zp1
.19af	a9 94		        lda #>scrcol
.19b1	85 fc		        sta zp1+1
.19b3	a9 76		        lda #<scrncol
.19b5	85 fd		        sta zp2
.19b7	a9 21		        lda #>scrncol
.19b9	85 fe		        sta zp2+1
.19bb	60		        rts
.19bc			fillscreen
.19bc	20 68 13	        jsr pushall
.19bf	a2 01		        ldx #$01
.19c1	a0 00		        ldy #$00
.19c3	99 00 10	again   sta scrtxt,y
.19c6	99 00 11	        sta scrtxt+256,y
.19c9	48		        pha
.19ca	ee e4 19	        inc col
.19cd	ad e4 19	        lda col
.19d0	29 7f		        and #$7f
.19d2	29 07		        and #$07
.19d4	09 18		        ora #$18
.19d6	99 00 94	        sta scrcol,y
.19d9	99 00 95	        sta scrcol+256,y
.19dc	68		        pla
.19dd	c8		        iny
.19de	d0 e3		        bne again
.19e0	20 a1 13	        jsr popall
.19e3	60		        rts
>19e4	00		col     .byte 0

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-vars.asm

=9714			libre    = *+3085
=9713			rp       = libre-$01;1 byte $cfff
=9712			ra       = rp-1     ;1 byte $cffe
=9711			rx       = ra-1     ;1 byte $cffd
=9710			ry       = rx-1     ;1 byte $cffc
=9709			rs       = ry-1     ;1 byte $cffb
=9707			pc       = rs-2     ;2 byte $cff9-$cffa
=9706			curcol   = pc-1     ;1 byte $cff6
=9705			memptr   = curcol-1;1 word $cff7-$cff8
=9703			src      = memptr-2
=9701			dst      = memptr-4
=9699			loopcount = memptr-6
=9699			hexv     = loopcount
.19e5			a2hexstr
=9694			hexstr   = hexv-$05 ;5 byte
=9693			a2hexpfx = hexv-$06 ;1 byte
=9692			a2hexpy  = hexv-$07 ;1 byte
=9691			a2hexpx  = hexv-$08 ;1 byte
=9691			a2hexpos = hexv-$08 ;0 byte
=9690			a2hexcol = hexv-$09 ;1 byte
=9690			binv     = a2hexcol
=9681			binstr   = binv-$09 ;9 byte
=9680			a2binpfx = binv-$0a ;1 byte
=9679			a2binpy  = binv-$0b ;1 byte
=9678			a2binpx  = binv-$0c ;1 byte
=9678			a2binpos = binv-$0c ;0 byte
=9677			a2bincol = binv-$0d ;1 byte
=9677			decv     = a2bincol
=9671			decstr   = decv-$06 ;6 byte
=9670			a2decpfx = decv-$07 ;1 byte
=9669			a2decpy  = decv-$08 ;1 byte
=9668			a2decpx  = decv-$09 ;1 byte
=9668			a2decpos = decv-$09 ;0 byte
=9667			a2deccol = decv-$0a ;1 byte
=9666			offset   = decv-$0b ;1 byte
=9666			fltv     = offset
=9660			fvar1    = fltv-6  ; 6 byte
=9654			fvar2    = fltv-12 ; 6 byte
=9634			float1   = fltv-32 ;20 byte
=9614			float2   = fltv-52 ;20 byte
=9613			tval1    = fltv-53 ; 1 byte
=9611			tval2    = fltv-55 ; 2 byte
=9609			reponse  = tval2-2 ; 2 byte
=9609			edbox    = reponse
=9608			cleft    = edbox-1 ;1 byte
=9607			cright   = edbox-2 ;1 byte
=9606			cmid     = edbox-3 ;1 byte
=9605			dbtop    = edbox-4 ;1 byte
=9604			dbleft   = edbox-5 ;1 byte
=9603			dbwdth   = edbox-6 ;1 byte
=9602			dbhght   = edbox-7 ;1 byte
=9601			dbcoul   = edbox-8 ;1 byte
=9600			dbclin   = edbox-9 ;1 byte
=9600			ekeyb    = dbclin
=9599			curx     = ekeyb-1 ;1 byte
=9598			cury     = ekeyb-2 ;1 byte
=9597			clef     = ekeyb-3 ;1 byte
=9596			len      = clef-1  ;1 byte
=9595			cx       = clef-2  ;1 byte
=9594			cy       = clef-3  ;1 byte
=9593			bcol     = clef-4  ;1 byte
=9593			escr     = bcol         ;2051 bytes
=9592			loops    = escr-1       ;   1 byte
=9590			loop16   = loops-2      ;   2 byte
=9078			scrncar  = loop16-$200  ;  1k byte
=8566			scrncol  = scrncar-$200 ;  1k byte
=8566			diskvar = scrncol
=8564			ddatas  = diskvar-2 ;2 byte Data start
=8562			ddatae  = diskvar-4 ;2 byte Data end
=8561			ddev    = diskvar-5 ;1 byte Dev number
=8560			dlfsno  = diskvar-6 ;1 byte Lfs
=8558			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=8557			dfnlen  = diskvar-9 ;1 byte lenfilename
=8556			genbyte1 = dfnlen-1 ; 1 byte
=8554			genword1 = dfnlen-3 ; 2 byte
=8553			endofvars = genword1-1

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm


;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-page0.asm

=$01			kvar1     = $01
=$02			kvar2     = $02
=$13			channl    = $13
=$37			memsiz    = $37     ; WORD: Pointeur vers la fin de la mémoire BASIC.
=$57			tmpfp3    = $57     ; 10 octets i.e. 2 fp $57-$5b et $5c-$60
=$61			fac1      = $61     ;  5 octets i.e.      $61-$66
=$69			fac2      = $69     ;  5 octets i.e.      $69-$6e
=$73			chrget    = $73     ; Recup Basic car texte 24 octets i.e. $73-$8a
=$79			chrgot    = $79     ;  ...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$93			verck     = $93     ; 0=LOAD, 1=VERIFY
=$99			dfltn     = $99     ; Numéro du périphérique d'entrée actuel.
=$9d			msgflg    = $9d     ; Indicateur de contrôle des messages du noyau.
=$a0			time      = $a0     ; 3 octets i.e. HR:$a0, MN:$a1, SC:$a2
=$b7			curfnlen  = $b7     ; Longueur actuelle du nom de fichier (octets).
=$b8			la        = $b8     ; Numéro de fichier logique actuel utilisé.
=$b9			sa        = $b9     ; Adresse secondaire actuellement utilisée.
=$b9			cursecadd = $b9     ; Adresse secondaire actuellement utilisée. (octet).
=$ba			fa        = $ba     ; Numéro de périphérique actuel (octet).
=$ba			curdevno  = $ba     ; Numéro de périphérique actuel (octet).
=$bb			fnadr     = $bb     ; Pointeur de fichier actuel (mot).
=$bb			curfptr   = $bb     ; Pointeur de fichier actuel (mot).
=$c1			stal      = $c1     ;
=$c3			memuss    = $c3     ; Pointeur vers la zone de RAM en cours de chargement.(mot)
=$c6			ndx       = $c6     ; Nombre de caractères (0-10) dans le tampon du clavier.
=$c7			rvs       = $c7     ; Indicateur pour caractères d'écran inversés.
=$d1			scrnlin   = $d1     ; pnt cur-scrn-line
=$d6			tblx      = $d6     ; Curseur : numéro de la ligne physique actuelle sur
=$fb			zp1       = $fb     ; 1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ; 2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			fFAC1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			fFAC1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; ff1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; ff1=atn(f1).

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: keyfinder.asm


;******  Processing file: /Users/Locals/CBM/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=0			eot       =    0
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.19e5	4c ac 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: keyfinder.asm


;******  End of listing
