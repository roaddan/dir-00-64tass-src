
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -C -m -a -I /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib -i -L template.txt -o template.prg template.asm
; Sun Jan 18 16:31:13 2026

;Offset	;Hex		;Source

;******  Processing input file: template.asm

="20240704-2343040x"	Version = "20240704-2343040x"

;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-bashead-v20e.asm

>1201	0b 08		bcmd1    .word $080b ;adresse de la pro-
>1203	0a 00		         .word $0a   ;no. ligne basic.
>1205	9e		         .byte $9e   ;jeton pour la
>1206	34 36 32 31	         .text "4621";adresse du debut
>120a	00		         .byte $00   ;fin de cmd basic.
>120b	00 00		bcmd2    .word $00   ;adresse de la pro-
.120d	20 13 12	        jsr bhscrini
.1210	4c 3f 12	basnold jmp main
.1213			bhscrini
.1213	08		        php
.1214	48		        pha
.1215	a9 84		        lda #(128+4)
.1217	8d 00 90	        sta vic0
.121a	ad 0f 90	bord    lda $900f    ;place la couleur
.121d	29 08		        and #%0001000
.121f	09 65		        ora #$65
.1221	8d 0f 90	        sta $900f
.1224	a9 01		text    lda #$01    ;place la couleur
.1226	8d 86 02	        sta $0286   ; du texte.
.1229	a9 93		        lda #$93    ;efface l'ecran par
.122b	20 d2 ff	        jsr $ffd2   ; chrout du kernal.
.122e	68		        pla
.122f	28		        plp
.1230	60		        rts
.1231			bhprint
.1231	a0 00		        ldy #$00
.1233	b1 fb		nextc   lda ($fb),y
.1235	f0 07		        beq end
.1237	c8		        iny
.1238	20 d2 ff	        jsr $ffd2
.123b	4c 33 12	        jmp nextc
.123e	60		end     rts

;******  Return to file: template.asm

=1			TLINE=1
=5			BLINE=5
=6			BCOLM=6
=$00			XVAL=$00
=$00			XCPX=$00
=$5			DIFF=$5
.123f			main
.123f	08		               php
.1240	48		               pha
.1241	a9 0e		               lda  #14
.1243	20 d2 ff	               jsr  $ffd2
.1246	68		               pla
.1247	28		               plp
.1248	08		               php
.1249	48		               pha
.124a	a9 0e		               lda #(vnoir*16+(vbleu|8))
.124c	8d 0f 90	               sta  vic15
.124f	68		               pla
.1250	28		               plp
.1251	08		               php
.1252	48		               pha
.1253	a9 05		               lda  #5
.1255	8d 86 02	               sta  kcol
.1258	68		               pla
.1259	28		               plp
.125a	08		        php
.125b	48		        pha
.125c	a9 12		        lda #revson
.125e	20 7a f2	        jsr chrout
.1261	68		        pla
.1262	28		        plp
.1263	20 4a 17	               jsr  pushregs
.1266	a2 45		               ldx  #<string3
.1268	a0 16		               ldy  #>string3
.126a	20 c8 17	               jsr  putsxy
.126d	20 77 17	               jsr  popregs
.1270	08		        php
.1271	48		        pha
.1272	a9 92		        lda #revsoff
.1274	20 7a f2	        jsr chrout
.1277	68		        pla
.1278	28		        plp
.1279	08		        php
.127a	48		        pha
.127b	a9 12		        lda #revson
.127d	20 7a f2	        jsr chrout
.1280	68		        pla
.1281	28		        plp
.1282	08		               php
.1283	48		               pha
.1284	a9 03		               lda  #vocean
.1286	8d 86 02	               sta  kcol
.1289	68		               pla
.128a	28		               plp
.128b	20 4a 17	               jsr  pushregs
.128e	a2 1d		               ldx  #<string1
.1290	a0 16		               ldy  #>string1
.1292	20 c8 17	               jsr  putsxy
.1295	20 77 17	               jsr  popregs
.1298	08		        php
.1299	48		        pha
.129a	a9 92		        lda #revsoff
.129c	20 7a f2	        jsr chrout
.129f	68		        pla
.12a0	28		        plp
.12a1	08		               php
.12a2	48		               pha
.12a3	a9 01		               lda  #vblanc
.12a5	8d 86 02	               sta  kcol
.12a8	68		               pla
.12a9	28		               plp
.12aa	20 4a 17	               jsr  pushregs
.12ad	a2 34		               ldx  #<string2
.12af	a0 16		               ldy  #>string2
.12b1	20 c8 17	               jsr  putsxy
.12b4	20 77 17	               jsr  popregs
.12b7	08		               php
.12b8	48		               pha
.12b9	a9 05		               lda  #vvert
.12bb	8d 86 02	               sta  kcol
.12be	68		               pla
.12bf	28		               plp
.12c0	20 4a 17	               jsr  pushregs
.12c3	a2 64		               ldx  #<string5
.12c5	a0 16		               ldy  #>string5
.12c7	20 c8 17	               jsr  putsxy
.12ca	20 77 17	               jsr  popregs
.12cd	08		               php
.12ce	48		               pha
.12cf	a9 05		               lda  #vvert
.12d1	8d 86 02	               sta  kcol
.12d4	68		               pla
.12d5	28		               plp
.12d6	20 4a 17	               jsr  pushregs
.12d9	a2 6f		               ldx  #<string6
.12db	a0 16		               ldy  #>string6
.12dd	20 c8 17	               jsr  putsxy
.12e0	20 77 17	               jsr  popregs
.12e3	08		               php
.12e4	48		               pha
.12e5	a9 04		               lda  #vmauve
.12e7	8d 86 02	               sta  kcol
.12ea	68		               pla
.12eb	28		               plp
.12ec	20 4a 17	               jsr  pushregs
.12ef	a2 5c		               ldx  #<string4
.12f1	a0 16		               ldy  #>string4
.12f3	20 c8 17	               jsr  putsxy
.12f6	20 77 17	               jsr  popregs
.12f9	08		               php
.12fa	48		               pha
.12fb	a9 07		               lda  #vjaune
.12fd	8d 86 02	               sta  kcol
.1300	68		               pla
.1301	28		               plp
.1302	20 4a 17	               jsr  pushregs
.1305	a2 7a		               ldx  #<string7
.1307	a0 16		               ldy  #>string7
.1309	20 c8 17	               jsr  putsxy
.130c	20 77 17	               jsr  popregs
.130f	08		               php
.1310	48		               pha
.1311	a9 07		               lda  #vjaune
.1313	8d 86 02	               sta  kcol
.1316	68		               pla
.1317	28		               plp
.1318	20 4a 17	               jsr  pushregs
.131b	a2 89		               ldx  #<string8
.131d	a0 16		               ldy  #>string8
.131f	20 c8 17	               jsr  putsxy
.1322	20 77 17	               jsr  popregs
.1325	08		               php
.1326	48		               pha
.1327	a9 01		               lda  #vblanc
.1329	8d 86 02	               sta  kcol
.132c	68		               pla
.132d	28		               plp
.132e	a9 00		          lda #XVAL      ; initialise ...
.1330	8d d0 16	          sta count      ; ...le compteur
.1333	ad d0 16	next      lda count      ; Charge le compteur
.1336	38		          sec
.1337	ed d1 16	          sbc tstval     ; On on soustrait tstval de count
.133a	8d d2 16	          sta result     ;
.133d	ad d2 16	          lda  result
.1340	08		          php
.1341	68		          pla
.1342	20 21 1a	          jsr atobin
.1345	08		               php
.1346	48		               pha
.1347	a9 07		               lda  #vjaune
.1349	8d 86 02	               sta  kcol
.134c	68		               pla
.134d	28		               plp
.134e	20 4a 17	               jsr  pushregs
.1351	20 4a 17	        jsr pushregs
.1354	a0 06		        ldy #BCOLM
.1356	a2 05		        ldx #BLINE
.1358	18		        clc
.1359	20 0a e5	        jsr plot
.135c	20 77 17	        jsr popregs
.135f	20 4a 17	               jsr  pushregs
.1362	a9 25		               lda  #"%"
.1364	20 7a f2	               jsr  chrout
.1367	20 4a 17	               jsr  pushregs
.136a	a2 f2		               ldx  #<binstr
.136c	a0 27		               ldy  #>binstr
.136e	20 ba 17	               jsr  putsyx
.1371	20 77 17	               jsr  popregs
.1374	20 77 17	               jsr  popregs
.1377	20 77 17	               jsr  popregs
.137a	20 06 1a	          jsr atohex
.137d	08		               php
.137e	48		               pha
.137f	a9 07		               lda  #vjaune
.1381	8d 86 02	               sta  kcol
.1384	68		               pla
.1385	28		               plp
.1386	20 4a 17	               jsr  pushregs
.1389	20 4a 17	        jsr pushregs
.138c	a0 10		        ldy #BCOLM+10
.138e	a2 05		        ldx #BLINE
.1390	18		        clc
.1391	20 0a e5	        jsr plot
.1394	20 77 17	        jsr popregs
.1397	20 4a 17	               jsr  pushregs
.139a	a9 24		               lda  #"$"
.139c	20 7a f2	               jsr  chrout
.139f	20 4a 17	               jsr  pushregs
.13a2	a2 ff		               ldx  #<hexstr
.13a4	a0 27		               ldy  #>hexstr
.13a6	20 ba 17	               jsr  putsyx
.13a9	20 77 17	               jsr  popregs
.13ac	20 77 17	               jsr  popregs
.13af	20 77 17	               jsr  popregs
.13b2	ad d0 16	          lda count
.13b5	20 06 1a	          jsr atohex
.13b8	08		               php
.13b9	48		               pha
.13ba	a9 03		               lda  #vocean
.13bc	8d 86 02	               sta  kcol
.13bf	68		               pla
.13c0	28		               plp
.13c1	20 4a 17	               jsr  pushregs
.13c4	20 4a 17	        jsr pushregs
.13c7	a0 05		        ldy #5
.13c9	a2 09		        ldx #9
.13cb	18		        clc
.13cc	20 0a e5	        jsr plot
.13cf	20 77 17	        jsr popregs
.13d2	20 4a 17	               jsr  pushregs
.13d5	a9 24		               lda  #"$"
.13d7	20 7a f2	               jsr  chrout
.13da	20 4a 17	               jsr  pushregs
.13dd	a2 ff		               ldx  #<hexstr
.13df	a0 27		               ldy  #>hexstr
.13e1	20 ba 17	               jsr  putsyx
.13e4	20 77 17	               jsr  popregs
.13e7	20 77 17	               jsr  popregs
.13ea	20 77 17	               jsr  popregs
.13ed	ad d0 16	          lda count
.13f0	20 21 1a	          jsr atobin
.13f3	08		               php
.13f4	48		               pha
.13f5	a9 03		               lda  #vocean
.13f7	8d 86 02	               sta  kcol
.13fa	68		               pla
.13fb	28		               plp
.13fc	20 4a 17	               jsr  pushregs
.13ff	20 4a 17	        jsr pushregs
.1402	a0 0a		        ldy #10
.1404	a2 09		        ldx #9
.1406	18		        clc
.1407	20 0a e5	        jsr plot
.140a	20 77 17	        jsr popregs
.140d	20 4a 17	               jsr  pushregs
.1410	a9 25		               lda  #"%"
.1412	20 7a f2	               jsr  chrout
.1415	20 4a 17	               jsr  pushregs
.1418	a2 f2		               ldx  #<binstr
.141a	a0 27		               ldy  #>binstr
.141c	20 ba 17	               jsr  putsyx
.141f	20 77 17	               jsr  popregs
.1422	20 77 17	               jsr  popregs
.1425	20 77 17	               jsr  popregs
.1428	ad d1 16	          lda tstval
.142b	20 06 1a	          jsr atohex
.142e	08		               php
.142f	48		               pha
.1430	a9 03		               lda  #vocean
.1432	8d 86 02	               sta  kcol
.1435	68		               pla
.1436	28		               plp
.1437	20 4a 17	               jsr  pushregs
.143a	20 4a 17	        jsr pushregs
.143d	a0 05		        ldy #5
.143f	a2 0a		        ldx #10
.1441	18		        clc
.1442	20 0a e5	        jsr plot
.1445	20 77 17	        jsr popregs
.1448	20 4a 17	               jsr  pushregs
.144b	a9 24		               lda  #"$"
.144d	20 7a f2	               jsr  chrout
.1450	20 4a 17	               jsr  pushregs
.1453	a2 ff		               ldx  #<hexstr
.1455	a0 27		               ldy  #>hexstr
.1457	20 ba 17	               jsr  putsyx
.145a	20 77 17	               jsr  popregs
.145d	20 77 17	               jsr  popregs
.1460	20 77 17	               jsr  popregs
.1463	ad d1 16	          lda tstval
.1466	20 21 1a	          jsr atobin
.1469	08		               php
.146a	48		               pha
.146b	a9 03		               lda  #vocean
.146d	8d 86 02	               sta  kcol
.1470	68		               pla
.1471	28		               plp
.1472	20 4a 17	               jsr  pushregs
.1475	20 4a 17	        jsr pushregs
.1478	a0 0a		        ldy #10
.147a	a2 0a		        ldx #10
.147c	18		        clc
.147d	20 0a e5	        jsr plot
.1480	20 77 17	        jsr popregs
.1483	20 4a 17	               jsr  pushregs
.1486	a9 25		               lda  #"%"
.1488	20 7a f2	               jsr  chrout
.148b	20 4a 17	               jsr  pushregs
.148e	a2 f2		               ldx  #<binstr
.1490	a0 27		               ldy  #>binstr
.1492	20 ba 17	               jsr  putsyx
.1495	20 77 17	               jsr  popregs
.1498	20 77 17	               jsr  popregs
.149b	20 77 17	               jsr  popregs
.149e	ad d2 16	          lda result
.14a1	20 06 1a	          jsr atohex
.14a4	08		               php
.14a5	48		               pha
.14a6	a9 03		               lda  #vocean
.14a8	8d 86 02	               sta  kcol
.14ab	68		               pla
.14ac	28		               plp
.14ad	20 4a 17	               jsr  pushregs
.14b0	20 4a 17	        jsr pushregs
.14b3	a0 05		        ldy #5
.14b5	a2 0c		        ldx #12
.14b7	18		        clc
.14b8	20 0a e5	        jsr plot
.14bb	20 77 17	        jsr popregs
.14be	20 4a 17	               jsr  pushregs
.14c1	a9 24		               lda  #"$"
.14c3	20 7a f2	               jsr  chrout
.14c6	20 4a 17	               jsr  pushregs
.14c9	a2 ff		               ldx  #<hexstr
.14cb	a0 27		               ldy  #>hexstr
.14cd	20 ba 17	               jsr  putsyx
.14d0	20 77 17	               jsr  popregs
.14d3	20 77 17	               jsr  popregs
.14d6	20 77 17	               jsr  popregs
.14d9	ad d2 16	          lda result
.14dc	20 21 1a	          jsr atobin
.14df	08		               php
.14e0	48		               pha
.14e1	a9 03		               lda  #vocean
.14e3	8d 86 02	               sta  kcol
.14e6	68		               pla
.14e7	28		               plp
.14e8	20 4a 17	               jsr  pushregs
.14eb	20 4a 17	        jsr pushregs
.14ee	a0 0a		        ldy #10
.14f0	a2 0c		        ldx #12
.14f2	18		        clc
.14f3	20 0a e5	        jsr plot
.14f6	20 77 17	        jsr popregs
.14f9	20 4a 17	               jsr  pushregs
.14fc	a9 25		               lda  #"%"
.14fe	20 7a f2	               jsr  chrout
.1501	20 4a 17	               jsr  pushregs
.1504	a2 f2		               ldx  #<binstr
.1506	a0 27		               ldy  #>binstr
.1508	20 ba 17	               jsr  putsyx
.150b	20 77 17	               jsr  popregs
.150e	20 77 17	               jsr  popregs
.1511	20 77 17	               jsr  popregs
.1514	ad d0 16	          lda count
.1517	18		          clc
.1518	69 05		          adc #DIFF
.151a	8d d0 16	          sta count
.151d	ad d1 16	          lda tstval
.1520	38		          sec
.1521	e9 05		          sbc #DIFF
.1523	8d d1 16	          sta tstval
.1526	20 9f 1b	          jsr getkey
.1529	c9 5f		          cmp  #$5f
.152b	d0 03		          bne continue
.152d	4c 7c 15	          jmp out
.1530			continue
.1530	20 4a 17	        jsr pushregs
.1533	a0 06		        ldy #6
.1535	a2 12		        ldx #18
.1537	18		        clc
.1538	20 0a e5	        jsr plot
.153b	20 77 17	        jsr popregs
.153e	20 06 1a	          jsr atohex
.1541	20 4a 17	               jsr  pushregs
.1544	20 4a 17	        jsr pushregs
.1547	a0 0f		        ldy #15
.1549	a2 12		        ldx #18
.154b	18		        clc
.154c	20 0a e5	        jsr plot
.154f	20 77 17	        jsr popregs
.1552	20 4a 17	               jsr  pushregs
.1555	a9 24		               lda  #"$"
.1557	20 7a f2	               jsr  chrout
.155a	20 4a 17	               jsr  pushregs
.155d	a2 ff		               ldx  #<hexstr
.155f	a0 27		               ldy  #>hexstr
.1561	20 ba 17	               jsr  putsyx
.1564	20 77 17	               jsr  popregs
.1567	20 77 17	               jsr  popregs
.156a	20 77 17	               jsr  popregs
.156d	08		        php
.156e	48		        pha
.156f	a9 20		        lda #32
.1571	20 7a f2	        jsr chrout
.1574	68		        pla
.1575	28		        plp
.1576	20 7a f2	          jsr chrout
.1579	4c 33 13	          jmp next
.157c			out
.157c	08		        php
.157d	48		        pha
.157e	a9 93		        lda #147
.1580	20 7a f2	        jsr chrout
.1583	68		        pla
.1584	28		        plp
.1585	20 d8 16	               jsr  pushall
.1588	ad d6 16	               lda  adresse
.158b	85 fb		               sta  $fb
.158d	ad d7 16	               lda  adresse+1
.1590	85 fc		               sta  $fb+1
.1592	a0 01		               ldy  #$01
.1594	b1 fb		               lda  ($fb),y
.1596	20 21 1a	               jsr  atobin
.1599	20 4a 17	               jsr  pushregs
.159c	a9 25		               lda  #"%"
.159e	20 7a f2	               jsr  chrout
.15a1	20 4a 17	               jsr  pushregs
.15a4	a2 f2		               ldx  #<binstr
.15a6	a0 27		               ldy  #>binstr
.15a8	20 ba 17	               jsr  putsyx
.15ab	20 77 17	               jsr  popregs
.15ae	20 77 17	               jsr  popregs
.15b1	88		               dey
.15b2	b1 fb		               lda  ($fb),y
.15b4	20 21 1a	               jsr  atobin
.15b7	20 4a 17	               jsr  pushregs
.15ba	a2 f2		               ldx  #<binstr
.15bc	a0 27		               ldy  #>binstr
.15be	20 ba 17	               jsr  putsyx
.15c1	20 77 17	               jsr  popregs
.15c4	20 11 17	               jsr  popall
.15c7	20 9f 1b	          jsr getkey
.15ca	08		        php
.15cb	48		        pha
.15cc	a9 93		        lda #147
.15ce	20 7a f2	        jsr chrout
.15d1	68		        pla
.15d2	28		        plp
.15d3	a2 07		          ldx  #$7
.15d5	8a		more      txa
.15d6	49 0f		          eor #$0f
.15d8	29 0f		          and #$0f
.15da	8d 86 02	          sta kcol
.15dd	20 d8 16	        jsr pushall
.15e0	a0 16		        ldy #>teststr
.15e2	84 fc		        sty zp1+1
.15e4	a2 bb		        ldx #<teststr
.15e6	86 fb		        stx zp1
.15e8	20 a4 17	        jsr puts
.15eb	20 11 17	        jsr popall
.15ee	20 d8 16	        jsr pushall
.15f1	a0 16		        ldy #>teststr
.15f3	84 fc		        sty zp1+1
.15f5	a2 bb		        ldx #<teststr
.15f7	86 fb		        stx zp1
.15f9	20 a4 17	        jsr puts
.15fc	20 11 17	        jsr popall
.15ff	ca		          dex
.1600	10 d3		          bpl more
.1602	08		               php
.1603	48		               pha
.1604	a9 01		               lda  #vblanc
.1606	8d 86 02	               sta  kcol
.1609	68		               pla
.160a	28		               plp
.160b	60		          rts
.160c			delay65536
.160c	20 4a 17	          jsr pushregs
.160f	a2 00		          ldx #$00
.1611	a0 00		          ldy #$00
.1613	88		waity     dey
.1614	d0 fd		          bne waity
.1616	ca		waitx     dex
.1617	d0 fa		          bne waity
.1619	20 77 17	          jsr popregs
.161c	60		          rts
>161d	01 00 d4 45	string1   .text     1,0,"Test de Drapeaux CPU",0
>1621	53 54 20 44 45 20 c4 52 41 50 45 41 55 58 20 c3
>1631	d0 d5 00
>1634	01 02 c6 cc	string2   .text     BCOLM-5,BLINE-3,"FLAGS:NV-BDIZC",0
>1638	c1 c7 d3 3a ce d6 2d c2 c4 c9 da c3 00
>1645	01 15 d0 41	string3   .text     1,21,"Par: Daniel Lafrance",0
>1649	52 3a 20 c4 41 4e 49 45 4c 20 cc 41 46 52 41 4e
>1659	43 45 00
>165c	0f 05 28 20	string4   .text     BCOLM+9,BLINE,"(   )",0
>1660	20 20 29 00
>1664	07 03 5e 5e	string5   .byte     BCOLM+1,BLINE-2,94,94,32,94,94,94,94,94,0
>1668	20 5e 5e 5e 5e 5e 00
>166f	07 04 7d 7d	string6   .byte     BCOLM+1,BLINE-1,125,125,'?'
>1673	3f
>1674	7d 7d 7d 7d	          .byte     125,125,125,125,125,0
>1678	7d 00
>167a	04 12 c7 45	string7   .text     4,18,"Getkey() = $",0
>167e	54 4b 45 59 28 29 20 3d 20 24 00
>1689	00 09		string8   .byte     0,9
>168b	20 20 20 20	          .text     '    $',13
>168f	24 0d
>1691	20 20 20 2d	          .text     '   -','$    -'
>1695	24 20 20 20 20 2d
>169b	0d 20 20 20	          .byte     13,32,32,32,32,32,45,45,45,32
>169f	20 20 2d 2d 2d 20
>16a5	20 2d 2d 2d	          .byte     32,45,45,45,45,45,45,45,45,45,13
>16a9	2d 2d 2d 2d 2d 2d 0d
>16b0	20 20 20	          .byte     32,32,32
>16b3	3d 24 20 20	          .null     "=$    ="
>16b7	20 20 3d 00
>16bb	12 20 20	teststr   .byte     revson,32,32
>16be	20 20 20 20	          .text     "               "
>16c2	20 20 20 20 20 20 20 20 20 20 20
>16cd	92 0d 00	          .byte     revsoff,$0d,eot
>16d0	00		count     .byte     XVAL
>16d1	00		tstval    .byte     XCPX
>16d2	00		result    .byte     0
>16d3	00		flags     .byte     0
>16d4	00		row       .byte     0
>16d5	00		lin       .byte     0
>16d6	3f 12		adresse   .word     main

;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-push.asm

.16d8			pushall
.16d8	08		         php     ;s;rp,pcl,pch
.16d9	8d 11 28	         sta ra  ;sauve a
.16dc	68		         pla     ;s:pcl,pch
.16dd	8d 12 28	         sta rp  ;sauve rp
.16e0	68		         pla     ;s:pch
.16e1	8d 0c 28	         sta pc  ;sauve pcl
.16e4	68		         pla     ;s:
.16e5	8d 0d 28	         sta pc+1;sauve pch
.16e8	a5 fb		         lda $fb ;sauve fb
.16ea	48		         pha     ;s:fb
.16eb	a5 fc		         lda $fc ;sauve fc
.16ed	48		         pha     ;s:fc,fb
.16ee	a5 fd		         lda $fd ;sauve fd
.16f0	48		         pha     ;s:fd,fc,fb
.16f1	a5 fe		         lda $fe ;sauve fe
.16f3	48		         pha     ;s:fe,fd,fc,fb
.16f4	ad 12 28	         lda rp  ;sauve rp
.16f7	48		         pha     ;s:rp,fe,fd,fc,fb
.16f8	ad 11 28	         lda ra  ;sauve ra
.16fb	48		         pha     ;s:ra,rp,fe,fd,fc,fb
.16fc	8a		         txa     ;sauve rx
.16fd	48		         pha     ;s:rx,ra,rp,fe-fb
.16fe	98		         tya     ;sauve y
.16ff	48		         pha     ;s:ry,rx,ra,rp,fe-fb
.1700	ad 0d 28	         lda pc+1;replace l'adresse
.1703	48		         pha     ;s:pch,ry,rx,ra,...
.1704	ad 0c 28	         lda pc  ; de retour.
.1707	48		         pha     ;s:pcl,pch,ru,rx,ra,...
.1708	ad 12 28	         lda rp  ;place les flags
.170b	48		         pha     ; sur le stack.
.170c	ad 11 28	         lda ra  ;recupere ra
.170f	28		         plp     ;recupere les flags.
.1710	60		         rts
.1711			popall
.1711	08		         php     ;s:rp,pcl,pch,ry,rx,...
.1712	8d 11 28	         sta ra
.1715	68		         pla     ;s:pcl,pch,ry,rx,...
.1716	8d 12 28	         sta rp  ;s:pch,ry,rx,ra,rp,...
.1719	68		         pla
.171a	8d 0c 28	         sta pc  ;sauve pcl
.171d	68		         pla     ;s:ry,rx,ra,rp,fe...fb
.171e	8d 0d 28	         sta pc+1;sauve pch
.1721	68		         pla     ;s:rx,ra,rp,fe,fd,fc,fb
.1722	a8		         tay     ;recupere ry
.1723	68		         pla     ;s:ra,rp,fe,fd,fc,fb
.1724	aa		         tax     ;recupere rx
.1725	68		         pla     ;s:rp,fe,fd,fc,fb
.1726	8d 11 28	         sta ra  ;recupere ra
.1729	68		         pla     ;s:fe,fd,fc,fb
.172a	8d 12 28	         sta rp  ;recupere les flags.
.172d	68		         pla     ;s:fd,fc,fb
.172e	85 fe		         sta $fe ;reccupere fe
.1730	68		         pla     ;s:fc,fb
.1731	85 fd		         sta $fd ;recupere fd
.1733	68		         pla     ;s:fb
.1734	85 fc		         sta $fc ;recupere fc
.1736	68		         pla     ;s:
.1737	85 fb		         sta $fb ;recupere fb
.1739	ad 0d 28	         lda pc+1;replaace l'adresse de
.173c	48		         pha     ;s:pch
.173d	ad 0c 28	         lda pc  ;retour sur la pile
.1740	48		         pha     ;s:pcl,pch
.1741	ad 12 28	         lda rp  ;recupere les flags
.1744	48		         pha     ;s:rp,pcl,pch
.1745	ad 11 28	         lda ra  ;recupere ra
.1748	28		         plp     ;s:pcl,pch
.1749	60		         rts
.174a			pushregs
.174a	08		         php     ;s;rp,pcl,pch
.174b	8d 11 28	         sta ra  ; -- sauve a
.174e	68		         pla     ;s:pcl,pch
.174f	8d 12 28	         sta rp  ; -- sauve rp
.1752	68		         pla     ;s:pch
.1753	8d 0c 28	         sta pc  ; -- sauve pcl
.1756	68		         pla     ;s:
.1757	8d 0d 28	         sta pc+1; -- sauve pch
.175a	ad 12 28	         lda rp  ; -- sauve rp
.175d	48		         pha     ;s:rp
.175e	ad 11 28	         lda ra  ; -- sauve ra
.1761	48		         pha     ;s:ra,rp
.1762	8a		         txa     ; -- tfr rx
.1763	48		         pha     ;s:rx,ra,rp
.1764	98		         tya     ; -- tfr ry
.1765	48		         pha     ;s:ry,rx,ra,rp
.1766	ad 0d 28	         lda pc+1; -- replace l'adresse
.1769	48		         pha     ;s:pch,ry,rx,ra,rp
.176a	ad 0c 28	         lda pc  ; -- de retour.
.176d	48		         pha     ;s:pcl,pch,ru,rx,ra,rp
.176e	ad 12 28	         lda rp  ; -- place les flags
.1771	48		         pha     ;    sur le stack.
.1772	ad 11 28	         lda ra  ; -- recupere ra
.1775	28		         plp     ; -- recupere flags.
.1776	60		         rts     ;s:pcl,pch,ru,rx,ra,rp
.1777			popregs
.1777	08		         php
.1778	8d 11 28	         sta ra
.177b	68		         pla
.177c	8d 12 28	         sta rp
.177f	68		         pla     ;s:pch,ry,rx,ra,rp
.1780	8d 0c 28	         sta pc  ; -- sauve pcl
.1783	68		         pla     ;s:ry,rx,ra,rp
.1784	8d 0d 28	         sta pc+1; -- sauve pch
.1787	68		         pla     ;s:rx,ra,rp
.1788	a8		         tay     ;recupere ry
.1789	68		         pla     ;s:ra,rp
.178a	aa		         tax     ;recupere rx
.178b	68		         pla     ;s:rp
.178c	8d 11 28	         sta ra  ;recupere ra
.178f	68		         pla     ;s:
.1790	8d 12 28	         sta rp  ;recupere les flags.
.1793	ad 0d 28	         lda pc+1;replace l'adresse de
.1796	48		         pha     ;s:pch
.1797	ad 0c 28	         lda pc  ;retour sur la pile
.179a	48		         pha     ;s:pcl,pch
.179b	ad 12 28	         lda rp  ;recupere les flags
.179e	48		         pha     ;s:rp,pcl,pch
.179f	ad 11 28	         lda ra  ;recupere ra
.17a2	28		         plp     ;s:pcl,pch
.17a3	60		         rts

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-string.asm

.17a4			puts
.17a4	20 d8 16	        jsr pushall
.17a7	a0 00		        ldy #$00   ; y = offset
.17a9	b1 fb		nextc   lda ($fb),y;lit un caractere
.17ab	f0 09		        beq out    ;si 0 on sort
.17ad	20 7a f2	        jsr chrout ;on l'affiche
.17b0	20 de 18	        jsr inczp1 ;pointe le prochain
.17b3	4c a9 17	        jmp nextc  ; et l'affiche
.17b6	20 11 17	out     jsr popall
.17b9	60		        rts
.17ba			putsyx
.17ba	20 d8 16	        jsr pushall;sauve reg + zps
.17bd	86 fb		        stx $fb    ;$yyxx dans
.17bf	84 fc		        sty $fb+1  ; zp1
.17c1	20 a4 17	        jsr puts
.17c4	20 11 17	        jsr popall ;recup reg + zps
.17c7	60		        rts
.17c8			putsxy
.17c8	20 d8 16	        jsr pushall;sauve reg + zps
.17cb	86 fb		        stx $fb    ;$yyxx dans
.17cd	84 fc		        sty $fb+1  ; zp1
.17cf	a0 00		        ldy #$00
.17d1	b1 fb		        lda ($fb),y
.17d3	aa		        tax
.17d4	20 de 18	        jsr inczp1
.17d7	b1 fb		        lda ($fb),y
.17d9	20 de 18	        jsr inczp1
.17dc	a8		        tay
.17dd	20 32 18	        jsr gotoxy
.17e0	20 a4 17	        jsr puts
.17e3	20 11 17	        jsr popall ;recup reg + zps
.17e6	60		        rts
.17e7			putsc
.17e7	08		        php        ;flag sur stack
.17e8	48		        pha        ;acc sur stack
.17e9	48		        pha        ;sauvegarde acc
.17ea	ad 86 02	        lda kcol   ;recup coul. carac.
.17ed	8d 0b 28	        sta curcol ; et la sauvegarde
.17f0	68		        pla        ;recup. acc
.17f1	8d 86 02	        sta kcol   ;place coul. voulue
.17f4	20 a4 17	        jsr puts   ;affiche la chaine
.17f7	ad 0b 28	        lda curcol ;recup coul. carac.
.17fa	8d 86 02	        sta kcol   ; et la replace
.17fd	68		        pla        ;recup acc
.17fe	28		        plp        ;recup flag
.17ff	60		        rts
.1800			putscyx
.1800	08		        php       ;sauve registres
.1801	48		        pha       ; ...
.1802	48		        pha       ;sauve acc
.1803	ad 86 02	        lda kcol  ;recup couleur carac.
.1806	8d 0b 28	        sta curcol; et sauvegarde
.1809	68		        pla       ;recup acc
.180a	8d 86 02	        sta kcol  ;place couleur carac.
.180d	20 ba 17	        jsr putsyx;affiche la chaine
.1810	ad 0b 28	        lda curcol
.1813	8d 86 02	        sta kcol
.1816	68		        pla
.1817	28		        plp
.1818	60		        rts
.1819			putscxy
.1819	08		        php       ;sauve registres
.181a	48		        pha       ; ...
.181b	48		        pha       ;sauve acc
.181c	ad 86 02	        lda kcol  ;recup couleur carac.
.181f	8d 0b 28	        sta curcol; et sauvegarde
.1822	68		        pla       ;recup acc
.1823	8d 86 02	        sta kcol   ;place couleur carac.
.1826	20 ba 17	        jsr putsyx ;affiche la chaine
.1829	ad 0b 28	        lda curcol
.182c	8d 86 02	        sta kcol
.182f	68		        pla
.1830	28		        plp
.1831	60		        rts
.1832			gotoxy
.1832	20 4a 17	        jsr pushregs
.1835	8a		        txa ; interchange x et y
.1836	48		        pha ; ...
.1837	98		        tya ; ...
.1838	aa		        tax ; ...
.1839	68		        pla ; ...
.183a	a8		        tay ; ...
.183b	c0 00		txlow   cpy #0
.183d	10 02		        bpl txhigh
.183f	a2 00		        ldx #0
.1841	e0 19		txhigh  cpx #25
.1843	30 02		        bmi tylow
.1845	a2 18		        ldx #24
.1847	c0 00		tylow   cpy #0
.1849	10 02		        bpl tyhigh
.184b	a0 00		        ldy #0
.184d	c0 28		tyhigh  cpy #40
.184f	30 02		        bmi allok
.1851	a0 27		        ldy #39
.1853	18		allok   clc
.1854	20 0a e5	        jsr plot
.1857	20 77 17	        jsr popregs
.185a	60		        rts
.185b			putnch
.185b	20 4a 17	        jsr pushregs
.185e	20 7a f2	again   jsr chrout
.1861	ca		        dex
.1862	d0 fa		        bne again
.1864	20 77 17	        jsr popregs
.1867	60		        rts
.1868			strlen
.1868	20 d8 16	        jsr pushall
.186b	84 fc		        sty zp1+1
.186d	86 fb		        stx zp1
.186f	a0 00		        ldy #$00
.1871	8c 9d 27	        sty len
.1874	b1 fb		next    lda (zp1),y
.1876	f0 07		        beq out
.1878	ee 9d 27	        inc len
.187b	c8		        iny
.187c	4c 74 18	        jmp next
.187f	20 11 17	out     jsr popall
.1882	ad 9d 27	        lda len
.1885	60		        rts
.1886			cursor
.1886	20 4a 17	        jsr  pushregs
.1889	90 12		        bcc  get    ;C=0 récupération.
.188b	20 0a e5	        jsr  plot  ;récupère position
.188e	8c 9c 27	        sty  cx     ;curseur et sauve
.1891	8e 9b 27	        stx  cy     ;dans vars locales.
.1894	ad 86 02	        lda  kcol   ;Sauve couleur
.1897	8d 9a 27	        sta  bcol   ; BASIC du texte.
.189a	4c ac 18	        jmp  out    ;Fini on sort.
.189d	ae 9b 27	get     ldx  cy     ;C=1, charge x
.18a0	ac 9c 27	        ldy  cx     ; ligne, y col.
.18a3	20 0a e5	        jsr  plot  ;Position curseur.
.18a6	ad 9a 27	        lda  bcol   ;replace couleur
.18a9	8d 86 02	        sta  kcol ; basic sauvegardé.
.18ac	20 77 17	out     jsr  popregs
.18af	60		        rts
.18b0			cursave
.18b0	08		        php
.18b1	38		        sec
.18b2	20 86 18	        jsr  cursor
.18b5	28		        plp
.18b6	60		        rts
.18b7			curput
.18b7	08		        php
.18b8	18		        clc
.18b9	20 86 18	        jsr  cursor
.18bc	28		        plp
.18bd	60		        rts

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-mem.asm

.18be			blkfill
.18be	20 d8 16	bf0     jsr pushall
.18c1	84 fc		        sty zp1+1
.18c3	a0 00		        ldy #$00
.18c5	84 fb		        sty zp1
.18c7	91 fb		bf1     sta (zp1),y
.18c9	c8		        iny
.18ca	d0 fb		        bne bf1
.18cc	20 11 17	        jsr popall
.18cf	60		        rts
.18d0			memfill
.18d0	20 4a 17	        jsr pushregs
.18d3	20 be 18	mf1     jsr blkfill
.18d6	c8		        iny
.18d7	ca		        dex
.18d8	d0 f9		        bne mf1
.18da	20 77 17	        jsr popregs
.18dd	60		        rts
.18de			inczp1
.18de	08		         php
.18df	e6 fb		         inc zp1
.18e1	d0 02		         bne repzp1
.18e3	e6 fc		         inc zp1+1
.18e5	28		repzp1   plp
.18e6	60		         rts
.18e7			inczp2
.18e7	08		         php
.18e8	e6 fd		         inc zp2
.18ea	d0 02		         bne repzp2
.18ec	e6 fe		         inc zp2+1
.18ee	28		repzp2   plp
.18ef	60		         rts
.18f0			deczp1
.18f0	08		         php
.18f1	48		         pha
.18f2	a5 fb		         lda zp1
.18f4	d0 02		         bne noemp
.18f6	c6 fc		         dec zp1+1
.18f8	c6 fb		noemp    dec zp1
.18fa	68		         pla
.18fb	28		         plp
.18fc	60		         rts
.18fd			deczp2
.18fd	08		         php
.18fe	48		         pha
.18ff	a5 fd		         lda zp2
.1901	d0 02		         bne noemp
.1903	c6 fe		         dec zp2+1
.1905	c6 fd		noemp    dec zp2
.1907	68		         pla
.1908	28		         plp
.1909	60		         rts
.190a			rolzp1
.190a	08		        php
.190b	48		        pha
.190c	18		        clc
.190d	a5 fb		        lda zp1
.190f	2a		        rol
.1910	85 fb		        sta zp1
.1912	a5 fc		        lda zp1+1
.1914	2a		        rol
.1915	85 fc		        sta zp1+1
.1917	68		        pla
.1918	28		        plp
.1919			rorzp1
.1919	08		        php
.191a	48		        pha
.191b	18		        clc
.191c	a5 fc		        lda zp1+1
.191e	6a		        ror
.191f	85 fc		        sta zp1+1
.1921	a5 fb		        lda zp1
.1923	6a		        ror
.1924	85 fb		        sta zp1
.1926	68		        pla
.1927	28		        plp
.1928			rolzp2
.1928	08		        php
.1929	48		        pha
.192a	18		        clc
.192b	a5 fd		        lda zp2
.192d	2a		        rol
.192e	85 fd		        sta zp2
.1930	a5 fe		        lda zp2+1
.1932	2a		        rol
.1933	85 fe		        sta zp2+1
.1935	68		        pla
.1936	28		        plp
.1937			rorzp2
.1937	08		        php
.1938	48		        pha
.1939	18		        clc
.193a	a5 fe		        lda zp2+1
.193c	6a		        ror
.193d	85 fe		        sta zp2+1
.193f	a5 fd		        lda zp2
.1941	6a		        ror
.1942	85 fd		        sta zp2
.1944	68		        pla
.1945	28		        plp
.1946			yxtoptr
.1946	8c 0b 28	        sty memptr+1
.1949	8e 0a 28	        stx memptr
.194c	60		        rts
.194d			ptrtoyx
.194d	08		        php
.194e	ac 0b 28	        ldy memptr+1
.1951	ae 0a 28	        ldx memptr
.1954	28		        plp
.1955	60		        rts
.1956			incptr
.1956	08		        php
.1957	ee 0a 28	        inc memptr
.195a	d0 03		        bne norep
.195c	ee 0b 28	        inc memptr+1
.195f	28		norep   plp
.1960	60		        rts
.1961			decptr
.1961	08		        php
.1962	48		        pha
.1963	ad 0a 28	        lda memptr
.1966	d0 03		        bne noemp
.1968	ee 0b 28	        inc memptr+1
.196b	ee 0a 28	noemp   inc memptr
.196e	68		        pla
.196f	28		        plp
.1970	60		        rts
.1971			incptr8
.1971	08		        php
.1972	48		        pha
.1973	98		        tya
.1974	48		        pha
.1975	a0 08		        ldy #8
.1977	20 56 19	again   jsr incptr
.197a	88		        dey
.197b	d0 fa		        bne again
.197d	68		        pla
.197e	a8		        tay
.197f	68		        pla
.1980	28		        plp
.1981	60		        rts
.1982			loop
.1982	ce 04 28	               dec  loopcount
.1985	d0 03		               bne  norep
.1987	ce 05 28	               dec  loopcount+1
.198a	ad 04 28	norep          lda  loopcount
.198d	c9 00		               cmp  #$00
.198f	d0 05		               bne  out
.1991	4d 05 28	               eor  loopcount+1
.1994	c9 ff		               cmp  #$ff
.1996	60		out            rts

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-math.asm

.1997			addtoword
.1997			addatoyx
.1997	08		        php
.1998	48		        pha
.1999	8c ab 27	        sty reponse+1
.199c	8e aa 27	        stx reponse
.199f	18		        clc
.19a0	6d aa 27	        adc reponse
.19a3	90 03		        bcc norep
.19a5	ee ab 27	        inc reponse+1
.19a8	8d aa 27	norep   sta reponse
.19ab	ac ab 27	        ldy reponse+1
.19ae	ae aa 27	        ldx reponse
.19b1	68		        pla
.19b2	28		        plp
.19b3	60		        rts
.19b4			subtoword
.19b4			subatoyx
.19b4	08		        php
.19b5	48		        pha
.19b6	8c ab 27	        sty reponse+1
.19b9	8e aa 27	        stx reponse
.19bc	38		        sec
.19bd	ed aa 27	        sbc reponse
.19c0	b0 03		        bcs noemp
.19c2	ce ab 27	        dec reponse+1
.19c5	8d aa 27	noemp   sta reponse
.19c8	ac ab 27	        ldy reponse+1
.19cb	ae aa 27	        ldx reponse
.19ce	68		        pla
.19cf	28		        plp
.19d0	60		        rts

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-conv.asm

.19d1			putyxhex
.19d1	20 d8 16	        jsr pushall
.19d4	98		        tya
.19d5	48		        pha
.19d6	20 43 1a	        jsr lsr4bits
.19d9	20 4a 1a	        jsr nibtohex
.19dc	8d ff 27	        sta hexstr+0
.19df	68		        pla
.19e0	20 4a 1a	        jsr nibtohex
.19e3	8d 00 28	        sta hexstr+1
.19e6	8a		        txa
.19e7	20 06 1a	        jsr atohex
.19ea	a2 ff		        ldx #<hexstr+0
.19ec	a0 27		        ldy #>hexstr+0
.19ee	20 ba 17	        jsr putsyx
.19f1	20 11 17	        jsr popall
.19f4	60		        rts
.19f5			putahex
.19f5	20 4a 17	        jsr pushregs
.19f8	20 06 1a	        jsr atohex
.19fb	a2 01		        ldx #<hexstr+2
.19fd	a0 28		        ldy #>hexstr+2
.19ff	20 ba 17	        jsr putsyx
.1a02	20 77 17	        jsr popregs
.1a05	60		        rts
.1a06			atohex
.1a06	08		        php
.1a07	48		        pha
.1a08	48		        pha
.1a09	20 43 1a	        jsr lsr4bits
.1a0c	20 4a 1a	        jsr nibtohex
.1a0f	8d ff 27	        sta hexstr
.1a12	68		        pla
.1a13	20 4a 1a	        jsr nibtohex
.1a16	8d 00 28	        sta hexstr+1
.1a19	a9 00		        lda #$00
.1a1b	8d 01 28	        sta hexstr+2
.1a1e	68		        pla
.1a1f	28		        plp
.1a20	60		        rts
.1a21			atobin
.1a21	20 4a 17	               jsr  pushregs
.1a24	a2 08		               ldx  #8
.1a26	a0 00		               ldy  #0
.1a28	18		               clc
.1a29	2a		nextbit        rol
.1a2a	48		               pha
.1a2b	69 00		               adc  #$00
.1a2d	29 01		               and  #$01
.1a2f	20 4a 1a	               jsr  nibtohex
.1a32	99 f2 27	               sta  binstr,y
.1a35	68		               pla
.1a36	c8		               iny
.1a37	ca		               dex
.1a38	d0 ef		               bne  nextbit
.1a3a	a9 00		               lda  #0
.1a3c	99 f2 27	               sta  binstr,y
.1a3f	20 77 17	               jsr  popregs
.1a42	60		               rts
.1a43			lsr4bits
.1a43	08		        php
.1a44	4a		        lsr a
.1a45	4a		        lsr a
.1a46	4a		        lsr a
.1a47	4a		        lsr a
.1a48	28		        plp
.1a49	60		        rts
.1a4a			nibtohex
.1a4a	08		        php
.1a4b	29 0f		        and    #$0f
.1a4d	f8		        sed
.1a4e	18		        clc
.1a4f	69 90		        adc #$90
.1a51	69 40		        adc #$40
.1a53	28		        plp
.1a54	60		        rts
.1a55			bytestohex
.1a55	20 d8 16	        jsr pushall
.1a58	84 fc		        sty zp1+1
.1a5a	86 fb		        stx zp1
.1a5c	08		        php
.1a5d	48		        pha
.1a5e	a9 20		        lda #32
.1a60	20 7a f2	        jsr chrout
.1a63	68		        pla
.1a64	28		        plp
.1a65	08		        php
.1a66	48		        pha
.1a67	a9 05		        lda #5
.1a69	20 7a f2	        jsr chrout
.1a6c	68		        pla
.1a6d	28		        plp
.1a6e	08		        php
.1a6f	48		        pha
.1a70	a9 24		        lda #36
.1a72	20 7a f2	        jsr chrout
.1a75	68		        pla
.1a76	28		        plp
.1a77	20 d1 19	        jsr putyxhex   ; prn adreponsese
.1a7a	08		        php
.1a7b	48		        pha
.1a7c	a9 20		        lda #$20
.1a7e	20 7a f2	        jsr chrout
.1a81	68		        pla
.1a82	28		        plp
.1a83	08		        php
.1a84	48		        pha
.1a85	a9 9f		        lda #159
.1a87	20 7a f2	        jsr chrout
.1a8a	68		        pla
.1a8b	28		        plp
.1a8c	a0 00		        ldy #$00
.1a8e	aa		        tax
.1a8f	8c e3 27	another sty offset
.1a92	b1 fb		        lda (zp1),y
.1a94	20 f5 19	        jsr putahex
.1a97	48		        pha
.1a98	20 b7 1a	        jsr petsciiaddr
.1a9b	68		        pla
.1a9c	8d 00 04	petscii sta $0400
.1a9f	48		        pha
.1aa0	a9 0d		        lda #$0d
.1aa2	8d 00 d8	petcol  sta $d800
.1aa5	68		        pla
.1aa6	08		        php
.1aa7	48		        pha
.1aa8	a9 20		        lda #$20
.1aaa	20 7a f2	        jsr chrout
.1aad	68		        pla
.1aae	28		        plp
.1aaf	c8		        iny
.1ab0	ca		        dex
.1ab1	d0 dc		        bne another
.1ab3	20 11 17	        jsr popall
.1ab6	60		        rts
.1ab7			petsciiaddr
.1ab7	20 4a 17	        jsr pushregs
.1aba	08		        php
.1abb	a4 d2		        ldy scrnlin+1
.1abd	a6 d1		        ldx scrnlin
.1abf	28		        plp
.1ac0	a9 1f		        lda #31
.1ac2	18		        clc
.1ac3	6d e3 27	        adc offset
.1ac6	20 97 19	        jsr addatoyx
.1ac9	8c 9e 1a	        sty petscii+2
.1acc	8e 9d 1a	        stx petscii+1
.1acf	8e a3 1a	        stx petcol+1
.1ad2	98		        tya
.1ad3	29 fb		        and #%11111011 ;#%00000100
.1ad5	09 d8		        ora #$d8
.1ad7	8d a4 1a	        sta petcol+2
.1ada	a8		        tay
.1adb	20 77 17	        jsr popregs
.1ade	60		        rts
.1adf			strhexval
.1adf	20 d8 16	        jsr pushall ; sauve registre
.1ae2	84 fc		        sty zp1+1   ; ptr dans zp1
.1ae4	86 fb		        stx zp1
.1ae6	20 68 18	        jsr strlen  ;len de $(yyxx)->a
.1ae9	f0 3d		        beq oute    ; si 0 erreur C=1
.1aeb	a0 00		        ldy #$00    ; offset a 0
.1aed	8c ab 27	        sty reponse+1; reponse a zero
.1af0	8c aa 27	        sty reponse ;    ...
.1af3	b1 fb		nextc   lda (zp1),y ;charge un caractere
.1af5	f0 26		        beq out     ;On  a fini
.1af7	c0 00		        cpy #$00    ;si c'est le premier
.1af9	f0 07		        beq norol   ; pas de rol
.1afb	48		        pha         ;
.1afc	a9 04		        lda #$04    ;rol de 4 pos
.1afe	20 58 1b	        jsr rolword ;
.1b01	68		        pla         ;
.1b02	09 20		norol   ora #%00100000
.1b04	38		        sec
.1b05	e9 30		        sbc #$30
.1b07	c9 0a		        cmp #$0a
.1b09	90 07		        bcc lt10
.1b0b	38		        sec
.1b0c	e9 27		        sbc #$27
.1b0e	c9 10		        cmp #$10
.1b10	b0 16		        bcs oute
.1b12	0d aa 27	lt10    ora reponse
.1b15	8d aa 27	        sta reponse
.1b18	c8		        iny
.1b19	c0 04		        cpy #$04
.1b1b	d0 d6		        bne nextc
.1b1d	20 11 17	out     jsr popall
.1b20	18		        clc          ;Carry 0 = good
.1b21	ac ab 27	        ldy reponse+1
.1b24	ae aa 27	        ldx reponse
.1b27	60		        rts
.1b28	20 11 17	oute    jsr popall
.1b2b	38		        sec
.1b2c	60		        rts
.1b2d			putahexdec
.1b2d	20 4a 17	        jsr pushregs
.1b30	08		        php
.1b31	48		        pha
.1b32	a9 9e		        lda #sjaune
.1b34	20 7a f2	        jsr chrout
.1b37	68		        pla
.1b38	28		        plp
.1b39	20 f5 19	        jsr putahex
.1b3c	08		        php
.1b3d	48		        pha
.1b3e	a9 20		        lda #$20
.1b40	20 7a f2	        jsr chrout
.1b43	68		        pla
.1b44	28		        plp
.1b45	08		        php
.1b46	48		        pha
.1b47	a9 9f		        lda #socean
.1b49	20 7a f2	        jsr chrout
.1b4c	68		        pla
.1b4d	28		        plp
.1b4e	aa		        tax
.1b4f	a9 00		        lda #$00
.1b51	20 cd dd	        jsr fiaxtf1
.1b54	20 77 17	        jsr popregs
.1b57	60		        rts
.1b58			rolword
.1b58	20 4a 17	        jsr pushregs
.1b5b	a8		        tay
.1b5c	18		again   clc
.1b5d	2e aa 27	        rol reponse
.1b60	2e ab 27	        rol reponse+1
.1b63	88		        dey
.1b64	d0 f6		        bne again
.1b66	20 77 17	        jsr popregs
.1b69	60		        rts

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/l-keyb.asm

.1b6a			clrkbbuf
.1b6a	08		            php
.1b6b	48		            pha
.1b6c	a9 00		            lda #0
.1b6e	85 c6		            sta 198
.1b70	68		            pla
.1b71	28		            plp
.1b72	60		            rts
.1b73			waitstop
.1b73	08		          php    ;\ sauve les flags
.1b74	48		          pha    ;/  et l'acc.
.1b75	20 6a 1b	          jsr clrkbbuf
.1b78	20 70 f7	wait      jsr stop ; Veri [run/stop]
.1b7b	d0 fb		          bne wait ;loop pas pesee.
.1b7d	68		          pla    ;\ recup. acc et
.1b7e	28		          plp    ;/  les flags.
.1b7f	60		          rts
.1b80			anykey
.1b80	08		        php
.1b81	48		        pha
.1b82	20 6a 1b	        jsr clrkbbuf
.1b85	a5 cb		wait    lda 203    ;lit la matrice de
.1b87	c9 40		        cmp #64    ; 64 = aucune clef
.1b89	f0 fa		        beq wait   ; on en attend une.
.1b8b	20 94 1b	        jsr kbfree ; Clavier relache.
.1b8e	20 6a 1b	        jsr clrkbbuf
.1b91	68		        pla
.1b92	28		        plp
.1b93	60		        rts
.1b94			kbfree
.1b94	08		        php
.1b95	48		        pha
.1b96	a5 cb		wait    lda 203    ; lit la matrice
.1b98	c9 40		        cmp #64    ; 64 = aucune clef
.1b9a	d0 fa		        bne wait   ; attend la relache
.1b9c	68		        pla
.1b9d	28		        plp
.1b9e	60		        rts
.1b9f			getkey
.1b9f	08		        php
.1ba0	20 f5 f1	try     jsr getin  ;tente de lire
.1ba3	c9 00		        cmp #0     ; 0 si aucune.
.1ba5	f0 f9		        beq try    ; on reessaye
.1ba7	28		        plp
.1ba8	60		        rts
.1ba9			waitkey
.1ba9	08		        php
.1baa	48		        pha
.1bab	8d 9e 27	        sta clef   ;Sauve clef voulue
.1bae	20 6a 1b	        jsr clrkbbuf
.1bb1	20 f5 f1	wait    jsr getin  ;Sonde le clavier
.1bb4	cd 9e 27	        cmp clef   ;Compare avec clef
.1bb7	d0 f8		        bne wait   ;Pas la bonne.
.1bb9	68		        pla
.1bba	28		        plp
.1bbb	60		        rts
.1bbc			waitspace
.1bbc	a9 20		            lda #$20
.1bbe	20 a9 1b	            jsr waitkey
.1bc1	20 6a 1b	            jsr clrkbbuf
.1bc4	60		            rts
.1bc5			showkey
.1bc5	20 4a 17	        jsr pushregs
.1bc8	38		        sec
.1bc9	20 0a e5	        jsr plot
.1bcc	8e a0 27	        stx curx
.1bcf	8c 9f 27	        sty cury
.1bd2	20 4a 17	        jsr pushregs
.1bd5	a0 1c		        ldy #39-11
.1bd7	a2 18		        ldx #24
.1bd9	18		        clc
.1bda	20 0a e5	        jsr plot
.1bdd	20 77 17	        jsr popregs
.1be0	20 7a f2	        jsr chrout
.1be3	08		        php
.1be4	48		        pha
.1be5	a9 20		        lda #32
.1be7	20 7a f2	        jsr chrout
.1bea	68		        pla
.1beb	28		        plp
.1bec	08		        php
.1bed	48		        pha
.1bee	a9 24		        lda #36
.1bf0	20 7a f2	        jsr chrout
.1bf3	68		        pla
.1bf4	28		        plp
.1bf5	20 2d 1b	        jsr putahexdec
.1bf8	18		        clc
.1bf9	ac 9f 27	        ldy cury
.1bfc	ae a0 27	        ldx curx
.1bff	20 0a e5	        jsr plot
.1c02	20 77 17	        jsr popregs
.1c05	60		        rts

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-vars.asm

=10259			libre    = *+3085
=10258			rp       = libre-$01;1 byte $cfff
=10257			ra       = rp-1     ;1 byte $cffe
=10256			rx       = ra-1     ;1 byte $cffd
=10255			ry       = rx-1     ;1 byte $cffc
=10254			rs       = ry-1     ;1 byte $cffb
=10252			pc       = rs-2     ;2 byte $cff9-$cffa
=10251			curcol   = pc-1     ;1 byte $cff6
=10250			memptr   = curcol-1;1 word $cff7-$cff8
=10248			src      = memptr-2
=10246			dst      = memptr-4
=10244			loopcount = memptr-6
=10244			hexv     = loopcount
.1c06			a2hexstr
=10239			hexstr   = hexv-$05 ;5 byte
=10238			a2hexpfx = hexv-$06 ;1 byte
=10237			a2hexpy  = hexv-$07 ;1 byte
=10236			a2hexpx  = hexv-$08 ;1 byte
=10236			a2hexpos = hexv-$08 ;0 byte
=10235			a2hexcol = hexv-$09 ;1 byte
=10235			binv     = a2hexcol
=10226			binstr   = binv-$09 ;9 byte
=10225			a2binpfx = binv-$0a ;1 byte
=10224			a2binpy  = binv-$0b ;1 byte
=10223			a2binpx  = binv-$0c ;1 byte
=10223			a2binpos = binv-$0c ;0 byte
=10222			a2bincol = binv-$0d ;1 byte
=10222			decv     = a2bincol
=10216			decstr   = decv-$06 ;6 byte
=10215			a2decpfx = decv-$07 ;1 byte
=10214			a2decpy  = decv-$08 ;1 byte
=10213			a2decpx  = decv-$09 ;1 byte
=10213			a2decpos = decv-$09 ;0 byte
=10212			a2deccol = decv-$0a ;1 byte
=10211			offset   = decv-$0b ;1 byte
=10211			fltv     = offset
=10205			fvar1    = fltv-6  ; 6 byte
=10199			fvar2    = fltv-12 ; 6 byte
=10179			float1   = fltv-32 ;20 byte
=10159			float2   = fltv-52 ;20 byte
=10158			tval1    = fltv-53 ; 1 byte
=10156			tval2    = fltv-55 ; 2 byte
=10154			reponse  = tval2-2 ; 2 byte
=10154			edbox    = reponse
=10153			cleft    = edbox-1 ;1 byte
=10152			cright   = edbox-2 ;1 byte
=10151			cmid     = edbox-3 ;1 byte
=10150			dbtop    = edbox-4 ;1 byte
=10149			dbleft   = edbox-5 ;1 byte
=10148			dbwdth   = edbox-6 ;1 byte
=10147			dbhght   = edbox-7 ;1 byte
=10146			dbcoul   = edbox-8 ;1 byte
=10145			dbclin   = edbox-9 ;1 byte
=10145			ekeyb    = dbclin
=10144			curx     = ekeyb-1 ;1 byte
=10143			cury     = ekeyb-2 ;1 byte
=10142			clef     = ekeyb-3 ;1 byte
=10141			len      = clef-1  ;1 byte
=10140			cx       = clef-2  ;1 byte
=10139			cy       = clef-3  ;1 byte
=10138			bcol     = clef-4  ;1 byte
=10138			escr     = bcol          ;   2051 bytes
=10137			loops    = escr-1       ; 1 byte
=10135			loop16   = loops-2      ; 2 byte
=9111			scrncar  = loop16-1024  ;1k byte
=8087			scrncol  = scrncar-1024 ;1k byte
=8087			diskvar = scrncol
=8085			ddatas  = diskvar-2 ;2 byte Data start
=8083			ddatae  = diskvar-4 ;2 byte Data end
=8082			ddev    = diskvar-5 ;1 byte Dev number
=8081			dlfsno  = diskvar-6 ;1 byte Lfs
=8079			dfnptr  = diskvar-8 ;2 byte Ptrnfichier
=8078			dfnlen  = diskvar-9 ;1 byte lenfilename
=8077			genbyte1 = dfnlen-1 ; 1 byte
=8075			genword1 = dfnlen-3 ; 2 byte
=8074			endofvars = genword1-1

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/m-v20-utils.asm


;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-float.asm

=$cfe6			ffpor   =   $cfe6   ; f1=f1 or f2.
=$cfe9			ffpand  =   $cfe9   ; f1=f1 and f2.
=$d1aa			ff1wrday=   $d1aa   ; f1=word->$aayy
=$d1bf			ff1swd64=   $d1bf   ; f1=sw(f1)->64
=$d1d2			ff1wrd64=   $d1d2   ; f1=uw(f1)->64
=$d391			fwrdayf1=   $d391   ; $aayy->f1
=$d3a2			fiyytf1 =   $d3a2   ; f1=float(y)
=$d79e			ff1evalx=   $d79e   ; eval. expr. f1 to x.
=$d7a1			ff1bytxx=   $d7a1   ; f1 to byte in x
=$d7f7			ff1to20 =   $d7f7   ; f1 -> int($14,$15)
=$d849			ff1p05  =   $d849   ; f1=f1+0,5.
=$d850			ffvsf1  =   $d850   ; f1=fv-f1 ($yyaa)
=$d853			ff2sf1  =   $d853   ; f1=f2-f1.
=$d867			ffvpf1  =   $d867   ; f1=fv+f1 ($yyaa)
=$d86a			ff2pf1  =   $d86a   ; f1=f2+f1
=$d8f7			fzerof1 =   $d8f7   ; f1=0.0
=$d947			ff1com2 =   $d947   ; f1=two's compl f1
=$da28			ff1xfv  =   $da28   ; f1=f1*fv ($yyaa)
=$da2b			ff1xf2  =   $da2b   ; f1=f1*f2
=$da59			ff1maa  =   $da59   ; f1=f1*.A
=$da8c			ffvtf2  =   $da8c   ; fv $(yyaa) -> f2
=$dae2			ff1x10  =   $dae2   ; f1=f1*10
=$dafe			ff1d10  =   $dafe   ; f1=f1/10
=$db0f			ffvdf1  =   $db0f   ; f1=fv/f1 ($yyaa)
=$db12			ff2df1  =   $db12   ; f1=f2/f1
=$dbc7			ff1t5c  =   $dbc7   ; Copie f1 vers $5c-$60.
=$dbca			ff1t57  =   $dbca   ; copie f1 vers $57-$5b.
=$dbd0			ff1t49  =   $dbd0   ; copie f1 vers $49-$4a.
=$dbd4			ff1tyx  =   $dbd4   ; Copie f1 mem $yyxx.
=$dbfc			ff2tf1  =   $dbfc   ; copie f2 to f1.
=$dc0c			ff1tf2r =   $dc0c   ; Copie f1 to f2 avec arrondissement.
=$dc0f			ff1tf2  =   $dc0f   ; Copie f1 to f2 sans arrondissement.
=$dc1b			ff1rnd  =   $dc1b   ; f1=round(f1).
=$dc2b			fsngf1  =   $dc2b   ; Tester le signe de FAC1.
=$dc39			ff1sign =   $dc39   ; f1=sgn(f1).
=$dc3c			fiaatf1 =   $dc3c   ; Conv. .A->F1.
=$dc44			fi62tf1 =   $dc44   ; Conv. mot 16 bits $62,$63 a f1.
=$dc58			ff1abs  =   $dc58   ; f1=abs(f1).
=$dc5b			ffvcmp  =   $dc5b   ; f1=f1 comp fv ($yyaa)
=$dc9b			ff1tudw =   $dc9b   ; f1-> 32 octets signé ($62-$65)
=$dccc			ff1int  =   $dccc   ; f1=int(f1).
=$dcf3			fasctf1 =   $dcf3   ; f1=float(ascii)
=$dd7e			ff1pac  =   $dd7e   ; f1=f1+ra val ra=0-9
=$ddcd			fiaxtf1 =   $ddcd   ; f1=float($aaxx)+print
=$dddd			ff1tasc =   $dddd   ; f1 to ascii ($yyaa)
=$df71			ff1sqr  =   $df71   ; f1=sqrt(f1).
=$df7b			ff1ef2  =   $df7b   ; f1=f1^f2
=$dfb4			ff1nf1  =   $dfb4   ; f1=-f1.
=$e261			ffac1cos=   $e261   ; f1=sin(f1+(pi/2)).. FAC1 copié en ram.
=$e264			ff1cos  =   $e264   ; f1=sin(f1+(pi/2)).
=$e26b			fFAC1sin=   $e26b   ; f1=sin(f1). FAC1 copié en ram.
=$e26b			ff1sin  =   $e26b   ; f1=sin(f1)
=$e2b1			fFAC1tan=   $e2b1   ; f1=sin(f1)/cos(f1). FAC1 copié en ram.
=$e2b4			ff1tan  =   $e2b4   ; f1=sin(f1)/cos(f1)
=$e30e			ffac1atn=   $e30e   ; ff1=atn(f1). FAC1 copié en ram.
=$e30e			ff1atn  =   $e30e   ; ff1=atn(f1).

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-basic-map.asm

=$c000			bcoldst =   $c000   ; Vecteur vers la routine de démarrage à froid BASIC $e378.
=$c002			bwarmst =   $c002   ; Vecteur vers la routine de démarrage à chaud BASIC $e467.
=$c004			cbmBASIC=   $c004   ; Les caractères "CBMBASIC".
=$c00c			bstmdsp =   $c00c   ; Tableau vectoriel de répartition des mots clés, dans
=$c052			bfundsp =   $c052   ; Tableau des vecteurs de répartition des fonctions dans
=$c080			boptab  =   $c080   ; Tableau vectoriel de répartition des opérations
=$c09e			breslst =   $c09e   ; Tableau des mots-clés BASIC dans l'ordre des jetons.
=$c19e			berrtab =   $c19e   ; Tableau des messages d'erreur BASIC.
=$c328			bbmsgs  =   $c328   ; Tableau de Vecteurs de messages d'erreur BASIC.
=$c364			bmiscmsg=   $c364   ; Messages divers.
=$c38a			bscntk  =   $c38a   ; Trouvez les entrées FOR et GOSUB sur la pile.
=$c3b8			bmakspc =   $c3b8   ; Libérer de l'espace en mémoire pour une nouvelle ligne
=$c3bf			bmovebl =   $c3bf   ; Déplacer un bloc de mémoire.
=$c3fb			bstkspc =   $c3fb   ; Vérifiez si l'espace demandée est disponible sur la pile.
=$c408			bramspc =   $c408   ; Vérifiez que l'espace demandé dans la zone dynamique est
=$c435			bmemerr =   $c435   ; Définir le code du message d'erreur OUT OF MEMORY.
=$c437			berror  =   $c437   ; Routine de message d'erreur BASIC.
=$c469			bprdy   =   $c469   ; Afficher ERREUR, ou un autre message indiqué.
=$c474			bready  =   $c474   ; Afficher le message READY.
=$c480			bmain   =   $c480   ; Boucle principale BASIC, recevoir et exécuter ou stocker
=$c49c			bnewlin =   $c49c   ; Stocker/remplacer une ligne de programme BASIC.
=$c533			blnkprg =   $c533   ; Rechaîner les lignes du programme BASIC.
=$c560			bgetlin =   $c560   ; Recevoir les données du périphérique et remplir la
=$c579			bcrnch  =   $c579   ; Tokenisez la ligne BASIC dans le tampon de texte BASIC.
=$c613			bfinlin =   $c613   ; Trouvez la ligne BASIC à partir de son numéro de ligne.
=$c69c			bstxtpt =   $c69c   ; Ramener TXTPTR au début du programme.
=$c71a			bqplop  =   $c71a   ; Liste des mots-clés BASIC détokenisés.
=$c7ae			bnewstt =   $c7ae   ; Recherche (pour exécution) l'instruction BASIC suivante.
=$c7e4			bgone   =   $c7e4   ; Exécutez l'instruction BASIC actuelle.
=$c82c			btststop=   $c82c   ; Testez la touche STOP.
=$c8fb			bbumptp =   $c8fb   ; Incrémenter TXTPTR du montant en .Y.
=$c906			bfind2  =   $c906   ; Scannez le tampon de texte BASIC à 512 ($200) pour les
=$c96b			bdecbin =   $c96b   ; Convertir un numéro de ligne décimal au format LSB/MSB.
=$c9c2			blet2   =   $c9c2   ; LET : Affecter une variable entière.
=$c9da			blet5   =   $c9da   ; LET : Affecter TI$.
=$ca2c			blet8   =   $ca2c   ; LET : Affecter une variable de type chaîne de caractères.
=$ca9a			bprti   =   $ca9a   ; Partie de la routine PRINT.
=$cae8			bprt6   =   $cae8   ; Partie de la routine PRINT.
=$cb1e			bprtstr =   $cb1e   ; Imprimez $YYAA jusqu'à $0d ou jusqu'à ce que le nombre
=$cb3b			bprtos  =   $cb3b   ; Format d'impression des caractères d'espace, de curseur
=$cb4d			bigrerr =   $cb4d   ; Routine de formatage des messages d'erreur pour GET,
=$ccfc			bextra  =   $ccfc   ; Messages d'erreur de INPUT.
=$cd8a			btypchk =   $cd8a   ; Vérification du type de variable.
=$cd9e			bfrmevl =   $cd9e   ; Évaluation de formules/expressions.
=$ce83			beval   =   $ce83   ; Évaluer un seul terme d'une expression.
=$ce8a			bpival  =   $ce8a   ; Le NVF. PI = $82 $49 $0f $da $a1.
=$cef1			bparexp =   $cef1   ; L'évaluation entre parenthèses est effectuée.
=$cef7			brpachk =   $cef7   ; Vérification syntaxique pour ")".
=$cefa			blpachk =   $cefa   ; Vérification syntaxique pour "(".
=$cefd			bcomchk =   $cefd   ; Vérification syntaxique pour ",".
=$ceff			bsynchr =   $ceff   ; Vérification syntaxique d'un caractère spécifique dans
=$cf08			bsynerr =   $cf08   ; Provoquez un message d'ERREUR DE SYNTAXE via un saut
=$cf0d			bfactio =   $cf0d   ; Configurer l'index pour "-" (moins monadique).
=$cf14			bvarrange=  $cf14   ; Vérifier la plage de la variable ?
=$cf28			bfacti2 =   $cf28   ; Obtenir le nom et le type de la variable à partir de
=$cfa7			bfacti7 =   $cfa7   ; Appel une fonction.
=$d016			bcompar =   $d016   ; Comparer des nombres ou des chaînes de caractères.
=$d02e			bcmpst  =   $d02e   ; Comparez les chaînes de caractères.
=$d08b			bevlvar =   $d08b   ; Localiser ou créer une variable.
=$d0e7			bfndvar =   $d0e7   ; Localiser la variable.
=$d113			bchrtst =   $d113   ; Vérifie si le caractère ASCII est alphabétique.
=$d11d			bmakvar =   $d11d   ; Créez une nouvelle variable.
=$d185			bretvp  =   $d185   ; Renvoie l'adresse de la variable trouvée ou créée.
=$d194			baryhed =   $d194   ; Calculer la longueur d'un descripteur de tableau.
=$d1a5			bmaxint =   $d1a5   ; Valeur entière maximale de 32768 en Fonction NVF.:
=$d1aa			bintidx =   $d1aa   ; Convertir les nombres à virgule flottante en nombres à
=$d1b2			bgetsub =   $d1b2   ; Convertir une expression en nombre entier.
=$d1bf			bmakint =   $d1bf   ; Convertir un NVF. en entier signé.
=$d1d1			bary    =   $d1d1   ; Trouver un élément d'un tableau ou créer un tableau.
=$d245			bbadsub =   $d245   ; Affiche le message "BAD SUBSCRIPT".
=$d248			bilquan =   $d248   ; Afficher le message "ILLEGAL QUANTITY".
=$d24d			bary2   =   $d24d   ; Tableau trouvé, vérifiez la plage d'indices.
=$d261			bary6   =   $d261   ; Créer un tableau.
=$d2ea			bary14  =   $d2ea   ; Localiser un élément particulier du tableau.
=$d34c			bmi6    =   $d34c   ; Calculer la taille du tableau multidimensionnel.
=$d391			bmkfp   =   $d391   ; Convertir l'entier .AAYY .Y (LSB) et .A (MSB) en virgule
=$d3a6			bnidirm =   $d3a6   ; Vérifiez si l'instruction est saisie en mode direct.
=$d3ae			bundef  =   $d3ae   ; Émet un message « UNDEF'D FUNCTION » pour EVALFN ($d3f4).
=$d3e1			bfn     =   $d3e1   ; Vérifie la syntaxe de DEF FN et FN.
=$d44f			bevfn3  =   $d44f   ; Stocker les valeurs DEF FN dans le descripteur de
=$d475			balci   =   $d475   ; Calcul le vecteur et la longueur de la nouvelle chaine.
=$d487			bmakstr =   $d487   ; Analyse et configure la chaîne.
=$d4f4			balcspc =   $d4f4   ; Alloue de l'espace mémoire pour une chaîne de caractères.
=$d526			bgrbcol =   $d526   ; Collecteur de dechets.
=$d5b5			bgcoli3 =   $d5b5   ; Vérifiez si la chaîne la plus éligible est à collecter.
=$d606			bcolect =   $d606   ; Collecte en déchets une chaine.
=$d67a			bxferstr=   $d67a   ; Déplacer la chaîne de caractères en mémoire.
=$d6a3			bdelst  =   $d6a3   ; Supprimez une chaîne temporaire.
=$d6db			bdeltsd =   $d6db   ; Nettoyez la pile de descripteurs de chaînes temporaires.
=$d761			bfinlmr =   $d761   ; Obtenir les paramètres de chaîne pour LEFT$, MID$ et
=$d782			bgsinfo =   $d782   ; Obtenez des informations sur la chaîne.
=$d79b			bgetbyt =   $d79b   ; Obtenir un nombre compris entre 0 et 255.
=$d7eb			bgetad  =   $d7eb   ; Récupération de deux paramètres pour POKE et WAIT.
=$d7f7			bmakadr =   $d7f7   ; Convertir le NVF. FAC en un entier
=$d849			badd05  =   $d849   ; Additionner 0,5 à f1.
=$d850			blamin  =   $d850   ; Soustraction du contenu de la mémoire de f1.
=$d862			bplus1  =   $d862   ; Effectuer un prédécalage d'exposant (?) et continue
=$d867			blaplus =   $d867   ; Ajoute FV à f1.
=$d8a7			bplus6  =   $d8a7   ; Rendre le résultat négatif si un emprunt a été effectué.
=$d8f7			bzerfac =   $d8f7   ; Met f1 à zéro et rend le signe positif puisque le
=$d8fe			bnormlz =   $d8fe   ; Renormaliser le résultat f1.
=$d947			bcomfac =   $d947   ; Complément à 2 de f1 entièrement.
=$d97e			boverfl =   $d97e   ; Affiche le message OVERFLOW et quitte.
=$d983			basrres =   $d983   ; Effectuer un prédécalage d'exposant (?) et continue
=$d9bc			bfpci   =   $d9bc   ; Constante de un pour un accumulateur à Fonction NVF.:
=$d9c1			bloggon =   $d9c1   ; Constantes de la fonction LOG.
=$da59			btimes3 =   $da59   ; Sous-programme de multiplication de .A.
=$da8c			blodarg =   $da8c   ; Déplacer la mémoire à virgule flottante vers FAC2.
=$dab7			bmuldiv =   $dab7   ; Additionne les exposants de f1 et f2
=$dae2			bmulten =   $dae2   ; Multiplie f1 par 10.
=$daf9			bfpcten =   $daf9   ; +10 constante à virgule flottante : $84,$20,$00,$00,$00.
=$dafe			bdivten =   $dafe   ; Divise F1 par 10.
=$db0f			bladiv  =   $db0f   ; Déplace le NVF. en mémoire vers f2.
=$dba2			blodfac =   $dba2   ; Déplace le NVF. en mémoire dans f1.
=$dba2			ffvtf1  =   $dba2   ; copie fv $(yyaa) to f1
=$dbc7			bfactf2 =   $dbc7   ; Déplace f1 en mémoire.
=$dbca			bfactf1 =   $dbca   ; Déplace f1 en mémoire.
=$dbd0			bfactfp =   $dbd0   ; Déplace f1 en mémoire.
=$dbd4			bstorfac=   $dbd4   ; Déplace FAC1 en mémoire.
=$dbfc			batof   =   $dbfc   ; Transférer FAC2 vers FAC1.
=$dc0c			brftoa  =   $dc0c   ; Déplace FAC1 vers FAC2, avec arrondissement.
=$dc0f			bftoa   =   $dc0f   ; Déplace FAC1 vers FAC2, sans arrondissement.
=$dc1b			bround  =   $dc1b   ; Arrondir FAC1 en ajustant l'octet d'arrondi.
=$dc2b			bshgfac =   $dc2b   ; Tester le signe de FAC1.
=$dc3c			bintfp  =   $dc3c   ; Convertie .A en NVF. dans FAC1.
=$dc44			bintfp1 =   $dc44   ; Convertir un entier 16 bits ($62,$63) en NVF. dans FAC1.
=$dc5b			bcmpfac =   $dc5b   ; Comparez FAC1 à la mémoire ($YYAA).
=$dc9b			bfpint  =   $dc9b   ; Convertir FAC1 en entier signé. dans $62-$65 Double-mot
=$dce9			bfilfac =   $dce9   ; Stockez le contenu de .A dans les emplacements ($62-$65).
=$dcf3			bascflt =   $dcf3   ; Convertir une chaîne ASCII en un NVF. dans FAC1.
=$dd7e			basc18  =   $dd7e   ; Aditionne .A à FAC1.
=$ddb3			bfpc12  =   $ddb3   ; Constante de conversion de chaîne de caractères en NVF.
=$ddc2			bprtin  =   $ddc2   ; Émet le message IN.
=$ddcd			bprtfix =   $ddcd   ; Routine d'affichage des nombres décimaux.
=$dddd			bfltasc =   $dddd   ; Convertir FAC en TI$ ou en chaîne ASCII.
=$df11			bflp05  =   $df11   ; 0,5 constante pour l'arrondi et SQR.
=$df16			bfltcon =   $df16   ; Table des puissances de 10, au format entier fixe de
=$df3a			bhmscon =   $df3a   ; Constantes pour la conversion de division TI$, au format
=$dfbf			bexpcon =   $dfbf   ; Tableau pour EXP, au format à virgule flottante.
=$e040			bserevl =   $e040   ; Routine d’évaluation des séries.
=$e056			bser2   =   $e056   ; Routine d'évaluation des séries mathématiques.
=$e08a			brndc1  =   $e08a   ; Tableau des constantes pour RND.
=$e0f6			bpatchbas=  $e0f6   ; Routines de patch BASIC.
=$e1d1			bparsl  =   $e1d1   ; Définie les paramètres LOAD, VERIFY et SAVE.
=$e203			bifchrg =   $e203   ; Vérifiez si la commande actuelle contient d'autres
=$e20b			bskpcom =   $e20b   ; Ignorer toute virgule dans les paramètres analysés.
=$e20e			bchrerr =   $e20e   ; S'assurez qu'un paramètre soit présent après une virgule.
=$e216			bparoc  =   $e216   ; Gérer les paramètres de OPEN et CLOSE.
=$e2dd			bfpc20  =   $e2dd   ; Valeurs des constantes d'évaluation trigonométriques
=$e33b			batncon =   $e33b   ; Tableau des valeurs constantes pour l'évaluation ATN.
=$e378			bcoldba =   $e378   ; Effectue un démarrage à froid de BASIC.
=$e387			bcgimag =   $e387   ; La routine CHRGET et la graine RND doivent être copiées
=$e3a4			binitba =   $e3a4   ; Initialisation de BASIC : Restauration de CHRGET et des
=$e404			bfremsg =   $e404   ; Afficher le message de démarrage à froid de BASIC.
=$e429			bcbmmsg =   $e429   ; Message de démarrage à froid de BASIC.
=$e44f			bbasvctrs=  $e44f   ; Six vecteurs BASIC à copier à l'emplacement 768 ($300).
=$e45b			binitvctrs= $e45b   ; Copie des vecteurs BASIC de la ROM vers la RAM.
=$e467			bwarmbas=   $e467   ; Effectue un démarrage à chaud de BASIC.
=$e476			bpatcher=   $e476   ; Zone de "patch" programme.

;******  Return to file: template.asm


;******  Processing file: /Users/Locals/C64/00-usbkey32go/d-00-64tass-src/V20/lib/e-v20-kernal-map.asm

=$00			eot       = $00
=$01			memmapreg = $01
=$73			chrget    = $73     ;Recup Basic car texte
=$79			chrgot    = $79     ;...une seconde fois.
=$7c			chrtst    = $7c
=$90			kiostatus = $90     ; Kernal I/O status word (st) (byte)
=$b7			curfnlen  = $b7     ; Current filename length (byte)
=$b9			cursecadd = $b9     ; Current secondary address (byte)
=$ba			curdevno  = $ba     ; Current device number (byte)
=$bb			curfptr   = $bb     ; Current file pointer (word)
=$c1			stal      = $c1     ;word
=$d1			scrnlin   = $d1     ;pnt cur-scrn-line
=$fb			zp1       = $fb     ;1er Zpage prog. usager address (word)
=$fb			zpage1    = $fb     ; zero page 1
=$fd			zp2       = $fd     ;2em Zpage prog. usager address (word)
=$fd			zpage2    = $fd     ; zero page 2 address (word)
=$0100			fascii    = $0100;region conv FP a ascii
=$0286			kcol      = $0286;Couleur car affiche.
=$1001			basstart  = $1001     ;basic start address std
=$1201			basstartx = $1201     ;basic start address exram
=$a000			basicrom  = $a000
=$d000			chargen   = $d000
=$d000			vicii     = $d000
=$d400			sid       = $d400     ;sid base address
=$9110			via1      = $9110     ;cia1  base address
=$dd00			via2      = $dd00     ;cia2 base address
=$e000			kernalrom = $e000
=8			discase   =    8
=9			enacase   =    9
=14			locase    =    14
=17			crsdown   =    17
=18			revson    =    18
=19			gohome    =    19
=20			delete    =    20
=29			crsright  =    29
=142			upcase    =    142
=145			crsup     =    145
=157			crsleft   =    157
=146			revsoff   =    146
=147			clrhome   =    147
=$03			bstop     =   $03      ;stop
=$05			bwhite    =   $05      ;set colour white
=$08			block     =   $08      ;lock the charset
=$09			bunlock   =   $09      ;unlock the charset
=$0d			bcarret   =   $0d
=$0e			btext     =   $0e
=$11			bcrsdn    =   $11      ;cursor down 1 line
=$12			brevcol   =   $12
=$13			bhome     =   $13
=$14			bdelete   =   $14
=$1c			bred      =   $1c
=$1d			bcuright  =   $1d
=$1e			bgreen    =   $1e
=$1f			bblue     =   $1f
=$81			borange   =   $81
=$83			blrun     =   $83
=$85			bfkey1    =   $85
=$86			bfkey2    =   $86
=$87			bfkey3    =   $87
=$88			bfkey4    =   $88
=$89			bfkey5    =   $89
=$8a			bfkey6    =   $8a
=$8b			bfkey7    =   $8b
=$8c			bfkey8    =   $8c
=$8d			bcarret1  =   $8d
=$8e			bgraph    =   $8e
=$90			bblack    =   $90
=$91			bcuup     =   $91
=$92			brevoff   =   $92
=$93			bclear    =   $93
=$94			binsert   =   $94
=$95			bbrown    =   $95
=$96			bltred    =   $96
=$97			bdkgrey   =   $97
=$98			bmdgrey   =   $98
=$99			bltgreen  =   $99
=$9a			bltblue   =   $9a
=$9b			bltgrey   =   $9b
=$9c			bmagenta  =   $9c
=$9d			bculeft   =   $9d
=$9e			byellow   =   $9e
=$9f			bcyan     =   $9f
=$0286			carcol  = $0286
=$030a			ieval   = $030a
=$0			enoir       = $0
=$1			eblanc      = $1
=$2			erouge      = $2
=$3			eocean      = $3
=$4			emauve      = $4
=$5			evert       = $5
=$6			ebleu       = $6
=$7			ejaune      = $7
=$8			eorange     = $8
=$9			ebrun       = $9
=$a			erose       = $a
=$b			egrisfonce  = $b
=$c			egrismoyen  = $c
=$d			evertpale   = $d
=$e			ebleupale   = $e
=$f			egrispale   = $f
=144			snoir       = 144
=5			sblanc      = 5
=28			srouge      = 28
=159			socean      = 159
=156			smauve      = 156
=30			svert       = 30
=31			sbleu       = 31
=158			sjaune      = 158
=$9000			vic       = $9000;debut du vic
=$9000			vic0      = $9000;ABBBBBBB
=$9001			vic1      = $9001;CCCCCCCC
=$9002			vic2      = $9002;HDDDDDDD
=$9003			vic3      = $9003;GEEEEEEF
=$9004			vic4      = $9004;GGGGGGGG
=$9005			vic5      = $9005;HHHHIIII
=$9006			vic6      = $9006;JJJJJJJJ
=$9007			vic7      = $9007;KKKKKKKK
=$9008			vic8      = $9008;LLLLLLLL
=$9009			vic9      = $9009;MMMMMMMM
=$900a			vic10     = $900a;NRRRRRRR
=$900b			vic11     = $900b;OSSSSSSS
=$900c			vic12     = $900c;PTTTTTTT
=$900d			vic13     = $900d;QUUUUUUU
=$900e			vic14     = $900e;WWWWVVVV
=$900f			vic15     = $900f;XXXXYZZZ
=$00			vnoir   =   %00000000
=$01			vblanc  =   %00000001
=$02			vrouge  =   %00000010
=$03			vocean  =   %00000011
=$04			vmauve  =   %00000100
=$05			vvert   =   %00000101
=$06			vbleu   =   %00000110
=$07			vjaune  =   %00000111
=$08			vorange =   %00001000
=$09			vbrun   =   %00001001
=$0a			vrose   =   %00001010
=$0b			vgris   =   %00001011
=$0c			vgris1  =   %00001100
=$0d			vvert1  =   %00001101
=$0e			vbleu1  =   %00001110
=$0f			vgris2  =   %00001111
=$00			bknoir  =   %00000000
=$10			bkblanc =   %00010000
=$20			bkrouge =   %00100000
=$30			bkocean =   %00110000
=$40			bkmauve =   %01000000
=$50			bkvert  =   %01010000
=$60			bkbleu  =   %01100000
=$70			bkjaune =   %01110000
=$80			bkorange=   %10000000
=$90			bkrose  =   %10010000
=$a0			bkgris  =   %10100000
=$b0			bkgris1 =   %10110000
=$c0			bkgris2 =   %11000000
=$d0			bkvert1 =   %11010000
=$e0			bkbleu1 =   %11100000
=$f0			bkjaune2=   %11110000
=$e4a0			serout1 = $e4a0 ; Serial: Output a 1 on the serial data line.
=$e4a9			serout0 = $e4a9 ; Serial: Output a 0 on the serial data line.
=$e4b2			serget  = $e4b2 ; Serial: Get an input bit from VIA1 and stabilize.
=$e4bc			patches = $e4bc ; Program patch area.
=$e500			iobase  = $e500 ; ($e500) Define i/o memory page
=$e505			screen  = $e505 ; Return screen format
=$e50a			plot    = $e50a ; Set or retrieve cursor location x=column, y=line
=$e518			initsk  = $e518 ; Initialize 6550 Vic Chip, screen and related pointers.
=$e55f			clsr    = $e55f ; Clear the screen.
=$e55f			home    = $e55f ; Move the cursor to the screen home position.
=$e587			setslink= $e587 ; Reset the screen line link table pointers.
=$e5b5			unusdnmi= $e5b5 ; NMI entry for restore key (No entry for this routine found.)
=$e5bb			setiodef= $e5bb ; Reset the default device number.
=$e5c3			initvic = $e5c3 ; Reset the vic chip registers.
=$e5cf			lp2     = $e5cf ; Get a character from the keyboard queue and shift it down.
=$e5e5			getque  = $e5e5 ; Wait for character to appear in the keyboard buffer.
=$e619			get2rtn = $e619 ; Empty the keyboard buffer up to a carriage return.
=$e64f			getscrn = $e64f ; Optain input from screen.
=$e6b8			quoteck = $e6b8 ; Test for quote and set flag.
=$e6c5			setchar = $e6c5 ; Set up diaplay of a character on the screen.
=$e6ea			scroll  = $e6ea ; advance the cursor on the screen, adds lines, and scroll.
=$e72d			retreat = $e72d ; Backup the cursor into the previous ligical screen line from
=$e742			scrnout = $e742 ; Handle characters going to the screen.
=$e8c3			nxtline = $e8c3 ; Advance cursor to the next logical line.
=$e8d8			rtrn    = $e8d8 ; Handle the carriage return key.
=$e8e8			backup  = $e8e8 ; Move the corsor to the end of the previoud physical screen
=$e8fa			forward = $e8fa ; Move the cursor to the start of the next screen line if the
=$e912			colourset=$e912 ; Set the current foreground colour code.
=$e921			colourtbl=$e921 ; Colour code key table.
=$e929			cnvrtcd = $e929 ; Code conversion table.
=$e975			scrl    = $e975 ; Scroll the screen.
=$e9ee			openlin = $e9ee ; Open up a blank physical line on the screen for inserts.
=$ea56			movline = $ea56 ; Move screen line.
=$ea6e			setaddr = $ea6e ; The address of the screen line + color line is set in memory.
=$ea7e			linptr  = $ea7e ; Set a pointer to the address of the start of the screen line.
=$ea8d			clraline= $ea8d ; Blank out a physical screen line.
=$eaa1			synptr  = $eaa1 ; Synchronize color to byte and store character on screen.
=$eaaa			putscrn = $eaaa ; store a character on the screen.
=$eab2			colorsyn= $eab2 ; The address of the color map byte for screen map byte is
=$eabf			irq     = $eabf ; IRQ interupt handler.
=$eb1e			scnkey  = $eb1e ; Scan the keyboard
=$ebdc			setkeys = $ebdc ; Set keyboard decode table address in 245-246 ($f6-$f6).
=$ec46			keyvctrs= $ec46 ; Keyboard decode table addresses.
=$ec5e			normkeys= $ec5e ; Table used for decoding unshifted keys into ascii.
=$ec9f			shftkeys= $ec9f ; Table used for decoding SHIFTed keys into ascii.
=$ece0			logokeys= $ece0 ; Table used for decoding Commodore SHIFTed keys into ascii.
=$ed21			charset = $ed21 ; Used to set uppercase/graphics character set.
=$ed30			graphmode=$ed30 ; Set the environment specified by graphics control characters.
=$ed5b			wrapline= $ed5b ;
=$ed69			whatkeys= $ed69 ; Apparently unused keyboard decoding table.
=$eda3			ctrlkeys= $eda3 ; Table used for decoding CTRL SHIFT keys into ascii.
=$ede4			vicinit = $ede4 ; Initial values for VIC chip registers.
=$edf4			runtb   = $edf4 ; LOAD and RUN words for the SHIFT and RUN keys.
=$edfd			ldtb2   = $edfd ; Screen line link table LSB of line in screen map.
=$ee14			talk    = $ee14 ; Send Talk command to serial bus.
=$ee17			listen  = $ee17 ; Command a device on the serial bus to listen.
=$ee1c			listi   = $ee1c ; Serial: Prepare to send serial command with attention.
=$ee49			srsend  = $ee49 ; Serial: Send command or data to serial device.
=$eeb4			srbad   = $eeb4 ; Serial: Set ST for timeout or DEVICE NOT PRESENT.
=$eec0			second  = $eec0 ; Send secondary address after listen
=$eec5			scatn   = $eec5 ; Serial: Clear attention.
=$eece			tksa    = $eece ; Send a secondary address to a device commanded to talk
=$eee4			ciout   = $eee4 ; Transmit a byte over the serial bus
=$eef6			untlk   = $eef6 ; Send an untalk command
=$ef04			unlsn   = $ef04 ; Send an unlisten command
=$ef19			acptr   = $ef19 ; Recoit un caractere provenant du port serie
=$ef84			srclkhi = $ef84 ; Serial: Set clock line high.
=$ef8d			srclklo = $ef8d ; Serial: Set clock line low.
=$ef96			waitabit= $ef96 ; Serial: Delay one millisecond.
=$efa3			rsnxtbit= $efa3 ; RS-232: Send the next bin (NMI continuation routine).
=$efbf			rsprty  = $efbf ; RS-232: Calculate barity and stop bits value.
=$efe8			rsstops = $efe8 ; RS-232: Transmit stop bits.
=$efee			rsnxtbyt= $efee ; RS-232: Prepare the next byte to be send from send buffer.
=$f016			rsmissing=$f016 ; RS-232: Set Clear To Send or Data Set Ready Missing status.
=$f027			rscptbit= $f027 ; RS-232: Compute desire word lenght bit count.
=$f036			rsinbit = $f036 ; RS-232: Recieve an input bit (NMI driven).
=$f04b			rsstpbit= $f04b ; RS-232: Determine if all the stop bits have been recieved yet.
=$f05b			rsprepin= $f05b ; RS-232: Prepare to recieve the next input byte.
=$f068			rsstrbit= $f068 ; RS-232: Check for start bit in recieve mode.
=$f06f			rsinbyte= $f06f ; RS-232: Put constructed byte into reciebe buffer.
=$f08b			rsinprty= $f08b ; RS-232: Parity checking of the input byte.
=$f09d			rsprtyer= $f09d ; RS-232: Parity error on input byte.
=$f0a2			rsoverun= $f0a2 ; RS-232: Buffer overrun on input byte.
=$f0a5			rsbreak = $f0a5 ; RS-232: Break detected on input.
=$f0a8			rsframer= $f0a8 ; RS-232: Framing error on input.
=$f0aa			rsinerr = $f0aa ; RS-232: Set input error status and continue.
=$f0b9			rsdvcerr= $f0b9 ; RS-232: ILLEGAL DEVICE message for LOAD or SAVE.
=$f0bc			rsopnout= $f0bc ; RS-232: Open an RS-232 channel for output.
=$f0ed			rsoutsav= $f0ed ; RS-232: Store a character in the transmit buffer.
=$f102			rsprepot= $f102 ; RS-232: Set up NMI for transmission.
=$f116			rsopnin = $f116 ; RS-232: Open an RS-232 channel for input.
=$f14f			rsnxtin = $f14f ; RS-232: Retrieve the next character from the recieve buffer.
=$f160			rspause = $f160 ; RS-232: Check if serial and tape are idle, protect from RS232.
=$f174			kmsgtbl = $f174 ; Table of KERNAL messages.
=$f1e2			spmsg   = $F1e2 ; Display LOADING or VERIFYING if control messages wanted.
=$f1e6			kmsgshow= $f1e6 ; Print KERNAL control messages.
=$f1f5			getin   = $f1f5 ; Get a character.
=$f20e			ibasin  = $f20e ; Get a character from the input channel
=$f20e			chrin   = $f20e ; Description:
=$f230			chrintp = $f230 ; Obtain a byte from the tape buffer.
=$f250			chrintp2= $f250 ; Load .A with next tape character, getting block when needed.
=$f264			chrinsr = $f264 ; Obtain a byte from the serial line.
=$f26f			chrinrs = $f26f ; RS-232: Obtain a byte from the rs-232 device.
=$f27a			chrout  = $f27a ; Output character to current output device.
=$f290			chrouttp= $f290 ; Output a character to tape.
=$f2c7			chkin   = $f2c7 ; Define an input channel.
=$f309			chkout  = $f309 ; Define an output channel.
=$f34a			close   = $f34a ; (Close a logical file
=$f3cf			fndflno = $f3cf ; Find file number (.x) in file table at 601 ($0259).
=$f3df			setflch = $f3df ; Set file characteristics of file (.x) into 184-186 ($b8-$ba).
=$f3ef			clall   = $f3ef ; Close all open files
=$f3f3			clrchn  = $f3f3 ; Clear all i/o channels.
=$f40a			open    = $f40a ; Open a logical file
=$f495			sername = $f495 ; Send secondary address and filename to serial device.
=$f4c7			openrs  = $f4c7 ; RS-232: open RS-232 device.
=$f542			load    = $f542 ; Load device to RAM.
=$f55c			loadser = $f55c ; Load or Verify from serial device.
=$f5d1			loadtp  = $f5d1 ; Load or Verify from tape.
=$f647			srching = $f647 ; Display SEARCHING message for tape device.
=$f659			filename= $f659 ; Display the filename.
=$f66a			ldvrmsg = $f66a ; Display LOADING or VERIFYING message.
=$f675			save    = $f675 ; Save memory to a device.
=$f692			saveser = $f692 ; Save RAM to serial device (except: RS-232,screen or keyboard).
=$f6f1			savetp  = $f6f1 ; Save RAM to tape.
=$f728			saving  = $f728 ; Display SAVING message.
=$f734			udtim   = $f734 ; Update the system clock
=$f760			rdtim   = $f760 ; Read system clock
=$f767			settim  = $f767 ; Set the system clock.
=$f770			stop    = $f770 ; Check if stop key is pressed.
=$f77e			filemsg = $f77e ; I/O error file error message handler.
=$f7af			fah     = $f7af ; Tape: find next tape header, .X back contains header ID#.
=$f7e7			tapeh   = $f7e7 ; Tape: Build an output tape header in the tape buffer area.
=$f84d			tpbufa  = $f84d ; Tape: Load tape buffer address from 178-179($b2-$b3) in .X .Y.
=$f854			ldad1   = $f854 ; Tape: Set Load/Save starting and ending pointers to the tape.
=$f867			fndhrd  = $f867 ; Tape: Find the tape header for a specified filename (or next).
=$f88a			jtp20   = $f88a ; Tape: Increment the tape buffer character counter.
=$f894			cstel   = $f894 ; Tape: Display PRESS PLAY ON TAPE message.
=$f8ab			csio    = $f8ab ; Tape: Check Tape's play/rewind/forward button status.
=$f8b7			cste2   = $f8b7 ; Tape: Display PRESS RECORD & PLAY ON TAPE message.
=$f8c0			rdtpblks= $f8c0 ; Tape: Initiate tape header read.
=$f8c9			rblk    = $f8c9 ; Tape: Read blocks from tape.
=$f8e3			wblk    = $f8e3 ; Tape: Write blocks to tape.
=$f8f4			tape    = $f8f4 ; Tape: Common tape read/write, start tape operations,
=$f94b			tstop   = $f94b ; Tape: Check for the STOP key.
=$f95d			stti    = $f95d ; Tape: Set time limit for tape dispole.
=$f98e			readt   = $f98e ; Tape: Read tape data bits into location 191 ($bf) (IRQ driven)
=$faad			tpstore = $faad ; Tape: Determin if to store the input character from tape.
=$fbd2			rd300   = $fbd2 ; Tape: Called to reset the tape read pointer.
=$fbdb			newch   = $fbdb ; Tape: New tape character setup.
=$fbea			tptogle = $fbea ; Tape: Toggle the tape write line to invert the output signal.
=$fc06			blkend  = $fc06 ; Tape: End of block write processing.
=$fc0b			write   = $fc0b ; Tape: Data write (IRQ driven).
=$fc95			wrtni   = $fc95 ; Tape: Block leader write (IRQ driven).
=$fca8			wrtz    = $fca8 ; Tape: Leader write (IRQ driven).
=$fccf			tnif    = $fccf ; Tape: Restore IRQ vector.
=$fcf6			bsiv    = $fcf6 ; Tape: Reset the current IRQ vector.
=$fd08			tnoff   = $fd08 ; Tape: Kill motor.
=$fd11			vrpty   = $fd11 ; Comnpare current to end of load/save pointers (tape & serial).
=$fd1b			wrt62   = $fd1b ; Increment current load/save pointer (tape & serial).
=$fd22			start   = $fd22 ; Power-on/reset routine (check for autostart cartridge).
=$fd3f			chkauto = $fd3f ; Check for an autostarting program at $a000. if equ a0cbm
=$fd4d			a0cbm   = $fd4d ; A0CBM characters with the high order bit on in the last 3
=$fd52			restor  = $fd52 ; Restore default I/O vectors.
=$fd57			vector  = $fd57 ; ($fd1a) Read/set I/O vectors.
=$fd6d			vectors = $fd6d ; Default system vector address storage table.
=$fd8d			initmem = $fd8d ; Initialize system memory.
=$fdf1			irqvctrs= $fdf1 ; IRQ vectors table.
=$fdf9			initvis = $fdf9 ; Initialize the 6522 VIA registers.
=$fe49			setnam  = $fe49 ; Set up file name
=$fe50			setlfs  = $fe50 ; Set up a logical file
=$fe57			readst  = $fe57 ; Read i/o status word
=$fe66			setmsg  = $fe66 ; Set kernal message output flag
=$fe68			readiost= $fe68 ; Load .A with the non-RE-232 I/O status ST.
=$fe6f			settmo  = $fe6f ; Set ieee bus card timeout flag
=$fe73			memtop  = $fe73 ; Get/Set top of ram
=$fe82			membot  = $fe82 ; Get/set bottom of memory.
=$fe91			tstmem  = $fe91 ; Test a memory location.
=$fea9			nmi     = $fea9 ; NMI handler routine.
=$fed2			break   = $fed2 ; BREAK interupt entry.
=$fede			rsnmi   = $fede ; RS-232: nmi sequence.
=$ff56			krti    = $ff56 ; Restore 6502 registers frm the stack and return frm interrupt.
=$ff5c			baudtbl = $ff5c ; RS-232: VIA timer 2 values for baud rate table.
=$ff72			irqrout = $ff72 ; irq routine initial 6502 entry point.
=$ff85			c4ffs   = $ff85 ; five unused bytes of 255 ($ff).
=$ff8a			crestor = $ff8a ; Jump to 64850 ($fd52) RESTOR.
=$ff8d			cvector = $ff8d ; Jump to 64855 ($fd57) VECTOR.
=$ff90			csetmsg = $ff90 ; Jump to 65126 ($fe66) SETMSG.
=$ff93			csecond = $ff93 ; Jump to 61120 ($eec0) SECOND.
=$ff96			ctksa   = $ff96 ; Jump to 61134 ($eece) TKSA.
=$ff99			cmemtop = $ff99 ; Jump to 65139 ($fe73) MEMTOP.
=$ff9c			cmembot = $ff9c ; Jump to 65154 ($fe82) MEMBOT.
=$ff9f			cscnkey = $ff9f ; Jump to 60190 ($eb1e) SCNKEY.
=$ffa2			csettmo = $ffa2 ; Jump to 65135 ($fe6f) SETTMO.
=$ffa5			cacptr  = $ffa5 ; Jump to 61209 ($ef19) ACPTR.
=$ffa8			cciout  = $ffa8 ; Jump to 61156 ($eee4) CIOUT.
=$ffab			cuntlk  = $ffab ; Jump to 61174 ($eef6) UNTLK.
=$ffae			cunlsn  = $ffae ; Jump to 61188 ($ef04) UNLSN.
=$ffb1			clisten = $ffb1 ; Jump to 60951 ($ee17) LISTEN.
=$ffb4			ctalk   = $ffb4 ; Jump to 60948 ($ee14) TALK.
=$ffb7			crdst   = $ffb7 ; Jump to 65111 ($fe57) READST.
=$ffba			csetlfs = $ffba ; Jump to 65104 ($fe50) SETLFS.
=$ffbd			csetnam = $ffbd ; Jump to 65097 ($fe49) SETNAM.
=$ffc0			copen   = $ffc0 ; Jump off 794-795 ($031a-$031b) IOPEN.
=$ffc3			cclos   = $ffc3 ; Jump off 796-797 ($031c-$031d) ICLOSE.
=$ffc6			inpchn  = $ffc6 ; Jump off 798-799 ($031e-$031f) ICHKIN.
=$ffc9			outchn  = $ffc9 ; Jump off 800-801 ($0320-$0321) ICKOUT.
=$ffcc			cclrchn = $ffcc ; Jump off 802-803 ($0322-$0323) ICLRCH.
=$ffcf			cinch   = $ffcf ; Jump off 804-805 ($0324-$0325) IBASIN.
=$ffd2			cchrout = $ffd2 ; Jump to 62074 ($f27a) CHROUT.
=$ffd5			cload   = $ffd5 ; Jump to 67286 ($f542) LOAD.
=$ffd8			csave   = $ffd8 ; Jump to 63093 ($f675) SAVE.
=$ffdb			csettim = $ffdb ; Jump to 63335 ($f767) SETTIM.
=$ffde			crdtim  = $ffde ; Jump to 63328 ($f760) RDTIM.
=$ffe1			iscntc  = $ffe1 ; Jump off 808-809 ($0328-$0329) ISTOP.
=$ffe4			cgetl   = $ffe4 ; Jump off 810-811 ($032a-$032b) IGETIN.
=$ffe7			ccall   = $ffe7 ; Jump off 812-813 ($032c-$032d) ICALL.
=$ffea			cudtim  = $ffea ; Jump to 63284 ($f734) UDTIM.
=$ffed			cscreen = $ffed ; Jump to 58629 ($e505) SCRN.
=$fff0			cplot   = $fff0 ; Jump to 58634 ($e50a) PLOT.
=$fff3			ciobase = $fff3 ; Jump to 58624 ($e500) IOBASE.
=$fffa			vctrnmi = $fffa ; 6502 vector to 65193 ($fea9) NMI.
=$fffc			vctrrst = $fffc ; 6502 vector to 64802 ($fd22) START.
=$fffe			vctrirq = $fffe ; 6502 vector to 65394 ($ff72) BREAK.
=$e043			kd_poly1     =   $e043
=$e059			kd_poly2     =   $e059
=$e08d			kd_rmulc     =   $e08d       ;
=$e092			kd_raddc     =   $e092       ;
=$e097			kd_rnd       =   $e097
=$e12a			kd_sys       =   $e12a
=$e156			kd_save      =   $e156
=$e165			kd_verify    =   $e165
=$e168			kd_load      =   $e168
=error			kcint       =   cint        ;   , init vic + ecran.
=error			kioinit     =   ioinit      ;   , init i/o dev.
=error			kramtas     =   ramtas      ;   , test de memoire.
=$eee4			kciout      =   ciout       ;a  ,tx byte  acia
=$fd52			krestor     =   restor      ;   , set ram plafond
=$fd57			kvector     =   vector      ;
=$fe66			ksetmsg     =   setmsg      ;a  , set sys. msg. out
=$eec0			ksecond     =   second      ;a  , tx adresse sec.
=$eece			ktksa       =   tksa        ;a  , talk adresse sec.
=$fe73			kmemtop     =   memtop      ; yx, (c) get mem high
=$fe82			kmembot     =   membot      ; yx, (c) get mem low
=error			kscankey    =   scankey     ;   , scan clavier
=$fe6f			ksettmo     =   settmo      ;a  , set ieee timeout
=$ef19			kacptr      =   acptr       ;a  ,rx serie.
=$eef6			kuntlk      =   untlk       ;   , iec-cmc stop talk
=$ef04			kunlsn      =   unlsn       ;   , iec-cmd stop lsn
=$ee17			klisten     =   listen      ;a  , iec-cmd dev ecout
=$ee14			ktalk       =   talk        ;a  , iec-cmd dev parle
=$fe57			kreadst     =   readst      ;a  , lecture i/o stats
=$fe50			ksetlfs     =   setlfs      ;ayx, init fich logi.
=$fe49			ksetnam     =   setnam      ;ayx, init num.nom.fich
=$f40a			kopen       =   open        ;axy, ouvre fich-nom
=$f34a			kclose      =   close       ;a  , ferme fichier #a.
=$f2c7			kchkin      =   chkin       ;  x,open canal in.
=$f309			kchkout     =   chkout      ;  x,open canal out
=$f3f3			kclrchn     =   clrchn      ;   , ferme canaux i/o.
=$f20e			kchrin      =   chrin       ;a  ,recup. un car.
=$f27a			kchrout     =   chrout      ;a  ,sort un car.
=$f1ca			kd_chrout    =   $f1ca
=$f542			kload       =   load        ;ayx, dev->ram
=$f675			ksave       =   save        ;   , sauve mem->dev
=$f767			ksettim     =   settim      ;axy, init sysclock
=$f760			krdtim      =   rdtim       ;axy, lecture sysclock
=$f770			kstop       =   stop        ;a  , ret. stopkey stat
=$f1f5			kgetin      =   getin       ;a  , recup. car. #dev.
=$f3ef			kclall      =   clall       ;   , ferme fichiers.
=$f734			kudtim      =   udtim       ;   , maj sysclock
=$e505			kscreen     =   screen      ; yx, get format ecran
=$e50a			kplot       =   plot        ; yx, (c) get csr pos.
=$e500			kiobase     =   iobase      ; yx, def. i/o mem page
=$e39a			k_echostartup = $e39a
=$e716			k_putch       = $e716 ; 52) Print a character.          ;a--;---; a = char
=$e7a0			k_cls         = $e7a0
=$e87c			k_cursordown  = $e87c
=$e8ea			k_scrollup    = $e8ea
=$e94e			k_home        = $e94e
=$e965			k_insertline  = $e965
=$e9c8			k_screlldown  = $e9c8
=$ed0c			k_devsndlstn  = $ed0c ; 55) Send 'LISTEN'>IEEE/Serial.  ;a--;---; a = dev #
=$ee13			k_ieeein      = $ee13 ; 60) Input from IEEE/Serial.     ;---;a--; a = Data byte
=$eef6			k_devsndutalk = $eef6 ; 58) Send 'UNTALK'>IEEE/Serial.  ;---;---;
=$ef04			k_devsndulstn = $ef04 ; 59) Send 'UNLISTEN'>IEEE/Serial.;---;---;
=$f12f			k_putsysmsg   = $f12f ; 53) Print system message.       ;--y;---; y = msg offset
=$f291			k_cloself     = $f291 ; 61) Close logical file .        ;a--;---; a = file #
=$f49e			k_loadsub     = $f49e ; 63) LOAD subroutine.            ;axy;---; a = # start=yyxx
=$f5af			k_prnsrch     = $f5af ; 64) Print SEARCHING if imm mode.;---;---;
=$f5b3			k_echosearch  = $f5b3 ; 64b) Skipping test part of 64.  ;---;---;
=$f5c1			k_prnfnam     = $f5c1 ; 65) Print filename.             ;---;---;
=$f6ed			k_stop        = $f6ed ; 62) Check for STOP key.         ;---;---; z = 1 pressed
=$f7ea			k_gettaphdblk = $f7ea ; 66) Find a tape hdr blk.        ;a--;---; a = len
=$f7ea			k_fndtaphdblk = $f7ea ; 67) Find any tape hdr blk.      ;---;---;
=$f817			k_waittapplay = $f817 ; 68) Press PLAY... (wait)        ;---;---;
=$f841			k_rdtape2buff = $f841 ; 69) Read tape to buffer.        ;---;---;
=$f847			k_readtape    = $f847 ; 70) Read tape.                  ;---;---;
=$f864			k_wrbuff2tape = $f864 ; 71) write buffer to tape.       ;---;---;
=$f869			k_wrtape      = $f869 ; 72) write tape.                 ;a--;---; a = ldr len
=$fb8e			k_resettapeio = $fb8e ; 73) Reset tape I/O.             ;---;---;
=$fcbd			k_setintvect  = $fcbd ; 74) set interupt vector.        ;---;---;
=$fce2			k_coldreset   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldstart   = $fce2 ; 75) Power on reset.             ;---;---;
=$fce2			k_coldboot    = $fce2 ; 75) Power on reset.             ;---;---;
=$fe66			k_warmreset   = $fe66 ;     Warm resetstart
=$fe66			k_warmboot    = $fe66 ;     Warm resetstart
=$ff93			k_devsndaddr2 = $ff93 ; 56) Send second address.        ;a--;---; a = SA or #$60
=0			kerr00 = 0      ; routine ended by the stop key.
=1			kerr01 = 1      ; too many files open.
=2			kerr02 = 2      ; file already open.
=3			kerr03 = 3      ; file not open.
=4			kerr04 = 4      ; file not found.
=5			kerr05 = 5      ; device not present.
=6			kerr06 = 6      ; file is not an input file.
=7			kerr07 = 7      ; file is not an output file.
=8			kerr08 = 8      ; file name is missing.
=9			kerr09 = 9      ; illegal device number.
=240			kerrf0 = 240    ; top-of-memory change rs-232 buffer allocation.
.1c06	4c 3f 12	pgmstart        jmp      main  ; le programme principale doit s'appeler "main"

;******  Return to file: template.asm


;******  End of listing
